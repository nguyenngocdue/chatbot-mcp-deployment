function tO(e, t) {
  for (var n = 0; n < t.length; n++) {
    const o = t[n];
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const i in o)
        if (i !== "default" && !(i in e)) {
          const l = Object.getOwnPropertyDescriptor(o, i);
          l && Object.defineProperty(e, i, l.get ? l : {
            enumerable: !0,
            get: () => o[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function jl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function nO(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function o() {
      var i = !1;
      try {
        i = this instanceof o;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(o) {
    var i = Object.getOwnPropertyDescriptor(e, o);
    Object.defineProperty(n, o, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[o];
      }
    });
  }), n;
}
var wp = { exports: {} }, Ce = {};
var nS;
function rO() {
  if (nS) return Ce;
  nS = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), o = /* @__PURE__ */ Symbol.for("react.strict_mode"), i = /* @__PURE__ */ Symbol.for("react.profiler"), l = /* @__PURE__ */ Symbol.for("react.consumer"), c = /* @__PURE__ */ Symbol.for("react.context"), f = /* @__PURE__ */ Symbol.for("react.forward_ref"), d = /* @__PURE__ */ Symbol.for("react.suspense"), h = /* @__PURE__ */ Symbol.for("react.memo"), m = /* @__PURE__ */ Symbol.for("react.lazy"), v = /* @__PURE__ */ Symbol.for("react.activity"), b = Symbol.iterator;
  function x(j) {
    return j === null || typeof j != "object" ? null : (j = b && j[b] || j["@@iterator"], typeof j == "function" ? j : null);
  }
  var E = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, w = Object.assign, C = {};
  function A(j, W, $) {
    this.props = j, this.context = W, this.refs = C, this.updater = $ || E;
  }
  A.prototype.isReactComponent = {}, A.prototype.setState = function(j, W) {
    if (typeof j != "object" && typeof j != "function" && j != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, j, W, "setState");
  }, A.prototype.forceUpdate = function(j) {
    this.updater.enqueueForceUpdate(this, j, "forceUpdate");
  };
  function M() {
  }
  M.prototype = A.prototype;
  function T(j, W, $) {
    this.props = j, this.context = W, this.refs = C, this.updater = $ || E;
  }
  var D = T.prototype = new M();
  D.constructor = T, w(D, A.prototype), D.isPureReactComponent = !0;
  var O = Array.isArray;
  function k() {
  }
  var R = { H: null, A: null, T: null, S: null }, N = Object.prototype.hasOwnProperty;
  function P(j, W, $) {
    var X = $.ref;
    return {
      $$typeof: e,
      type: j,
      key: W,
      ref: X !== void 0 ? X : null,
      props: $
    };
  }
  function Y(j, W) {
    return P(j.type, W, j.props);
  }
  function ne(j) {
    return typeof j == "object" && j !== null && j.$$typeof === e;
  }
  function J(j) {
    var W = { "=": "=0", ":": "=2" };
    return "$" + j.replace(/[=:]/g, function($) {
      return W[$];
    });
  }
  var ce = /\/+/g;
  function ue(j, W) {
    return typeof j == "object" && j !== null && j.key != null ? J("" + j.key) : W.toString(36);
  }
  function de(j) {
    switch (j.status) {
      case "fulfilled":
        return j.value;
      case "rejected":
        throw j.reason;
      default:
        switch (typeof j.status == "string" ? j.then(k, k) : (j.status = "pending", j.then(
          function(W) {
            j.status === "pending" && (j.status = "fulfilled", j.value = W);
          },
          function(W) {
            j.status === "pending" && (j.status = "rejected", j.reason = W);
          }
        )), j.status) {
          case "fulfilled":
            return j.value;
          case "rejected":
            throw j.reason;
        }
    }
    throw j;
  }
  function I(j, W, $, X, se) {
    var ie = typeof j;
    (ie === "undefined" || ie === "boolean") && (j = null);
    var H = !1;
    if (j === null) H = !0;
    else
      switch (ie) {
        case "bigint":
        case "string":
        case "number":
          H = !0;
          break;
        case "object":
          switch (j.$$typeof) {
            case e:
            case t:
              H = !0;
              break;
            case m:
              return H = j._init, I(
                H(j._payload),
                W,
                $,
                X,
                se
              );
          }
      }
    if (H)
      return se = se(j), H = X === "" ? "." + ue(j, 0) : X, O(se) ? ($ = "", H != null && ($ = H.replace(ce, "$&/") + "/"), I(se, W, $, "", function(fe) {
        return fe;
      })) : se != null && (ne(se) && (se = Y(
        se,
        $ + (se.key == null || j && j.key === se.key ? "" : ("" + se.key).replace(
          ce,
          "$&/"
        ) + "/") + H
      )), W.push(se)), 1;
    H = 0;
    var re = X === "" ? "." : X + ":";
    if (O(j))
      for (var le = 0; le < j.length; le++)
        X = j[le], ie = re + ue(X, le), H += I(
          X,
          W,
          $,
          ie,
          se
        );
    else if (le = x(j), typeof le == "function")
      for (j = le.call(j), le = 0; !(X = j.next()).done; )
        X = X.value, ie = re + ue(X, le++), H += I(
          X,
          W,
          $,
          ie,
          se
        );
    else if (ie === "object") {
      if (typeof j.then == "function")
        return I(
          de(j),
          W,
          $,
          X,
          se
        );
      throw W = String(j), Error(
        "Objects are not valid as a React child (found: " + (W === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : W) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return H;
  }
  function G(j, W, $) {
    if (j == null) return j;
    var X = [], se = 0;
    return I(j, X, "", "", function(ie) {
      return W.call($, ie, se++);
    }), X;
  }
  function U(j) {
    if (j._status === -1) {
      var W = j._result;
      W = W(), W.then(
        function($) {
          (j._status === 0 || j._status === -1) && (j._status = 1, j._result = $);
        },
        function($) {
          (j._status === 0 || j._status === -1) && (j._status = 2, j._result = $);
        }
      ), j._status === -1 && (j._status = 0, j._result = W);
    }
    if (j._status === 1) return j._result.default;
    throw j._result;
  }
  var te = typeof reportError == "function" ? reportError : function(j) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var W = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof j == "object" && j !== null && typeof j.message == "string" ? String(j.message) : String(j),
        error: j
      });
      if (!window.dispatchEvent(W)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", j);
      return;
    }
    console.error(j);
  }, he = {
    map: G,
    forEach: function(j, W, $) {
      G(
        j,
        function() {
          W.apply(this, arguments);
        },
        $
      );
    },
    count: function(j) {
      var W = 0;
      return G(j, function() {
        W++;
      }), W;
    },
    toArray: function(j) {
      return G(j, function(W) {
        return W;
      }) || [];
    },
    only: function(j) {
      if (!ne(j))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return j;
    }
  };
  return Ce.Activity = v, Ce.Children = he, Ce.Component = A, Ce.Fragment = n, Ce.Profiler = i, Ce.PureComponent = T, Ce.StrictMode = o, Ce.Suspense = d, Ce.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = R, Ce.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(j) {
      return R.H.useMemoCache(j);
    }
  }, Ce.cache = function(j) {
    return function() {
      return j.apply(null, arguments);
    };
  }, Ce.cacheSignal = function() {
    return null;
  }, Ce.cloneElement = function(j, W, $) {
    if (j == null)
      throw Error(
        "The argument must be a React element, but you passed " + j + "."
      );
    var X = w({}, j.props), se = j.key;
    if (W != null)
      for (ie in W.key !== void 0 && (se = "" + W.key), W)
        !N.call(W, ie) || ie === "key" || ie === "__self" || ie === "__source" || ie === "ref" && W.ref === void 0 || (X[ie] = W[ie]);
    var ie = arguments.length - 2;
    if (ie === 1) X.children = $;
    else if (1 < ie) {
      for (var H = Array(ie), re = 0; re < ie; re++)
        H[re] = arguments[re + 2];
      X.children = H;
    }
    return P(j.type, se, X);
  }, Ce.createContext = function(j) {
    return j = {
      $$typeof: c,
      _currentValue: j,
      _currentValue2: j,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, j.Provider = j, j.Consumer = {
      $$typeof: l,
      _context: j
    }, j;
  }, Ce.createElement = function(j, W, $) {
    var X, se = {}, ie = null;
    if (W != null)
      for (X in W.key !== void 0 && (ie = "" + W.key), W)
        N.call(W, X) && X !== "key" && X !== "__self" && X !== "__source" && (se[X] = W[X]);
    var H = arguments.length - 2;
    if (H === 1) se.children = $;
    else if (1 < H) {
      for (var re = Array(H), le = 0; le < H; le++)
        re[le] = arguments[le + 2];
      se.children = re;
    }
    if (j && j.defaultProps)
      for (X in H = j.defaultProps, H)
        se[X] === void 0 && (se[X] = H[X]);
    return P(j, ie, se);
  }, Ce.createRef = function() {
    return { current: null };
  }, Ce.forwardRef = function(j) {
    return { $$typeof: f, render: j };
  }, Ce.isValidElement = ne, Ce.lazy = function(j) {
    return {
      $$typeof: m,
      _payload: { _status: -1, _result: j },
      _init: U
    };
  }, Ce.memo = function(j, W) {
    return {
      $$typeof: h,
      type: j,
      compare: W === void 0 ? null : W
    };
  }, Ce.startTransition = function(j) {
    var W = R.T, $ = {};
    R.T = $;
    try {
      var X = j(), se = R.S;
      se !== null && se($, X), typeof X == "object" && X !== null && typeof X.then == "function" && X.then(k, te);
    } catch (ie) {
      te(ie);
    } finally {
      W !== null && $.types !== null && (W.types = $.types), R.T = W;
    }
  }, Ce.unstable_useCacheRefresh = function() {
    return R.H.useCacheRefresh();
  }, Ce.use = function(j) {
    return R.H.use(j);
  }, Ce.useActionState = function(j, W, $) {
    return R.H.useActionState(j, W, $);
  }, Ce.useCallback = function(j, W) {
    return R.H.useCallback(j, W);
  }, Ce.useContext = function(j) {
    return R.H.useContext(j);
  }, Ce.useDebugValue = function() {
  }, Ce.useDeferredValue = function(j, W) {
    return R.H.useDeferredValue(j, W);
  }, Ce.useEffect = function(j, W) {
    return R.H.useEffect(j, W);
  }, Ce.useEffectEvent = function(j) {
    return R.H.useEffectEvent(j);
  }, Ce.useId = function() {
    return R.H.useId();
  }, Ce.useImperativeHandle = function(j, W, $) {
    return R.H.useImperativeHandle(j, W, $);
  }, Ce.useInsertionEffect = function(j, W) {
    return R.H.useInsertionEffect(j, W);
  }, Ce.useLayoutEffect = function(j, W) {
    return R.H.useLayoutEffect(j, W);
  }, Ce.useMemo = function(j, W) {
    return R.H.useMemo(j, W);
  }, Ce.useOptimistic = function(j, W) {
    return R.H.useOptimistic(j, W);
  }, Ce.useReducer = function(j, W, $) {
    return R.H.useReducer(j, W, $);
  }, Ce.useRef = function(j) {
    return R.H.useRef(j);
  }, Ce.useState = function(j) {
    return R.H.useState(j);
  }, Ce.useSyncExternalStore = function(j, W, $) {
    return R.H.useSyncExternalStore(
      j,
      W,
      $
    );
  }, Ce.useTransition = function() {
    return R.H.useTransition();
  }, Ce.version = "19.2.4", Ce;
}
var rS;
function kl() {
  return rS || (rS = 1, wp.exports = rO()), wp.exports;
}
var y = kl();
const Jn = /* @__PURE__ */ jl(y), Tf = /* @__PURE__ */ tO({
  __proto__: null,
  default: Jn
}, [y]);
var Ep = { exports: {} }, qs = {}, _p = { exports: {} }, Tp = {};
var oS;
function oO() {
  return oS || (oS = 1, (function(e) {
    function t(I, G) {
      var U = I.length;
      I.push(G);
      e: for (; 0 < U; ) {
        var te = U - 1 >>> 1, he = I[te];
        if (0 < i(he, G))
          I[te] = G, I[U] = he, U = te;
        else break e;
      }
    }
    function n(I) {
      return I.length === 0 ? null : I[0];
    }
    function o(I) {
      if (I.length === 0) return null;
      var G = I[0], U = I.pop();
      if (U !== G) {
        I[0] = U;
        e: for (var te = 0, he = I.length, j = he >>> 1; te < j; ) {
          var W = 2 * (te + 1) - 1, $ = I[W], X = W + 1, se = I[X];
          if (0 > i($, U))
            X < he && 0 > i(se, $) ? (I[te] = se, I[X] = U, te = X) : (I[te] = $, I[W] = U, te = W);
          else if (X < he && 0 > i(se, U))
            I[te] = se, I[X] = U, te = X;
          else break e;
        }
      }
      return G;
    }
    function i(I, G) {
      var U = I.sortIndex - G.sortIndex;
      return U !== 0 ? U : I.id - G.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var l = performance;
      e.unstable_now = function() {
        return l.now();
      };
    } else {
      var c = Date, f = c.now();
      e.unstable_now = function() {
        return c.now() - f;
      };
    }
    var d = [], h = [], m = 1, v = null, b = 3, x = !1, E = !1, w = !1, C = !1, A = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
    function D(I) {
      for (var G = n(h); G !== null; ) {
        if (G.callback === null) o(h);
        else if (G.startTime <= I)
          o(h), G.sortIndex = G.expirationTime, t(d, G);
        else break;
        G = n(h);
      }
    }
    function O(I) {
      if (w = !1, D(I), !E)
        if (n(d) !== null)
          E = !0, k || (k = !0, J());
        else {
          var G = n(h);
          G !== null && de(O, G.startTime - I);
        }
    }
    var k = !1, R = -1, N = 5, P = -1;
    function Y() {
      return C ? !0 : !(e.unstable_now() - P < N);
    }
    function ne() {
      if (C = !1, k) {
        var I = e.unstable_now();
        P = I;
        var G = !0;
        try {
          e: {
            E = !1, w && (w = !1, M(R), R = -1), x = !0;
            var U = b;
            try {
              t: {
                for (D(I), v = n(d); v !== null && !(v.expirationTime > I && Y()); ) {
                  var te = v.callback;
                  if (typeof te == "function") {
                    v.callback = null, b = v.priorityLevel;
                    var he = te(
                      v.expirationTime <= I
                    );
                    if (I = e.unstable_now(), typeof he == "function") {
                      v.callback = he, D(I), G = !0;
                      break t;
                    }
                    v === n(d) && o(d), D(I);
                  } else o(d);
                  v = n(d);
                }
                if (v !== null) G = !0;
                else {
                  var j = n(h);
                  j !== null && de(
                    O,
                    j.startTime - I
                  ), G = !1;
                }
              }
              break e;
            } finally {
              v = null, b = U, x = !1;
            }
            G = void 0;
          }
        } finally {
          G ? J() : k = !1;
        }
      }
    }
    var J;
    if (typeof T == "function")
      J = function() {
        T(ne);
      };
    else if (typeof MessageChannel < "u") {
      var ce = new MessageChannel(), ue = ce.port2;
      ce.port1.onmessage = ne, J = function() {
        ue.postMessage(null);
      };
    } else
      J = function() {
        A(ne, 0);
      };
    function de(I, G) {
      R = A(function() {
        I(e.unstable_now());
      }, G);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(I) {
      I.callback = null;
    }, e.unstable_forceFrameRate = function(I) {
      0 > I || 125 < I ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : N = 0 < I ? Math.floor(1e3 / I) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return b;
    }, e.unstable_next = function(I) {
      switch (b) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = b;
      }
      var U = b;
      b = G;
      try {
        return I();
      } finally {
        b = U;
      }
    }, e.unstable_requestPaint = function() {
      C = !0;
    }, e.unstable_runWithPriority = function(I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var U = b;
      b = I;
      try {
        return G();
      } finally {
        b = U;
      }
    }, e.unstable_scheduleCallback = function(I, G, U) {
      var te = e.unstable_now();
      switch (typeof U == "object" && U !== null ? (U = U.delay, U = typeof U == "number" && 0 < U ? te + U : te) : U = te, I) {
        case 1:
          var he = -1;
          break;
        case 2:
          he = 250;
          break;
        case 5:
          he = 1073741823;
          break;
        case 4:
          he = 1e4;
          break;
        default:
          he = 5e3;
      }
      return he = U + he, I = {
        id: m++,
        callback: G,
        priorityLevel: I,
        startTime: U,
        expirationTime: he,
        sortIndex: -1
      }, U > te ? (I.sortIndex = U, t(h, I), n(d) === null && I === n(h) && (w ? (M(R), R = -1) : w = !0, de(O, U - te))) : (I.sortIndex = he, t(d, I), E || x || (E = !0, k || (k = !0, J()))), I;
    }, e.unstable_shouldYield = Y, e.unstable_wrapCallback = function(I) {
      var G = b;
      return function() {
        var U = b;
        b = G;
        try {
          return I.apply(this, arguments);
        } finally {
          b = U;
        }
      };
    };
  })(Tp)), Tp;
}
var aS;
function aO() {
  return aS || (aS = 1, _p.exports = oO()), _p.exports;
}
var Cp = { exports: {} }, Zt = {};
var iS;
function iO() {
  if (iS) return Zt;
  iS = 1;
  var e = kl();
  function t(d) {
    var h = "https://react.dev/errors/" + d;
    if (1 < arguments.length) {
      h += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var m = 2; m < arguments.length; m++)
        h += "&args[]=" + encodeURIComponent(arguments[m]);
    }
    return "Minified React error #" + d + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var o = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, i = /* @__PURE__ */ Symbol.for("react.portal");
  function l(d, h, m) {
    var v = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: v == null ? null : "" + v,
      children: d,
      containerInfo: h,
      implementation: m
    };
  }
  var c = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function f(d, h) {
    if (d === "font") return "";
    if (typeof h == "string")
      return h === "use-credentials" ? h : "";
  }
  return Zt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = o, Zt.createPortal = function(d, h) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
      throw Error(t(299));
    return l(d, h, null, m);
  }, Zt.flushSync = function(d) {
    var h = c.T, m = o.p;
    try {
      if (c.T = null, o.p = 2, d) return d();
    } finally {
      c.T = h, o.p = m, o.d.f();
    }
  }, Zt.preconnect = function(d, h) {
    typeof d == "string" && (h ? (h = h.crossOrigin, h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null, o.d.C(d, h));
  }, Zt.prefetchDNS = function(d) {
    typeof d == "string" && o.d.D(d);
  }, Zt.preinit = function(d, h) {
    if (typeof d == "string" && h && typeof h.as == "string") {
      var m = h.as, v = f(m, h.crossOrigin), b = typeof h.integrity == "string" ? h.integrity : void 0, x = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
      m === "style" ? o.d.S(
        d,
        typeof h.precedence == "string" ? h.precedence : void 0,
        {
          crossOrigin: v,
          integrity: b,
          fetchPriority: x
        }
      ) : m === "script" && o.d.X(d, {
        crossOrigin: v,
        integrity: b,
        fetchPriority: x,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0
      });
    }
  }, Zt.preinitModule = function(d, h) {
    if (typeof d == "string")
      if (typeof h == "object" && h !== null) {
        if (h.as == null || h.as === "script") {
          var m = f(
            h.as,
            h.crossOrigin
          );
          o.d.M(d, {
            crossOrigin: m,
            integrity: typeof h.integrity == "string" ? h.integrity : void 0,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0
          });
        }
      } else h == null && o.d.M(d);
  }, Zt.preload = function(d, h) {
    if (typeof d == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
      var m = h.as, v = f(m, h.crossOrigin);
      o.d.L(d, m, {
        crossOrigin: v,
        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
        nonce: typeof h.nonce == "string" ? h.nonce : void 0,
        type: typeof h.type == "string" ? h.type : void 0,
        fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
        referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
        imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
        imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
        media: typeof h.media == "string" ? h.media : void 0
      });
    }
  }, Zt.preloadModule = function(d, h) {
    if (typeof d == "string")
      if (h) {
        var m = f(h.as, h.crossOrigin);
        o.d.m(d, {
          as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
          crossOrigin: m,
          integrity: typeof h.integrity == "string" ? h.integrity : void 0
        });
      } else o.d.m(d);
  }, Zt.requestFormReset = function(d) {
    o.d.r(d);
  }, Zt.unstable_batchedUpdates = function(d, h) {
    return d(h);
  }, Zt.useFormState = function(d, h, m) {
    return c.H.useFormState(d, h, m);
  }, Zt.useFormStatus = function() {
    return c.H.useHostTransitionStatus();
  }, Zt.version = "19.2.4", Zt;
}
var sS;
function Cf() {
  if (sS) return Cp.exports;
  sS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Cp.exports = iO(), Cp.exports;
}
var lS;
function sO() {
  if (lS) return qs;
  lS = 1;
  var e = aO(), t = kl(), n = Cf();
  function o(r) {
    var a = "https://react.dev/errors/" + r;
    if (1 < arguments.length) {
      a += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var s = 2; s < arguments.length; s++)
        a += "&args[]=" + encodeURIComponent(arguments[s]);
    }
    return "Minified React error #" + r + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function i(r) {
    return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
  }
  function l(r) {
    var a = r, s = r;
    if (r.alternate) for (; a.return; ) a = a.return;
    else {
      r = a;
      do
        a = r, (a.flags & 4098) !== 0 && (s = a.return), r = a.return;
      while (r);
    }
    return a.tag === 3 ? s : null;
  }
  function c(r) {
    if (r.tag === 13) {
      var a = r.memoizedState;
      if (a === null && (r = r.alternate, r !== null && (a = r.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function f(r) {
    if (r.tag === 31) {
      var a = r.memoizedState;
      if (a === null && (r = r.alternate, r !== null && (a = r.memoizedState)), a !== null) return a.dehydrated;
    }
    return null;
  }
  function d(r) {
    if (l(r) !== r)
      throw Error(o(188));
  }
  function h(r) {
    var a = r.alternate;
    if (!a) {
      if (a = l(r), a === null) throw Error(o(188));
      return a !== r ? null : r;
    }
    for (var s = r, u = a; ; ) {
      var p = s.return;
      if (p === null) break;
      var g = p.alternate;
      if (g === null) {
        if (u = p.return, u !== null) {
          s = u;
          continue;
        }
        break;
      }
      if (p.child === g.child) {
        for (g = p.child; g; ) {
          if (g === s) return d(p), r;
          if (g === u) return d(p), a;
          g = g.sibling;
        }
        throw Error(o(188));
      }
      if (s.return !== u.return) s = p, u = g;
      else {
        for (var _ = !1, z = p.child; z; ) {
          if (z === s) {
            _ = !0, s = p, u = g;
            break;
          }
          if (z === u) {
            _ = !0, u = p, s = g;
            break;
          }
          z = z.sibling;
        }
        if (!_) {
          for (z = g.child; z; ) {
            if (z === s) {
              _ = !0, s = g, u = p;
              break;
            }
            if (z === u) {
              _ = !0, u = g, s = p;
              break;
            }
            z = z.sibling;
          }
          if (!_) throw Error(o(189));
        }
      }
      if (s.alternate !== u) throw Error(o(190));
    }
    if (s.tag !== 3) throw Error(o(188));
    return s.stateNode.current === s ? r : a;
  }
  function m(r) {
    var a = r.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return r;
    for (r = r.child; r !== null; ) {
      if (a = m(r), a !== null) return a;
      r = r.sibling;
    }
    return null;
  }
  var v = Object.assign, b = /* @__PURE__ */ Symbol.for("react.element"), x = /* @__PURE__ */ Symbol.for("react.transitional.element"), E = /* @__PURE__ */ Symbol.for("react.portal"), w = /* @__PURE__ */ Symbol.for("react.fragment"), C = /* @__PURE__ */ Symbol.for("react.strict_mode"), A = /* @__PURE__ */ Symbol.for("react.profiler"), M = /* @__PURE__ */ Symbol.for("react.consumer"), T = /* @__PURE__ */ Symbol.for("react.context"), D = /* @__PURE__ */ Symbol.for("react.forward_ref"), O = /* @__PURE__ */ Symbol.for("react.suspense"), k = /* @__PURE__ */ Symbol.for("react.suspense_list"), R = /* @__PURE__ */ Symbol.for("react.memo"), N = /* @__PURE__ */ Symbol.for("react.lazy"), P = /* @__PURE__ */ Symbol.for("react.activity"), Y = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), ne = Symbol.iterator;
  function J(r) {
    return r === null || typeof r != "object" ? null : (r = ne && r[ne] || r["@@iterator"], typeof r == "function" ? r : null);
  }
  var ce = /* @__PURE__ */ Symbol.for("react.client.reference");
  function ue(r) {
    if (r == null) return null;
    if (typeof r == "function")
      return r.$$typeof === ce ? null : r.displayName || r.name || null;
    if (typeof r == "string") return r;
    switch (r) {
      case w:
        return "Fragment";
      case A:
        return "Profiler";
      case C:
        return "StrictMode";
      case O:
        return "Suspense";
      case k:
        return "SuspenseList";
      case P:
        return "Activity";
    }
    if (typeof r == "object")
      switch (r.$$typeof) {
        case E:
          return "Portal";
        case T:
          return r.displayName || "Context";
        case M:
          return (r._context.displayName || "Context") + ".Consumer";
        case D:
          var a = r.render;
          return r = r.displayName, r || (r = a.displayName || a.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case R:
          return a = r.displayName || null, a !== null ? a : ue(r.type) || "Memo";
        case N:
          a = r._payload, r = r._init;
          try {
            return ue(r(a));
          } catch {
          }
      }
    return null;
  }
  var de = Array.isArray, I = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, G = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, U = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, te = [], he = -1;
  function j(r) {
    return { current: r };
  }
  function W(r) {
    0 > he || (r.current = te[he], te[he] = null, he--);
  }
  function $(r, a) {
    he++, te[he] = r.current, r.current = a;
  }
  var X = j(null), se = j(null), ie = j(null), H = j(null);
  function re(r, a) {
    switch ($(ie, a), $(se, r), $(X, null), a.nodeType) {
      case 9:
      case 11:
        r = (r = a.documentElement) && (r = r.namespaceURI) ? Tx(r) : 0;
        break;
      default:
        if (r = a.tagName, a = a.namespaceURI)
          a = Tx(a), r = Cx(a, r);
        else
          switch (r) {
            case "svg":
              r = 1;
              break;
            case "math":
              r = 2;
              break;
            default:
              r = 0;
          }
    }
    W(X), $(X, r);
  }
  function le() {
    W(X), W(se), W(ie);
  }
  function fe(r) {
    r.memoizedState !== null && $(H, r);
    var a = X.current, s = Cx(a, r.type);
    a !== s && ($(se, r), $(X, s));
  }
  function me(r) {
    se.current === r && (W(X), W(se)), H.current === r && (W(H), Zs._currentValue = U);
  }
  var Re, je;
  function Qe(r) {
    if (Re === void 0)
      try {
        throw Error();
      } catch (s) {
        var a = s.stack.trim().match(/\n( *(at )?)/);
        Re = a && a[1] || "", je = -1 < s.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < s.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Re + r + je;
  }
  var un = !1;
  function Tn(r, a) {
    if (!r || un) return "";
    un = !0;
    var s = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var u = {
        DetermineComponentFrameRoot: function() {
          try {
            if (a) {
              var ae = function() {
                throw Error();
              };
              if (Object.defineProperty(ae.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(ae, []);
                } catch (K) {
                  var q = K;
                }
                Reflect.construct(r, [], ae);
              } else {
                try {
                  ae.call();
                } catch (K) {
                  q = K;
                }
                r.call(ae.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (K) {
                q = K;
              }
              (ae = r()) && typeof ae.catch == "function" && ae.catch(function() {
              });
            }
          } catch (K) {
            if (K && q && typeof K.stack == "string")
              return [K.stack, q.stack];
          }
          return [null, null];
        }
      };
      u.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var p = Object.getOwnPropertyDescriptor(
        u.DetermineComponentFrameRoot,
        "name"
      );
      p && p.configurable && Object.defineProperty(
        u.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var g = u.DetermineComponentFrameRoot(), _ = g[0], z = g[1];
      if (_ && z) {
        var L = _.split(`
`), F = z.split(`
`);
        for (p = u = 0; u < L.length && !L[u].includes("DetermineComponentFrameRoot"); )
          u++;
        for (; p < F.length && !F[p].includes(
          "DetermineComponentFrameRoot"
        ); )
          p++;
        if (u === L.length || p === F.length)
          for (u = L.length - 1, p = F.length - 1; 1 <= u && 0 <= p && L[u] !== F[p]; )
            p--;
        for (; 1 <= u && 0 <= p; u--, p--)
          if (L[u] !== F[p]) {
            if (u !== 1 || p !== 1)
              do
                if (u--, p--, 0 > p || L[u] !== F[p]) {
                  var Q = `
` + L[u].replace(" at new ", " at ");
                  return r.displayName && Q.includes("<anonymous>") && (Q = Q.replace("<anonymous>", r.displayName)), Q;
                }
              while (1 <= u && 0 <= p);
            break;
          }
      }
    } finally {
      un = !1, Error.prepareStackTrace = s;
    }
    return (s = r ? r.displayName || r.name : "") ? Qe(s) : "";
  }
  function Sr(r, a) {
    switch (r.tag) {
      case 26:
      case 27:
      case 5:
        return Qe(r.type);
      case 16:
        return Qe("Lazy");
      case 13:
        return r.child !== a && a !== null ? Qe("Suspense Fallback") : Qe("Suspense");
      case 19:
        return Qe("SuspenseList");
      case 0:
      case 15:
        return Tn(r.type, !1);
      case 11:
        return Tn(r.type.render, !1);
      case 1:
        return Tn(r.type, !0);
      case 31:
        return Qe("Activity");
      default:
        return "";
    }
  }
  function kt(r) {
    try {
      var a = "", s = null;
      do
        a += Sr(r, s), s = r, r = r.return;
      while (r);
      return a;
    } catch (u) {
      return `
Error generating stack: ` + u.message + `
` + u.stack;
    }
  }
  var za = Object.prototype.hasOwnProperty, ts = e.unstable_scheduleCallback, wr = e.unstable_cancelCallback, Wl = e.unstable_shouldYield, cd = e.unstable_requestPaint, fn = e.unstable_now, kz = e.unstable_getCurrentPriorityLevel, ry = e.unstable_ImmediatePriority, oy = e.unstable_UserBlockingPriority, Xl = e.unstable_NormalPriority, Pz = e.unstable_LowPriority, ay = e.unstable_IdlePriority, Lz = e.log, Iz = e.unstable_setDisableYieldValue, ns = null, dn = null;
  function Wr(r) {
    if (typeof Lz == "function" && Iz(r), dn && typeof dn.setStrictMode == "function")
      try {
        dn.setStrictMode(ns, r);
      } catch {
      }
  }
  var hn = Math.clz32 ? Math.clz32 : Bz, Vz = Math.log, Uz = Math.LN2;
  function Bz(r) {
    return r >>>= 0, r === 0 ? 32 : 31 - (Vz(r) / Uz | 0) | 0;
  }
  var Kl = 256, Jl = 262144, Ql = 4194304;
  function Fo(r) {
    var a = r & 42;
    if (a !== 0) return a;
    switch (r & -r) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return r & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return r & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return r & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return r;
    }
  }
  function ec(r, a, s) {
    var u = r.pendingLanes;
    if (u === 0) return 0;
    var p = 0, g = r.suspendedLanes, _ = r.pingedLanes;
    r = r.warmLanes;
    var z = u & 134217727;
    return z !== 0 ? (u = z & ~g, u !== 0 ? p = Fo(u) : (_ &= z, _ !== 0 ? p = Fo(_) : s || (s = z & ~r, s !== 0 && (p = Fo(s))))) : (z = u & ~g, z !== 0 ? p = Fo(z) : _ !== 0 ? p = Fo(_) : s || (s = u & ~r, s !== 0 && (p = Fo(s)))), p === 0 ? 0 : a !== 0 && a !== p && (a & g) === 0 && (g = p & -p, s = a & -a, g >= s || g === 32 && (s & 4194048) !== 0) ? a : p;
  }
  function rs(r, a) {
    return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & a) === 0;
  }
  function $z(r, a) {
    switch (r) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return a + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function iy() {
    var r = Ql;
    return Ql <<= 1, (Ql & 62914560) === 0 && (Ql = 4194304), r;
  }
  function ud(r) {
    for (var a = [], s = 0; 31 > s; s++) a.push(r);
    return a;
  }
  function os(r, a) {
    r.pendingLanes |= a, a !== 268435456 && (r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0);
  }
  function Hz(r, a, s, u, p, g) {
    var _ = r.pendingLanes;
    r.pendingLanes = s, r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0, r.expiredLanes &= s, r.entangledLanes &= s, r.errorRecoveryDisabledLanes &= s, r.shellSuspendCounter = 0;
    var z = r.entanglements, L = r.expirationTimes, F = r.hiddenUpdates;
    for (s = _ & ~s; 0 < s; ) {
      var Q = 31 - hn(s), ae = 1 << Q;
      z[Q] = 0, L[Q] = -1;
      var q = F[Q];
      if (q !== null)
        for (F[Q] = null, Q = 0; Q < q.length; Q++) {
          var K = q[Q];
          K !== null && (K.lane &= -536870913);
        }
      s &= ~ae;
    }
    u !== 0 && sy(r, u, 0), g !== 0 && p === 0 && r.tag !== 0 && (r.suspendedLanes |= g & ~(_ & ~a));
  }
  function sy(r, a, s) {
    r.pendingLanes |= a, r.suspendedLanes &= ~a;
    var u = 31 - hn(a);
    r.entangledLanes |= a, r.entanglements[u] = r.entanglements[u] | 1073741824 | s & 261930;
  }
  function ly(r, a) {
    var s = r.entangledLanes |= a;
    for (r = r.entanglements; s; ) {
      var u = 31 - hn(s), p = 1 << u;
      p & a | r[u] & a && (r[u] |= a), s &= ~p;
    }
  }
  function cy(r, a) {
    var s = a & -a;
    return s = (s & 42) !== 0 ? 1 : fd(s), (s & (r.suspendedLanes | a)) !== 0 ? 0 : s;
  }
  function fd(r) {
    switch (r) {
      case 2:
        r = 1;
        break;
      case 8:
        r = 4;
        break;
      case 32:
        r = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        r = 128;
        break;
      case 268435456:
        r = 134217728;
        break;
      default:
        r = 0;
    }
    return r;
  }
  function dd(r) {
    return r &= -r, 2 < r ? 8 < r ? (r & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function uy() {
    var r = G.p;
    return r !== 0 ? r : (r = window.event, r === void 0 ? 32 : Wx(r.type));
  }
  function fy(r, a) {
    var s = G.p;
    try {
      return G.p = r, a();
    } finally {
      G.p = s;
    }
  }
  var Xr = Math.random().toString(36).slice(2), Pt = "__reactFiber$" + Xr, en = "__reactProps$" + Xr, Da = "__reactContainer$" + Xr, hd = "__reactEvents$" + Xr, Zz = "__reactListeners$" + Xr, Fz = "__reactHandles$" + Xr, dy = "__reactResources$" + Xr, as = "__reactMarker$" + Xr;
  function pd(r) {
    delete r[Pt], delete r[en], delete r[hd], delete r[Zz], delete r[Fz];
  }
  function Na(r) {
    var a = r[Pt];
    if (a) return a;
    for (var s = r.parentNode; s; ) {
      if (a = s[Da] || s[Pt]) {
        if (s = a.alternate, a.child !== null || s !== null && s.child !== null)
          for (r = Ox(r); r !== null; ) {
            if (s = r[Pt]) return s;
            r = Ox(r);
          }
        return a;
      }
      r = s, s = r.parentNode;
    }
    return null;
  }
  function Oa(r) {
    if (r = r[Pt] || r[Da]) {
      var a = r.tag;
      if (a === 5 || a === 6 || a === 13 || a === 31 || a === 26 || a === 27 || a === 3)
        return r;
    }
    return null;
  }
  function is(r) {
    var a = r.tag;
    if (a === 5 || a === 26 || a === 27 || a === 6) return r.stateNode;
    throw Error(o(33));
  }
  function ja(r) {
    var a = r[dy];
    return a || (a = r[dy] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), a;
  }
  function Ot(r) {
    r[as] = !0;
  }
  var hy = /* @__PURE__ */ new Set(), py = {};
  function Go(r, a) {
    ka(r, a), ka(r + "Capture", a);
  }
  function ka(r, a) {
    for (py[r] = a, r = 0; r < a.length; r++)
      hy.add(a[r]);
  }
  var Gz = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), my = {}, gy = {};
  function Yz(r) {
    return za.call(gy, r) ? !0 : za.call(my, r) ? !1 : Gz.test(r) ? gy[r] = !0 : (my[r] = !0, !1);
  }
  function tc(r, a, s) {
    if (Yz(a))
      if (s === null) r.removeAttribute(a);
      else {
        switch (typeof s) {
          case "undefined":
          case "function":
          case "symbol":
            r.removeAttribute(a);
            return;
          case "boolean":
            var u = a.toLowerCase().slice(0, 5);
            if (u !== "data-" && u !== "aria-") {
              r.removeAttribute(a);
              return;
            }
        }
        r.setAttribute(a, "" + s);
      }
  }
  function nc(r, a, s) {
    if (s === null) r.removeAttribute(a);
    else {
      switch (typeof s) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(a);
          return;
      }
      r.setAttribute(a, "" + s);
    }
  }
  function Er(r, a, s, u) {
    if (u === null) r.removeAttribute(s);
    else {
      switch (typeof u) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          r.removeAttribute(s);
          return;
      }
      r.setAttributeNS(a, s, "" + u);
    }
  }
  function Cn(r) {
    switch (typeof r) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return r;
      case "object":
        return r;
      default:
        return "";
    }
  }
  function vy(r) {
    var a = r.type;
    return (r = r.nodeName) && r.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
  }
  function qz(r, a, s) {
    var u = Object.getOwnPropertyDescriptor(
      r.constructor.prototype,
      a
    );
    if (!r.hasOwnProperty(a) && typeof u < "u" && typeof u.get == "function" && typeof u.set == "function") {
      var p = u.get, g = u.set;
      return Object.defineProperty(r, a, {
        configurable: !0,
        get: function() {
          return p.call(this);
        },
        set: function(_) {
          s = "" + _, g.call(this, _);
        }
      }), Object.defineProperty(r, a, {
        enumerable: u.enumerable
      }), {
        getValue: function() {
          return s;
        },
        setValue: function(_) {
          s = "" + _;
        },
        stopTracking: function() {
          r._valueTracker = null, delete r[a];
        }
      };
    }
  }
  function md(r) {
    if (!r._valueTracker) {
      var a = vy(r) ? "checked" : "value";
      r._valueTracker = qz(
        r,
        a,
        "" + r[a]
      );
    }
  }
  function yy(r) {
    if (!r) return !1;
    var a = r._valueTracker;
    if (!a) return !0;
    var s = a.getValue(), u = "";
    return r && (u = vy(r) ? r.checked ? "true" : "false" : r.value), r = u, r !== s ? (a.setValue(r), !0) : !1;
  }
  function rc(r) {
    if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
    try {
      return r.activeElement || r.body;
    } catch {
      return r.body;
    }
  }
  var Wz = /[\n"\\]/g;
  function An(r) {
    return r.replace(
      Wz,
      function(a) {
        return "\\" + a.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function gd(r, a, s, u, p, g, _, z) {
    r.name = "", _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" ? r.type = _ : r.removeAttribute("type"), a != null ? _ === "number" ? (a === 0 && r.value === "" || r.value != a) && (r.value = "" + Cn(a)) : r.value !== "" + Cn(a) && (r.value = "" + Cn(a)) : _ !== "submit" && _ !== "reset" || r.removeAttribute("value"), a != null ? vd(r, _, Cn(a)) : s != null ? vd(r, _, Cn(s)) : u != null && r.removeAttribute("value"), p == null && g != null && (r.defaultChecked = !!g), p != null && (r.checked = p && typeof p != "function" && typeof p != "symbol"), z != null && typeof z != "function" && typeof z != "symbol" && typeof z != "boolean" ? r.name = "" + Cn(z) : r.removeAttribute("name");
  }
  function by(r, a, s, u, p, g, _, z) {
    if (g != null && typeof g != "function" && typeof g != "symbol" && typeof g != "boolean" && (r.type = g), a != null || s != null) {
      if (!(g !== "submit" && g !== "reset" || a != null)) {
        md(r);
        return;
      }
      s = s != null ? "" + Cn(s) : "", a = a != null ? "" + Cn(a) : s, z || a === r.value || (r.value = a), r.defaultValue = a;
    }
    u = u ?? p, u = typeof u != "function" && typeof u != "symbol" && !!u, r.checked = z ? r.checked : !!u, r.defaultChecked = !!u, _ != null && typeof _ != "function" && typeof _ != "symbol" && typeof _ != "boolean" && (r.name = _), md(r);
  }
  function vd(r, a, s) {
    a === "number" && rc(r.ownerDocument) === r || r.defaultValue === "" + s || (r.defaultValue = "" + s);
  }
  function Pa(r, a, s, u) {
    if (r = r.options, a) {
      a = {};
      for (var p = 0; p < s.length; p++)
        a["$" + s[p]] = !0;
      for (s = 0; s < r.length; s++)
        p = a.hasOwnProperty("$" + r[s].value), r[s].selected !== p && (r[s].selected = p), p && u && (r[s].defaultSelected = !0);
    } else {
      for (s = "" + Cn(s), a = null, p = 0; p < r.length; p++) {
        if (r[p].value === s) {
          r[p].selected = !0, u && (r[p].defaultSelected = !0);
          return;
        }
        a !== null || r[p].disabled || (a = r[p]);
      }
      a !== null && (a.selected = !0);
    }
  }
  function xy(r, a, s) {
    if (a != null && (a = "" + Cn(a), a !== r.value && (r.value = a), s == null)) {
      r.defaultValue !== a && (r.defaultValue = a);
      return;
    }
    r.defaultValue = s != null ? "" + Cn(s) : "";
  }
  function Sy(r, a, s, u) {
    if (a == null) {
      if (u != null) {
        if (s != null) throw Error(o(92));
        if (de(u)) {
          if (1 < u.length) throw Error(o(93));
          u = u[0];
        }
        s = u;
      }
      s == null && (s = ""), a = s;
    }
    s = Cn(a), r.defaultValue = s, u = r.textContent, u === s && u !== "" && u !== null && (r.value = u), md(r);
  }
  function La(r, a) {
    if (a) {
      var s = r.firstChild;
      if (s && s === r.lastChild && s.nodeType === 3) {
        s.nodeValue = a;
        return;
      }
    }
    r.textContent = a;
  }
  var Xz = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function wy(r, a, s) {
    var u = a.indexOf("--") === 0;
    s == null || typeof s == "boolean" || s === "" ? u ? r.setProperty(a, "") : a === "float" ? r.cssFloat = "" : r[a] = "" : u ? r.setProperty(a, s) : typeof s != "number" || s === 0 || Xz.has(a) ? a === "float" ? r.cssFloat = s : r[a] = ("" + s).trim() : r[a] = s + "px";
  }
  function Ey(r, a, s) {
    if (a != null && typeof a != "object")
      throw Error(o(62));
    if (r = r.style, s != null) {
      for (var u in s)
        !s.hasOwnProperty(u) || a != null && a.hasOwnProperty(u) || (u.indexOf("--") === 0 ? r.setProperty(u, "") : u === "float" ? r.cssFloat = "" : r[u] = "");
      for (var p in a)
        u = a[p], a.hasOwnProperty(p) && s[p] !== u && wy(r, p, u);
    } else
      for (var g in a)
        a.hasOwnProperty(g) && wy(r, g, a[g]);
  }
  function yd(r) {
    if (r.indexOf("-") === -1) return !1;
    switch (r) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var Kz = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), Jz = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function oc(r) {
    return Jz.test("" + r) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : r;
  }
  function _r() {
  }
  var bd = null;
  function xd(r) {
    return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
  }
  var Ia = null, Va = null;
  function _y(r) {
    var a = Oa(r);
    if (a && (r = a.stateNode)) {
      var s = r[en] || null;
      e: switch (r = a.stateNode, a.type) {
        case "input":
          if (gd(
            r,
            s.value,
            s.defaultValue,
            s.defaultValue,
            s.checked,
            s.defaultChecked,
            s.type,
            s.name
          ), a = s.name, s.type === "radio" && a != null) {
            for (s = r; s.parentNode; ) s = s.parentNode;
            for (s = s.querySelectorAll(
              'input[name="' + An(
                "" + a
              ) + '"][type="radio"]'
            ), a = 0; a < s.length; a++) {
              var u = s[a];
              if (u !== r && u.form === r.form) {
                var p = u[en] || null;
                if (!p) throw Error(o(90));
                gd(
                  u,
                  p.value,
                  p.defaultValue,
                  p.defaultValue,
                  p.checked,
                  p.defaultChecked,
                  p.type,
                  p.name
                );
              }
            }
            for (a = 0; a < s.length; a++)
              u = s[a], u.form === r.form && yy(u);
          }
          break e;
        case "textarea":
          xy(r, s.value, s.defaultValue);
          break e;
        case "select":
          a = s.value, a != null && Pa(r, !!s.multiple, a, !1);
      }
    }
  }
  var Sd = !1;
  function Ty(r, a, s) {
    if (Sd) return r(a, s);
    Sd = !0;
    try {
      var u = r(a);
      return u;
    } finally {
      if (Sd = !1, (Ia !== null || Va !== null) && (Fc(), Ia && (a = Ia, r = Va, Va = Ia = null, _y(a), r)))
        for (a = 0; a < r.length; a++) _y(r[a]);
    }
  }
  function ss(r, a) {
    var s = r.stateNode;
    if (s === null) return null;
    var u = s[en] || null;
    if (u === null) return null;
    s = u[a];
    e: switch (a) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (u = !u.disabled) || (r = r.type, u = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !u;
        break e;
      default:
        r = !1;
    }
    if (r) return null;
    if (s && typeof s != "function")
      throw Error(
        o(231, a, typeof s)
      );
    return s;
  }
  var Tr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), wd = !1;
  if (Tr)
    try {
      var ls = {};
      Object.defineProperty(ls, "passive", {
        get: function() {
          wd = !0;
        }
      }), window.addEventListener("test", ls, ls), window.removeEventListener("test", ls, ls);
    } catch {
      wd = !1;
    }
  var Kr = null, Ed = null, ac = null;
  function Cy() {
    if (ac) return ac;
    var r, a = Ed, s = a.length, u, p = "value" in Kr ? Kr.value : Kr.textContent, g = p.length;
    for (r = 0; r < s && a[r] === p[r]; r++) ;
    var _ = s - r;
    for (u = 1; u <= _ && a[s - u] === p[g - u]; u++) ;
    return ac = p.slice(r, 1 < u ? 1 - u : void 0);
  }
  function ic(r) {
    var a = r.keyCode;
    return "charCode" in r ? (r = r.charCode, r === 0 && a === 13 && (r = 13)) : r = a, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
  }
  function sc() {
    return !0;
  }
  function Ay() {
    return !1;
  }
  function tn(r) {
    function a(s, u, p, g, _) {
      this._reactName = s, this._targetInst = p, this.type = u, this.nativeEvent = g, this.target = _, this.currentTarget = null;
      for (var z in r)
        r.hasOwnProperty(z) && (s = r[z], this[z] = s ? s(g) : g[z]);
      return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? sc : Ay, this.isPropagationStopped = Ay, this;
    }
    return v(a.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var s = this.nativeEvent;
        s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = !1), this.isDefaultPrevented = sc);
      },
      stopPropagation: function() {
        var s = this.nativeEvent;
        s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = !0), this.isPropagationStopped = sc);
      },
      persist: function() {
      },
      isPersistent: sc
    }), a;
  }
  var Yo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(r) {
      return r.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, lc = tn(Yo), cs = v({}, Yo, { view: 0, detail: 0 }), Qz = tn(cs), _d, Td, us, cc = v({}, cs, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Ad,
    button: 0,
    buttons: 0,
    relatedTarget: function(r) {
      return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
    },
    movementX: function(r) {
      return "movementX" in r ? r.movementX : (r !== us && (us && r.type === "mousemove" ? (_d = r.screenX - us.screenX, Td = r.screenY - us.screenY) : Td = _d = 0, us = r), _d);
    },
    movementY: function(r) {
      return "movementY" in r ? r.movementY : Td;
    }
  }), Ry = tn(cc), eD = v({}, cc, { dataTransfer: 0 }), tD = tn(eD), nD = v({}, cs, { relatedTarget: 0 }), Cd = tn(nD), rD = v({}, Yo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), oD = tn(rD), aD = v({}, Yo, {
    clipboardData: function(r) {
      return "clipboardData" in r ? r.clipboardData : window.clipboardData;
    }
  }), iD = tn(aD), sD = v({}, Yo, { data: 0 }), My = tn(sD), lD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, cD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, uD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function fD(r) {
    var a = this.nativeEvent;
    return a.getModifierState ? a.getModifierState(r) : (r = uD[r]) ? !!a[r] : !1;
  }
  function Ad() {
    return fD;
  }
  var dD = v({}, cs, {
    key: function(r) {
      if (r.key) {
        var a = lD[r.key] || r.key;
        if (a !== "Unidentified") return a;
      }
      return r.type === "keypress" ? (r = ic(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? cD[r.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Ad,
    charCode: function(r) {
      return r.type === "keypress" ? ic(r) : 0;
    },
    keyCode: function(r) {
      return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    },
    which: function(r) {
      return r.type === "keypress" ? ic(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
    }
  }), hD = tn(dD), pD = v({}, cc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), zy = tn(pD), mD = v({}, cs, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Ad
  }), gD = tn(mD), vD = v({}, Yo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), yD = tn(vD), bD = v({}, cc, {
    deltaX: function(r) {
      return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
    },
    deltaY: function(r) {
      return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), xD = tn(bD), SD = v({}, Yo, {
    newState: 0,
    oldState: 0
  }), wD = tn(SD), ED = [9, 13, 27, 32], Rd = Tr && "CompositionEvent" in window, fs = null;
  Tr && "documentMode" in document && (fs = document.documentMode);
  var _D = Tr && "TextEvent" in window && !fs, Dy = Tr && (!Rd || fs && 8 < fs && 11 >= fs), Ny = " ", Oy = !1;
  function jy(r, a) {
    switch (r) {
      case "keyup":
        return ED.indexOf(a.keyCode) !== -1;
      case "keydown":
        return a.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function ky(r) {
    return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
  }
  var Ua = !1;
  function TD(r, a) {
    switch (r) {
      case "compositionend":
        return ky(a);
      case "keypress":
        return a.which !== 32 ? null : (Oy = !0, Ny);
      case "textInput":
        return r = a.data, r === Ny && Oy ? null : r;
      default:
        return null;
    }
  }
  function CD(r, a) {
    if (Ua)
      return r === "compositionend" || !Rd && jy(r, a) ? (r = Cy(), ac = Ed = Kr = null, Ua = !1, r) : null;
    switch (r) {
      case "paste":
        return null;
      case "keypress":
        if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
          if (a.char && 1 < a.char.length)
            return a.char;
          if (a.which) return String.fromCharCode(a.which);
        }
        return null;
      case "compositionend":
        return Dy && a.locale !== "ko" ? null : a.data;
      default:
        return null;
    }
  }
  var AD = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Py(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase();
    return a === "input" ? !!AD[r.type] : a === "textarea";
  }
  function Ly(r, a, s, u) {
    Ia ? Va ? Va.push(u) : Va = [u] : Ia = u, a = Jc(a, "onChange"), 0 < a.length && (s = new lc(
      "onChange",
      "change",
      null,
      s,
      u
    ), r.push({ event: s, listeners: a }));
  }
  var ds = null, hs = null;
  function RD(r) {
    bx(r, 0);
  }
  function uc(r) {
    var a = is(r);
    if (yy(a)) return r;
  }
  function Iy(r, a) {
    if (r === "change") return a;
  }
  var Vy = !1;
  if (Tr) {
    var Md;
    if (Tr) {
      var zd = "oninput" in document;
      if (!zd) {
        var Uy = document.createElement("div");
        Uy.setAttribute("oninput", "return;"), zd = typeof Uy.oninput == "function";
      }
      Md = zd;
    } else Md = !1;
    Vy = Md && (!document.documentMode || 9 < document.documentMode);
  }
  function By() {
    ds && (ds.detachEvent("onpropertychange", $y), hs = ds = null);
  }
  function $y(r) {
    if (r.propertyName === "value" && uc(hs)) {
      var a = [];
      Ly(
        a,
        hs,
        r,
        xd(r)
      ), Ty(RD, a);
    }
  }
  function MD(r, a, s) {
    r === "focusin" ? (By(), ds = a, hs = s, ds.attachEvent("onpropertychange", $y)) : r === "focusout" && By();
  }
  function zD(r) {
    if (r === "selectionchange" || r === "keyup" || r === "keydown")
      return uc(hs);
  }
  function DD(r, a) {
    if (r === "click") return uc(a);
  }
  function ND(r, a) {
    if (r === "input" || r === "change")
      return uc(a);
  }
  function OD(r, a) {
    return r === a && (r !== 0 || 1 / r === 1 / a) || r !== r && a !== a;
  }
  var pn = typeof Object.is == "function" ? Object.is : OD;
  function ps(r, a) {
    if (pn(r, a)) return !0;
    if (typeof r != "object" || r === null || typeof a != "object" || a === null)
      return !1;
    var s = Object.keys(r), u = Object.keys(a);
    if (s.length !== u.length) return !1;
    for (u = 0; u < s.length; u++) {
      var p = s[u];
      if (!za.call(a, p) || !pn(r[p], a[p]))
        return !1;
    }
    return !0;
  }
  function Hy(r) {
    for (; r && r.firstChild; ) r = r.firstChild;
    return r;
  }
  function Zy(r, a) {
    var s = Hy(r);
    r = 0;
    for (var u; s; ) {
      if (s.nodeType === 3) {
        if (u = r + s.textContent.length, r <= a && u >= a)
          return { node: s, offset: a - r };
        r = u;
      }
      e: {
        for (; s; ) {
          if (s.nextSibling) {
            s = s.nextSibling;
            break e;
          }
          s = s.parentNode;
        }
        s = void 0;
      }
      s = Hy(s);
    }
  }
  function Fy(r, a) {
    return r && a ? r === a ? !0 : r && r.nodeType === 3 ? !1 : a && a.nodeType === 3 ? Fy(r, a.parentNode) : "contains" in r ? r.contains(a) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(a) & 16) : !1 : !1;
  }
  function Gy(r) {
    r = r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null ? r.ownerDocument.defaultView : window;
    for (var a = rc(r.document); a instanceof r.HTMLIFrameElement; ) {
      try {
        var s = typeof a.contentWindow.location.href == "string";
      } catch {
        s = !1;
      }
      if (s) r = a.contentWindow;
      else break;
      a = rc(r.document);
    }
    return a;
  }
  function Dd(r) {
    var a = r && r.nodeName && r.nodeName.toLowerCase();
    return a && (a === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || a === "textarea" || r.contentEditable === "true");
  }
  var jD = Tr && "documentMode" in document && 11 >= document.documentMode, Ba = null, Nd = null, ms = null, Od = !1;
  function Yy(r, a, s) {
    var u = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument;
    Od || Ba == null || Ba !== rc(u) || (u = Ba, "selectionStart" in u && Dd(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = {
      anchorNode: u.anchorNode,
      anchorOffset: u.anchorOffset,
      focusNode: u.focusNode,
      focusOffset: u.focusOffset
    }), ms && ps(ms, u) || (ms = u, u = Jc(Nd, "onSelect"), 0 < u.length && (a = new lc(
      "onSelect",
      "select",
      null,
      a,
      s
    ), r.push({ event: a, listeners: u }), a.target = Ba)));
  }
  function qo(r, a) {
    var s = {};
    return s[r.toLowerCase()] = a.toLowerCase(), s["Webkit" + r] = "webkit" + a, s["Moz" + r] = "moz" + a, s;
  }
  var $a = {
    animationend: qo("Animation", "AnimationEnd"),
    animationiteration: qo("Animation", "AnimationIteration"),
    animationstart: qo("Animation", "AnimationStart"),
    transitionrun: qo("Transition", "TransitionRun"),
    transitionstart: qo("Transition", "TransitionStart"),
    transitioncancel: qo("Transition", "TransitionCancel"),
    transitionend: qo("Transition", "TransitionEnd")
  }, jd = {}, qy = {};
  Tr && (qy = document.createElement("div").style, "AnimationEvent" in window || (delete $a.animationend.animation, delete $a.animationiteration.animation, delete $a.animationstart.animation), "TransitionEvent" in window || delete $a.transitionend.transition);
  function Wo(r) {
    if (jd[r]) return jd[r];
    if (!$a[r]) return r;
    var a = $a[r], s;
    for (s in a)
      if (a.hasOwnProperty(s) && s in qy)
        return jd[r] = a[s];
    return r;
  }
  var Wy = Wo("animationend"), Xy = Wo("animationiteration"), Ky = Wo("animationstart"), kD = Wo("transitionrun"), PD = Wo("transitionstart"), LD = Wo("transitioncancel"), Jy = Wo("transitionend"), Qy = /* @__PURE__ */ new Map(), kd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  kd.push("scrollEnd");
  function Zn(r, a) {
    Qy.set(r, a), Go(a, [r]);
  }
  var fc = typeof reportError == "function" ? reportError : function(r) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var a = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof r == "object" && r !== null && typeof r.message == "string" ? String(r.message) : String(r),
        error: r
      });
      if (!window.dispatchEvent(a)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", r);
      return;
    }
    console.error(r);
  }, Rn = [], Ha = 0, Pd = 0;
  function dc() {
    for (var r = Ha, a = Pd = Ha = 0; a < r; ) {
      var s = Rn[a];
      Rn[a++] = null;
      var u = Rn[a];
      Rn[a++] = null;
      var p = Rn[a];
      Rn[a++] = null;
      var g = Rn[a];
      if (Rn[a++] = null, u !== null && p !== null) {
        var _ = u.pending;
        _ === null ? p.next = p : (p.next = _.next, _.next = p), u.pending = p;
      }
      g !== 0 && e0(s, p, g);
    }
  }
  function hc(r, a, s, u) {
    Rn[Ha++] = r, Rn[Ha++] = a, Rn[Ha++] = s, Rn[Ha++] = u, Pd |= u, r.lanes |= u, r = r.alternate, r !== null && (r.lanes |= u);
  }
  function Ld(r, a, s, u) {
    return hc(r, a, s, u), pc(r);
  }
  function Xo(r, a) {
    return hc(r, null, null, a), pc(r);
  }
  function e0(r, a, s) {
    r.lanes |= s;
    var u = r.alternate;
    u !== null && (u.lanes |= s);
    for (var p = !1, g = r.return; g !== null; )
      g.childLanes |= s, u = g.alternate, u !== null && (u.childLanes |= s), g.tag === 22 && (r = g.stateNode, r === null || r._visibility & 1 || (p = !0)), r = g, g = g.return;
    return r.tag === 3 ? (g = r.stateNode, p && a !== null && (p = 31 - hn(s), r = g.hiddenUpdates, u = r[p], u === null ? r[p] = [a] : u.push(a), a.lane = s | 536870912), g) : null;
  }
  function pc(r) {
    if (50 < Ls)
      throw Ls = 0, Gh = null, Error(o(185));
    for (var a = r.return; a !== null; )
      r = a, a = r.return;
    return r.tag === 3 ? r.stateNode : null;
  }
  var Za = {};
  function ID(r, a, s, u) {
    this.tag = r, this.key = s, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = a, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function mn(r, a, s, u) {
    return new ID(r, a, s, u);
  }
  function Id(r) {
    return r = r.prototype, !(!r || !r.isReactComponent);
  }
  function Cr(r, a) {
    var s = r.alternate;
    return s === null ? (s = mn(
      r.tag,
      a,
      r.key,
      r.mode
    ), s.elementType = r.elementType, s.type = r.type, s.stateNode = r.stateNode, s.alternate = r, r.alternate = s) : (s.pendingProps = a, s.type = r.type, s.flags = 0, s.subtreeFlags = 0, s.deletions = null), s.flags = r.flags & 65011712, s.childLanes = r.childLanes, s.lanes = r.lanes, s.child = r.child, s.memoizedProps = r.memoizedProps, s.memoizedState = r.memoizedState, s.updateQueue = r.updateQueue, a = r.dependencies, s.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }, s.sibling = r.sibling, s.index = r.index, s.ref = r.ref, s.refCleanup = r.refCleanup, s;
  }
  function t0(r, a) {
    r.flags &= 65011714;
    var s = r.alternate;
    return s === null ? (r.childLanes = 0, r.lanes = a, r.child = null, r.subtreeFlags = 0, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null) : (r.childLanes = s.childLanes, r.lanes = s.lanes, r.child = s.child, r.subtreeFlags = 0, r.deletions = null, r.memoizedProps = s.memoizedProps, r.memoizedState = s.memoizedState, r.updateQueue = s.updateQueue, r.type = s.type, a = s.dependencies, r.dependencies = a === null ? null : {
      lanes: a.lanes,
      firstContext: a.firstContext
    }), r;
  }
  function mc(r, a, s, u, p, g) {
    var _ = 0;
    if (u = r, typeof r == "function") Id(r) && (_ = 1);
    else if (typeof r == "string")
      _ = HN(
        r,
        s,
        X.current
      ) ? 26 : r === "html" || r === "head" || r === "body" ? 27 : 5;
    else
      e: switch (r) {
        case P:
          return r = mn(31, s, a, p), r.elementType = P, r.lanes = g, r;
        case w:
          return Ko(s.children, p, g, a);
        case C:
          _ = 8, p |= 24;
          break;
        case A:
          return r = mn(12, s, a, p | 2), r.elementType = A, r.lanes = g, r;
        case O:
          return r = mn(13, s, a, p), r.elementType = O, r.lanes = g, r;
        case k:
          return r = mn(19, s, a, p), r.elementType = k, r.lanes = g, r;
        default:
          if (typeof r == "object" && r !== null)
            switch (r.$$typeof) {
              case T:
                _ = 10;
                break e;
              case M:
                _ = 9;
                break e;
              case D:
                _ = 11;
                break e;
              case R:
                _ = 14;
                break e;
              case N:
                _ = 16, u = null;
                break e;
            }
          _ = 29, s = Error(
            o(130, r === null ? "null" : typeof r, "")
          ), u = null;
      }
    return a = mn(_, s, a, p), a.elementType = r, a.type = u, a.lanes = g, a;
  }
  function Ko(r, a, s, u) {
    return r = mn(7, r, u, a), r.lanes = s, r;
  }
  function Vd(r, a, s) {
    return r = mn(6, r, null, a), r.lanes = s, r;
  }
  function n0(r) {
    var a = mn(18, null, null, 0);
    return a.stateNode = r, a;
  }
  function Ud(r, a, s) {
    return a = mn(
      4,
      r.children !== null ? r.children : [],
      r.key,
      a
    ), a.lanes = s, a.stateNode = {
      containerInfo: r.containerInfo,
      pendingChildren: null,
      implementation: r.implementation
    }, a;
  }
  var r0 = /* @__PURE__ */ new WeakMap();
  function Mn(r, a) {
    if (typeof r == "object" && r !== null) {
      var s = r0.get(r);
      return s !== void 0 ? s : (a = {
        value: r,
        source: a,
        stack: kt(a)
      }, r0.set(r, a), a);
    }
    return {
      value: r,
      source: a,
      stack: kt(a)
    };
  }
  var Fa = [], Ga = 0, gc = null, gs = 0, zn = [], Dn = 0, Jr = null, rr = 1, or = "";
  function Ar(r, a) {
    Fa[Ga++] = gs, Fa[Ga++] = gc, gc = r, gs = a;
  }
  function o0(r, a, s) {
    zn[Dn++] = rr, zn[Dn++] = or, zn[Dn++] = Jr, Jr = r;
    var u = rr;
    r = or;
    var p = 32 - hn(u) - 1;
    u &= ~(1 << p), s += 1;
    var g = 32 - hn(a) + p;
    if (30 < g) {
      var _ = p - p % 5;
      g = (u & (1 << _) - 1).toString(32), u >>= _, p -= _, rr = 1 << 32 - hn(a) + p | s << p | u, or = g + r;
    } else
      rr = 1 << g | s << p | u, or = r;
  }
  function Bd(r) {
    r.return !== null && (Ar(r, 1), o0(r, 1, 0));
  }
  function $d(r) {
    for (; r === gc; )
      gc = Fa[--Ga], Fa[Ga] = null, gs = Fa[--Ga], Fa[Ga] = null;
    for (; r === Jr; )
      Jr = zn[--Dn], zn[Dn] = null, or = zn[--Dn], zn[Dn] = null, rr = zn[--Dn], zn[Dn] = null;
  }
  function a0(r, a) {
    zn[Dn++] = rr, zn[Dn++] = or, zn[Dn++] = Jr, rr = a.id, or = a.overflow, Jr = r;
  }
  var Lt = null, at = null, Ue = !1, Qr = null, Nn = !1, Hd = Error(o(519));
  function eo(r) {
    var a = Error(
      o(
        418,
        1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    throw vs(Mn(a, r)), Hd;
  }
  function i0(r) {
    var a = r.stateNode, s = r.type, u = r.memoizedProps;
    switch (a[Pt] = r, a[en] = u, s) {
      case "dialog":
        Pe("cancel", a), Pe("close", a);
        break;
      case "iframe":
      case "object":
      case "embed":
        Pe("load", a);
        break;
      case "video":
      case "audio":
        for (s = 0; s < Vs.length; s++)
          Pe(Vs[s], a);
        break;
      case "source":
        Pe("error", a);
        break;
      case "img":
      case "image":
      case "link":
        Pe("error", a), Pe("load", a);
        break;
      case "details":
        Pe("toggle", a);
        break;
      case "input":
        Pe("invalid", a), by(
          a,
          u.value,
          u.defaultValue,
          u.checked,
          u.defaultChecked,
          u.type,
          u.name,
          !0
        );
        break;
      case "select":
        Pe("invalid", a);
        break;
      case "textarea":
        Pe("invalid", a), Sy(a, u.value, u.defaultValue, u.children);
    }
    s = u.children, typeof s != "string" && typeof s != "number" && typeof s != "bigint" || a.textContent === "" + s || u.suppressHydrationWarning === !0 || Ex(a.textContent, s) ? (u.popover != null && (Pe("beforetoggle", a), Pe("toggle", a)), u.onScroll != null && Pe("scroll", a), u.onScrollEnd != null && Pe("scrollend", a), u.onClick != null && (a.onclick = _r), a = !0) : a = !1, a || eo(r, !0);
  }
  function s0(r) {
    for (Lt = r.return; Lt; )
      switch (Lt.tag) {
        case 5:
        case 31:
        case 13:
          Nn = !1;
          return;
        case 27:
        case 3:
          Nn = !0;
          return;
        default:
          Lt = Lt.return;
      }
  }
  function Ya(r) {
    if (r !== Lt) return !1;
    if (!Ue) return s0(r), Ue = !0, !1;
    var a = r.tag, s;
    if ((s = a !== 3 && a !== 27) && ((s = a === 5) && (s = r.type, s = !(s !== "form" && s !== "button") || sp(r.type, r.memoizedProps)), s = !s), s && at && eo(r), s0(r), a === 13) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(317));
      at = Nx(r);
    } else if (a === 31) {
      if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(317));
      at = Nx(r);
    } else
      a === 27 ? (a = at, mo(r.type) ? (r = dp, dp = null, at = r) : at = a) : at = Lt ? jn(r.stateNode.nextSibling) : null;
    return !0;
  }
  function Jo() {
    at = Lt = null, Ue = !1;
  }
  function Zd() {
    var r = Qr;
    return r !== null && (an === null ? an = r : an.push.apply(
      an,
      r
    ), Qr = null), r;
  }
  function vs(r) {
    Qr === null ? Qr = [r] : Qr.push(r);
  }
  var Fd = j(null), Qo = null, Rr = null;
  function to(r, a, s) {
    $(Fd, a._currentValue), a._currentValue = s;
  }
  function Mr(r) {
    r._currentValue = Fd.current, W(Fd);
  }
  function Gd(r, a, s) {
    for (; r !== null; ) {
      var u = r.alternate;
      if ((r.childLanes & a) !== a ? (r.childLanes |= a, u !== null && (u.childLanes |= a)) : u !== null && (u.childLanes & a) !== a && (u.childLanes |= a), r === s) break;
      r = r.return;
    }
  }
  function Yd(r, a, s, u) {
    var p = r.child;
    for (p !== null && (p.return = r); p !== null; ) {
      var g = p.dependencies;
      if (g !== null) {
        var _ = p.child;
        g = g.firstContext;
        e: for (; g !== null; ) {
          var z = g;
          g = p;
          for (var L = 0; L < a.length; L++)
            if (z.context === a[L]) {
              g.lanes |= s, z = g.alternate, z !== null && (z.lanes |= s), Gd(
                g.return,
                s,
                r
              ), u || (_ = null);
              break e;
            }
          g = z.next;
        }
      } else if (p.tag === 18) {
        if (_ = p.return, _ === null) throw Error(o(341));
        _.lanes |= s, g = _.alternate, g !== null && (g.lanes |= s), Gd(_, s, r), _ = null;
      } else _ = p.child;
      if (_ !== null) _.return = p;
      else
        for (_ = p; _ !== null; ) {
          if (_ === r) {
            _ = null;
            break;
          }
          if (p = _.sibling, p !== null) {
            p.return = _.return, _ = p;
            break;
          }
          _ = _.return;
        }
      p = _;
    }
  }
  function qa(r, a, s, u) {
    r = null;
    for (var p = a, g = !1; p !== null; ) {
      if (!g) {
        if ((p.flags & 524288) !== 0) g = !0;
        else if ((p.flags & 262144) !== 0) break;
      }
      if (p.tag === 10) {
        var _ = p.alternate;
        if (_ === null) throw Error(o(387));
        if (_ = _.memoizedProps, _ !== null) {
          var z = p.type;
          pn(p.pendingProps.value, _.value) || (r !== null ? r.push(z) : r = [z]);
        }
      } else if (p === H.current) {
        if (_ = p.alternate, _ === null) throw Error(o(387));
        _.memoizedState.memoizedState !== p.memoizedState.memoizedState && (r !== null ? r.push(Zs) : r = [Zs]);
      }
      p = p.return;
    }
    r !== null && Yd(
      a,
      r,
      s,
      u
    ), a.flags |= 262144;
  }
  function vc(r) {
    for (r = r.firstContext; r !== null; ) {
      if (!pn(
        r.context._currentValue,
        r.memoizedValue
      ))
        return !0;
      r = r.next;
    }
    return !1;
  }
  function ea(r) {
    Qo = r, Rr = null, r = r.dependencies, r !== null && (r.firstContext = null);
  }
  function It(r) {
    return l0(Qo, r);
  }
  function yc(r, a) {
    return Qo === null && ea(r), l0(r, a);
  }
  function l0(r, a) {
    var s = a._currentValue;
    if (a = { context: a, memoizedValue: s, next: null }, Rr === null) {
      if (r === null) throw Error(o(308));
      Rr = a, r.dependencies = { lanes: 0, firstContext: a }, r.flags |= 524288;
    } else Rr = Rr.next = a;
    return s;
  }
  var VD = typeof AbortController < "u" ? AbortController : function() {
    var r = [], a = this.signal = {
      aborted: !1,
      addEventListener: function(s, u) {
        r.push(u);
      }
    };
    this.abort = function() {
      a.aborted = !0, r.forEach(function(s) {
        return s();
      });
    };
  }, UD = e.unstable_scheduleCallback, BD = e.unstable_NormalPriority, wt = {
    $$typeof: T,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function qd() {
    return {
      controller: new VD(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function ys(r) {
    r.refCount--, r.refCount === 0 && UD(BD, function() {
      r.controller.abort();
    });
  }
  var bs = null, Wd = 0, Wa = 0, Xa = null;
  function $D(r, a) {
    if (bs === null) {
      var s = bs = [];
      Wd = 0, Wa = Jh(), Xa = {
        status: "pending",
        value: void 0,
        then: function(u) {
          s.push(u);
        }
      };
    }
    return Wd++, a.then(c0, c0), a;
  }
  function c0() {
    if (--Wd === 0 && bs !== null) {
      Xa !== null && (Xa.status = "fulfilled");
      var r = bs;
      bs = null, Wa = 0, Xa = null;
      for (var a = 0; a < r.length; a++) (0, r[a])();
    }
  }
  function HD(r, a) {
    var s = [], u = {
      status: "pending",
      value: null,
      reason: null,
      then: function(p) {
        s.push(p);
      }
    };
    return r.then(
      function() {
        u.status = "fulfilled", u.value = a;
        for (var p = 0; p < s.length; p++) (0, s[p])(a);
      },
      function(p) {
        for (u.status = "rejected", u.reason = p, p = 0; p < s.length; p++)
          (0, s[p])(void 0);
      }
    ), u;
  }
  var u0 = I.S;
  I.S = function(r, a) {
    Yb = fn(), typeof a == "object" && a !== null && typeof a.then == "function" && $D(r, a), u0 !== null && u0(r, a);
  };
  var ta = j(null);
  function Xd() {
    var r = ta.current;
    return r !== null ? r : et.pooledCache;
  }
  function bc(r, a) {
    a === null ? $(ta, ta.current) : $(ta, a.pool);
  }
  function f0() {
    var r = Xd();
    return r === null ? null : { parent: wt._currentValue, pool: r };
  }
  var Ka = Error(o(460)), Kd = Error(o(474)), xc = Error(o(542)), Sc = { then: function() {
  } };
  function d0(r) {
    return r = r.status, r === "fulfilled" || r === "rejected";
  }
  function h0(r, a, s) {
    switch (s = r[s], s === void 0 ? r.push(a) : s !== a && (a.then(_r, _r), a = s), a.status) {
      case "fulfilled":
        return a.value;
      case "rejected":
        throw r = a.reason, m0(r), r;
      default:
        if (typeof a.status == "string") a.then(_r, _r);
        else {
          if (r = et, r !== null && 100 < r.shellSuspendCounter)
            throw Error(o(482));
          r = a, r.status = "pending", r.then(
            function(u) {
              if (a.status === "pending") {
                var p = a;
                p.status = "fulfilled", p.value = u;
              }
            },
            function(u) {
              if (a.status === "pending") {
                var p = a;
                p.status = "rejected", p.reason = u;
              }
            }
          );
        }
        switch (a.status) {
          case "fulfilled":
            return a.value;
          case "rejected":
            throw r = a.reason, m0(r), r;
        }
        throw ra = a, Ka;
    }
  }
  function na(r) {
    try {
      var a = r._init;
      return a(r._payload);
    } catch (s) {
      throw s !== null && typeof s == "object" && typeof s.then == "function" ? (ra = s, Ka) : s;
    }
  }
  var ra = null;
  function p0() {
    if (ra === null) throw Error(o(459));
    var r = ra;
    return ra = null, r;
  }
  function m0(r) {
    if (r === Ka || r === xc)
      throw Error(o(483));
  }
  var Ja = null, xs = 0;
  function wc(r) {
    var a = xs;
    return xs += 1, Ja === null && (Ja = []), h0(Ja, r, a);
  }
  function Ss(r, a) {
    a = a.props.ref, r.ref = a !== void 0 ? a : null;
  }
  function Ec(r, a) {
    throw a.$$typeof === b ? Error(o(525)) : (r = Object.prototype.toString.call(a), Error(
      o(
        31,
        r === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : r
      )
    ));
  }
  function g0(r) {
    function a(B, V) {
      if (r) {
        var Z = B.deletions;
        Z === null ? (B.deletions = [V], B.flags |= 16) : Z.push(V);
      }
    }
    function s(B, V) {
      if (!r) return null;
      for (; V !== null; )
        a(B, V), V = V.sibling;
      return null;
    }
    function u(B) {
      for (var V = /* @__PURE__ */ new Map(); B !== null; )
        B.key !== null ? V.set(B.key, B) : V.set(B.index, B), B = B.sibling;
      return V;
    }
    function p(B, V) {
      return B = Cr(B, V), B.index = 0, B.sibling = null, B;
    }
    function g(B, V, Z) {
      return B.index = Z, r ? (Z = B.alternate, Z !== null ? (Z = Z.index, Z < V ? (B.flags |= 67108866, V) : Z) : (B.flags |= 67108866, V)) : (B.flags |= 1048576, V);
    }
    function _(B) {
      return r && B.alternate === null && (B.flags |= 67108866), B;
    }
    function z(B, V, Z, oe) {
      return V === null || V.tag !== 6 ? (V = Vd(Z, B.mode, oe), V.return = B, V) : (V = p(V, Z), V.return = B, V);
    }
    function L(B, V, Z, oe) {
      var Ee = Z.type;
      return Ee === w ? Q(
        B,
        V,
        Z.props.children,
        oe,
        Z.key
      ) : V !== null && (V.elementType === Ee || typeof Ee == "object" && Ee !== null && Ee.$$typeof === N && na(Ee) === V.type) ? (V = p(V, Z.props), Ss(V, Z), V.return = B, V) : (V = mc(
        Z.type,
        Z.key,
        Z.props,
        null,
        B.mode,
        oe
      ), Ss(V, Z), V.return = B, V);
    }
    function F(B, V, Z, oe) {
      return V === null || V.tag !== 4 || V.stateNode.containerInfo !== Z.containerInfo || V.stateNode.implementation !== Z.implementation ? (V = Ud(Z, B.mode, oe), V.return = B, V) : (V = p(V, Z.children || []), V.return = B, V);
    }
    function Q(B, V, Z, oe, Ee) {
      return V === null || V.tag !== 7 ? (V = Ko(
        Z,
        B.mode,
        oe,
        Ee
      ), V.return = B, V) : (V = p(V, Z), V.return = B, V);
    }
    function ae(B, V, Z) {
      if (typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint")
        return V = Vd(
          "" + V,
          B.mode,
          Z
        ), V.return = B, V;
      if (typeof V == "object" && V !== null) {
        switch (V.$$typeof) {
          case x:
            return Z = mc(
              V.type,
              V.key,
              V.props,
              null,
              B.mode,
              Z
            ), Ss(Z, V), Z.return = B, Z;
          case E:
            return V = Ud(
              V,
              B.mode,
              Z
            ), V.return = B, V;
          case N:
            return V = na(V), ae(B, V, Z);
        }
        if (de(V) || J(V))
          return V = Ko(
            V,
            B.mode,
            Z,
            null
          ), V.return = B, V;
        if (typeof V.then == "function")
          return ae(B, wc(V), Z);
        if (V.$$typeof === T)
          return ae(
            B,
            yc(B, V),
            Z
          );
        Ec(B, V);
      }
      return null;
    }
    function q(B, V, Z, oe) {
      var Ee = V !== null ? V.key : null;
      if (typeof Z == "string" && Z !== "" || typeof Z == "number" || typeof Z == "bigint")
        return Ee !== null ? null : z(B, V, "" + Z, oe);
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case x:
            return Z.key === Ee ? L(B, V, Z, oe) : null;
          case E:
            return Z.key === Ee ? F(B, V, Z, oe) : null;
          case N:
            return Z = na(Z), q(B, V, Z, oe);
        }
        if (de(Z) || J(Z))
          return Ee !== null ? null : Q(B, V, Z, oe, null);
        if (typeof Z.then == "function")
          return q(
            B,
            V,
            wc(Z),
            oe
          );
        if (Z.$$typeof === T)
          return q(
            B,
            V,
            yc(B, Z),
            oe
          );
        Ec(B, Z);
      }
      return null;
    }
    function K(B, V, Z, oe, Ee) {
      if (typeof oe == "string" && oe !== "" || typeof oe == "number" || typeof oe == "bigint")
        return B = B.get(Z) || null, z(V, B, "" + oe, Ee);
      if (typeof oe == "object" && oe !== null) {
        switch (oe.$$typeof) {
          case x:
            return B = B.get(
              oe.key === null ? Z : oe.key
            ) || null, L(V, B, oe, Ee);
          case E:
            return B = B.get(
              oe.key === null ? Z : oe.key
            ) || null, F(V, B, oe, Ee);
          case N:
            return oe = na(oe), K(
              B,
              V,
              Z,
              oe,
              Ee
            );
        }
        if (de(oe) || J(oe))
          return B = B.get(Z) || null, Q(V, B, oe, Ee, null);
        if (typeof oe.then == "function")
          return K(
            B,
            V,
            Z,
            wc(oe),
            Ee
          );
        if (oe.$$typeof === T)
          return K(
            B,
            V,
            Z,
            yc(V, oe),
            Ee
          );
        Ec(V, oe);
      }
      return null;
    }
    function ve(B, V, Z, oe) {
      for (var Ee = null, He = null, Se = V, De = V = 0, Ve = null; Se !== null && De < Z.length; De++) {
        Se.index > De ? (Ve = Se, Se = null) : Ve = Se.sibling;
        var Ze = q(
          B,
          Se,
          Z[De],
          oe
        );
        if (Ze === null) {
          Se === null && (Se = Ve);
          break;
        }
        r && Se && Ze.alternate === null && a(B, Se), V = g(Ze, V, De), He === null ? Ee = Ze : He.sibling = Ze, He = Ze, Se = Ve;
      }
      if (De === Z.length)
        return s(B, Se), Ue && Ar(B, De), Ee;
      if (Se === null) {
        for (; De < Z.length; De++)
          Se = ae(B, Z[De], oe), Se !== null && (V = g(
            Se,
            V,
            De
          ), He === null ? Ee = Se : He.sibling = Se, He = Se);
        return Ue && Ar(B, De), Ee;
      }
      for (Se = u(Se); De < Z.length; De++)
        Ve = K(
          Se,
          B,
          De,
          Z[De],
          oe
        ), Ve !== null && (r && Ve.alternate !== null && Se.delete(
          Ve.key === null ? De : Ve.key
        ), V = g(
          Ve,
          V,
          De
        ), He === null ? Ee = Ve : He.sibling = Ve, He = Ve);
      return r && Se.forEach(function(xo) {
        return a(B, xo);
      }), Ue && Ar(B, De), Ee;
    }
    function _e(B, V, Z, oe) {
      if (Z == null) throw Error(o(151));
      for (var Ee = null, He = null, Se = V, De = V = 0, Ve = null, Ze = Z.next(); Se !== null && !Ze.done; De++, Ze = Z.next()) {
        Se.index > De ? (Ve = Se, Se = null) : Ve = Se.sibling;
        var xo = q(B, Se, Ze.value, oe);
        if (xo === null) {
          Se === null && (Se = Ve);
          break;
        }
        r && Se && xo.alternate === null && a(B, Se), V = g(xo, V, De), He === null ? Ee = xo : He.sibling = xo, He = xo, Se = Ve;
      }
      if (Ze.done)
        return s(B, Se), Ue && Ar(B, De), Ee;
      if (Se === null) {
        for (; !Ze.done; De++, Ze = Z.next())
          Ze = ae(B, Ze.value, oe), Ze !== null && (V = g(Ze, V, De), He === null ? Ee = Ze : He.sibling = Ze, He = Ze);
        return Ue && Ar(B, De), Ee;
      }
      for (Se = u(Se); !Ze.done; De++, Ze = Z.next())
        Ze = K(Se, B, De, Ze.value, oe), Ze !== null && (r && Ze.alternate !== null && Se.delete(Ze.key === null ? De : Ze.key), V = g(Ze, V, De), He === null ? Ee = Ze : He.sibling = Ze, He = Ze);
      return r && Se.forEach(function(eO) {
        return a(B, eO);
      }), Ue && Ar(B, De), Ee;
    }
    function Je(B, V, Z, oe) {
      if (typeof Z == "object" && Z !== null && Z.type === w && Z.key === null && (Z = Z.props.children), typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case x:
            e: {
              for (var Ee = Z.key; V !== null; ) {
                if (V.key === Ee) {
                  if (Ee = Z.type, Ee === w) {
                    if (V.tag === 7) {
                      s(
                        B,
                        V.sibling
                      ), oe = p(
                        V,
                        Z.props.children
                      ), oe.return = B, B = oe;
                      break e;
                    }
                  } else if (V.elementType === Ee || typeof Ee == "object" && Ee !== null && Ee.$$typeof === N && na(Ee) === V.type) {
                    s(
                      B,
                      V.sibling
                    ), oe = p(V, Z.props), Ss(oe, Z), oe.return = B, B = oe;
                    break e;
                  }
                  s(B, V);
                  break;
                } else a(B, V);
                V = V.sibling;
              }
              Z.type === w ? (oe = Ko(
                Z.props.children,
                B.mode,
                oe,
                Z.key
              ), oe.return = B, B = oe) : (oe = mc(
                Z.type,
                Z.key,
                Z.props,
                null,
                B.mode,
                oe
              ), Ss(oe, Z), oe.return = B, B = oe);
            }
            return _(B);
          case E:
            e: {
              for (Ee = Z.key; V !== null; ) {
                if (V.key === Ee)
                  if (V.tag === 4 && V.stateNode.containerInfo === Z.containerInfo && V.stateNode.implementation === Z.implementation) {
                    s(
                      B,
                      V.sibling
                    ), oe = p(V, Z.children || []), oe.return = B, B = oe;
                    break e;
                  } else {
                    s(B, V);
                    break;
                  }
                else a(B, V);
                V = V.sibling;
              }
              oe = Ud(Z, B.mode, oe), oe.return = B, B = oe;
            }
            return _(B);
          case N:
            return Z = na(Z), Je(
              B,
              V,
              Z,
              oe
            );
        }
        if (de(Z))
          return ve(
            B,
            V,
            Z,
            oe
          );
        if (J(Z)) {
          if (Ee = J(Z), typeof Ee != "function") throw Error(o(150));
          return Z = Ee.call(Z), _e(
            B,
            V,
            Z,
            oe
          );
        }
        if (typeof Z.then == "function")
          return Je(
            B,
            V,
            wc(Z),
            oe
          );
        if (Z.$$typeof === T)
          return Je(
            B,
            V,
            yc(B, Z),
            oe
          );
        Ec(B, Z);
      }
      return typeof Z == "string" && Z !== "" || typeof Z == "number" || typeof Z == "bigint" ? (Z = "" + Z, V !== null && V.tag === 6 ? (s(B, V.sibling), oe = p(V, Z), oe.return = B, B = oe) : (s(B, V), oe = Vd(Z, B.mode, oe), oe.return = B, B = oe), _(B)) : s(B, V);
    }
    return function(B, V, Z, oe) {
      try {
        xs = 0;
        var Ee = Je(
          B,
          V,
          Z,
          oe
        );
        return Ja = null, Ee;
      } catch (Se) {
        if (Se === Ka || Se === xc) throw Se;
        var He = mn(29, Se, null, B.mode);
        return He.lanes = oe, He.return = B, He;
      }
    };
  }
  var oa = g0(!0), v0 = g0(!1), no = !1;
  function Jd(r) {
    r.updateQueue = {
      baseState: r.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Qd(r, a) {
    r = r.updateQueue, a.updateQueue === r && (a.updateQueue = {
      baseState: r.baseState,
      firstBaseUpdate: r.firstBaseUpdate,
      lastBaseUpdate: r.lastBaseUpdate,
      shared: r.shared,
      callbacks: null
    });
  }
  function ro(r) {
    return { lane: r, tag: 0, payload: null, callback: null, next: null };
  }
  function oo(r, a, s) {
    var u = r.updateQueue;
    if (u === null) return null;
    if (u = u.shared, (Fe & 2) !== 0) {
      var p = u.pending;
      return p === null ? a.next = a : (a.next = p.next, p.next = a), u.pending = a, a = pc(r), e0(r, null, s), a;
    }
    return hc(r, u, a, s), pc(r);
  }
  function ws(r, a, s) {
    if (a = a.updateQueue, a !== null && (a = a.shared, (s & 4194048) !== 0)) {
      var u = a.lanes;
      u &= r.pendingLanes, s |= u, a.lanes = s, ly(r, s);
    }
  }
  function eh(r, a) {
    var s = r.updateQueue, u = r.alternate;
    if (u !== null && (u = u.updateQueue, s === u)) {
      var p = null, g = null;
      if (s = s.firstBaseUpdate, s !== null) {
        do {
          var _ = {
            lane: s.lane,
            tag: s.tag,
            payload: s.payload,
            callback: null,
            next: null
          };
          g === null ? p = g = _ : g = g.next = _, s = s.next;
        } while (s !== null);
        g === null ? p = g = a : g = g.next = a;
      } else p = g = a;
      s = {
        baseState: u.baseState,
        firstBaseUpdate: p,
        lastBaseUpdate: g,
        shared: u.shared,
        callbacks: u.callbacks
      }, r.updateQueue = s;
      return;
    }
    r = s.lastBaseUpdate, r === null ? s.firstBaseUpdate = a : r.next = a, s.lastBaseUpdate = a;
  }
  var th = !1;
  function Es() {
    if (th) {
      var r = Xa;
      if (r !== null) throw r;
    }
  }
  function _s(r, a, s, u) {
    th = !1;
    var p = r.updateQueue;
    no = !1;
    var g = p.firstBaseUpdate, _ = p.lastBaseUpdate, z = p.shared.pending;
    if (z !== null) {
      p.shared.pending = null;
      var L = z, F = L.next;
      L.next = null, _ === null ? g = F : _.next = F, _ = L;
      var Q = r.alternate;
      Q !== null && (Q = Q.updateQueue, z = Q.lastBaseUpdate, z !== _ && (z === null ? Q.firstBaseUpdate = F : z.next = F, Q.lastBaseUpdate = L));
    }
    if (g !== null) {
      var ae = p.baseState;
      _ = 0, Q = F = L = null, z = g;
      do {
        var q = z.lane & -536870913, K = q !== z.lane;
        if (K ? (Ie & q) === q : (u & q) === q) {
          q !== 0 && q === Wa && (th = !0), Q !== null && (Q = Q.next = {
            lane: 0,
            tag: z.tag,
            payload: z.payload,
            callback: null,
            next: null
          });
          e: {
            var ve = r, _e = z;
            q = a;
            var Je = s;
            switch (_e.tag) {
              case 1:
                if (ve = _e.payload, typeof ve == "function") {
                  ae = ve.call(Je, ae, q);
                  break e;
                }
                ae = ve;
                break e;
              case 3:
                ve.flags = ve.flags & -65537 | 128;
              case 0:
                if (ve = _e.payload, q = typeof ve == "function" ? ve.call(Je, ae, q) : ve, q == null) break e;
                ae = v({}, ae, q);
                break e;
              case 2:
                no = !0;
            }
          }
          q = z.callback, q !== null && (r.flags |= 64, K && (r.flags |= 8192), K = p.callbacks, K === null ? p.callbacks = [q] : K.push(q));
        } else
          K = {
            lane: q,
            tag: z.tag,
            payload: z.payload,
            callback: z.callback,
            next: null
          }, Q === null ? (F = Q = K, L = ae) : Q = Q.next = K, _ |= q;
        if (z = z.next, z === null) {
          if (z = p.shared.pending, z === null)
            break;
          K = z, z = K.next, K.next = null, p.lastBaseUpdate = K, p.shared.pending = null;
        }
      } while (!0);
      Q === null && (L = ae), p.baseState = L, p.firstBaseUpdate = F, p.lastBaseUpdate = Q, g === null && (p.shared.lanes = 0), co |= _, r.lanes = _, r.memoizedState = ae;
    }
  }
  function y0(r, a) {
    if (typeof r != "function")
      throw Error(o(191, r));
    r.call(a);
  }
  function b0(r, a) {
    var s = r.callbacks;
    if (s !== null)
      for (r.callbacks = null, r = 0; r < s.length; r++)
        y0(s[r], a);
  }
  var Qa = j(null), _c = j(0);
  function x0(r, a) {
    r = Ir, $(_c, r), $(Qa, a), Ir = r | a.baseLanes;
  }
  function nh() {
    $(_c, Ir), $(Qa, Qa.current);
  }
  function rh() {
    Ir = _c.current, W(Qa), W(_c);
  }
  var gn = j(null), On = null;
  function ao(r) {
    var a = r.alternate;
    $(bt, bt.current & 1), $(gn, r), On === null && (a === null || Qa.current !== null || a.memoizedState !== null) && (On = r);
  }
  function oh(r) {
    $(bt, bt.current), $(gn, r), On === null && (On = r);
  }
  function S0(r) {
    r.tag === 22 ? ($(bt, bt.current), $(gn, r), On === null && (On = r)) : io();
  }
  function io() {
    $(bt, bt.current), $(gn, gn.current);
  }
  function vn(r) {
    W(gn), On === r && (On = null), W(bt);
  }
  var bt = j(0);
  function Tc(r) {
    for (var a = r; a !== null; ) {
      if (a.tag === 13) {
        var s = a.memoizedState;
        if (s !== null && (s = s.dehydrated, s === null || up(s) || fp(s)))
          return a;
      } else if (a.tag === 19 && (a.memoizedProps.revealOrder === "forwards" || a.memoizedProps.revealOrder === "backwards" || a.memoizedProps.revealOrder === "unstable_legacy-backwards" || a.memoizedProps.revealOrder === "together")) {
        if ((a.flags & 128) !== 0) return a;
      } else if (a.child !== null) {
        a.child.return = a, a = a.child;
        continue;
      }
      if (a === r) break;
      for (; a.sibling === null; ) {
        if (a.return === null || a.return === r) return null;
        a = a.return;
      }
      a.sibling.return = a.return, a = a.sibling;
    }
    return null;
  }
  var zr = 0, Me = null, Xe = null, Et = null, Cc = !1, ei = !1, aa = !1, Ac = 0, Ts = 0, ti = null, ZD = 0;
  function mt() {
    throw Error(o(321));
  }
  function ah(r, a) {
    if (a === null) return !1;
    for (var s = 0; s < a.length && s < r.length; s++)
      if (!pn(r[s], a[s])) return !1;
    return !0;
  }
  function ih(r, a, s, u, p, g) {
    return zr = g, Me = a, a.memoizedState = null, a.updateQueue = null, a.lanes = 0, I.H = r === null || r.memoizedState === null ? ob : Sh, aa = !1, g = s(u, p), aa = !1, ei && (g = E0(
      a,
      s,
      u,
      p
    )), w0(r), g;
  }
  function w0(r) {
    I.H = Rs;
    var a = Xe !== null && Xe.next !== null;
    if (zr = 0, Et = Xe = Me = null, Cc = !1, Ts = 0, ti = null, a) throw Error(o(300));
    r === null || _t || (r = r.dependencies, r !== null && vc(r) && (_t = !0));
  }
  function E0(r, a, s, u) {
    Me = r;
    var p = 0;
    do {
      if (ei && (ti = null), Ts = 0, ei = !1, 25 <= p) throw Error(o(301));
      if (p += 1, Et = Xe = null, r.updateQueue != null) {
        var g = r.updateQueue;
        g.lastEffect = null, g.events = null, g.stores = null, g.memoCache != null && (g.memoCache.index = 0);
      }
      I.H = ab, g = a(s, u);
    } while (ei);
    return g;
  }
  function FD() {
    var r = I.H, a = r.useState()[0];
    return a = typeof a.then == "function" ? Cs(a) : a, r = r.useState()[0], (Xe !== null ? Xe.memoizedState : null) !== r && (Me.flags |= 1024), a;
  }
  function sh() {
    var r = Ac !== 0;
    return Ac = 0, r;
  }
  function lh(r, a, s) {
    a.updateQueue = r.updateQueue, a.flags &= -2053, r.lanes &= ~s;
  }
  function ch(r) {
    if (Cc) {
      for (r = r.memoizedState; r !== null; ) {
        var a = r.queue;
        a !== null && (a.pending = null), r = r.next;
      }
      Cc = !1;
    }
    zr = 0, Et = Xe = Me = null, ei = !1, Ts = Ac = 0, ti = null;
  }
  function Gt() {
    var r = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Et === null ? Me.memoizedState = Et = r : Et = Et.next = r, Et;
  }
  function xt() {
    if (Xe === null) {
      var r = Me.alternate;
      r = r !== null ? r.memoizedState : null;
    } else r = Xe.next;
    var a = Et === null ? Me.memoizedState : Et.next;
    if (a !== null)
      Et = a, Xe = r;
    else {
      if (r === null)
        throw Me.alternate === null ? Error(o(467)) : Error(o(310));
      Xe = r, r = {
        memoizedState: Xe.memoizedState,
        baseState: Xe.baseState,
        baseQueue: Xe.baseQueue,
        queue: Xe.queue,
        next: null
      }, Et === null ? Me.memoizedState = Et = r : Et = Et.next = r;
    }
    return Et;
  }
  function Rc() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Cs(r) {
    var a = Ts;
    return Ts += 1, ti === null && (ti = []), r = h0(ti, r, a), a = Me, (Et === null ? a.memoizedState : Et.next) === null && (a = a.alternate, I.H = a === null || a.memoizedState === null ? ob : Sh), r;
  }
  function Mc(r) {
    if (r !== null && typeof r == "object") {
      if (typeof r.then == "function") return Cs(r);
      if (r.$$typeof === T) return It(r);
    }
    throw Error(o(438, String(r)));
  }
  function uh(r) {
    var a = null, s = Me.updateQueue;
    if (s !== null && (a = s.memoCache), a == null) {
      var u = Me.alternate;
      u !== null && (u = u.updateQueue, u !== null && (u = u.memoCache, u != null && (a = {
        data: u.data.map(function(p) {
          return p.slice();
        }),
        index: 0
      })));
    }
    if (a == null && (a = { data: [], index: 0 }), s === null && (s = Rc(), Me.updateQueue = s), s.memoCache = a, s = a.data[a.index], s === void 0)
      for (s = a.data[a.index] = Array(r), u = 0; u < r; u++)
        s[u] = Y;
    return a.index++, s;
  }
  function Dr(r, a) {
    return typeof a == "function" ? a(r) : a;
  }
  function zc(r) {
    var a = xt();
    return fh(a, Xe, r);
  }
  function fh(r, a, s) {
    var u = r.queue;
    if (u === null) throw Error(o(311));
    u.lastRenderedReducer = s;
    var p = r.baseQueue, g = u.pending;
    if (g !== null) {
      if (p !== null) {
        var _ = p.next;
        p.next = g.next, g.next = _;
      }
      a.baseQueue = p = g, u.pending = null;
    }
    if (g = r.baseState, p === null) r.memoizedState = g;
    else {
      a = p.next;
      var z = _ = null, L = null, F = a, Q = !1;
      do {
        var ae = F.lane & -536870913;
        if (ae !== F.lane ? (Ie & ae) === ae : (zr & ae) === ae) {
          var q = F.revertLane;
          if (q === 0)
            L !== null && (L = L.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: F.action,
              hasEagerState: F.hasEagerState,
              eagerState: F.eagerState,
              next: null
            }), ae === Wa && (Q = !0);
          else if ((zr & q) === q) {
            F = F.next, q === Wa && (Q = !0);
            continue;
          } else
            ae = {
              lane: 0,
              revertLane: F.revertLane,
              gesture: null,
              action: F.action,
              hasEagerState: F.hasEagerState,
              eagerState: F.eagerState,
              next: null
            }, L === null ? (z = L = ae, _ = g) : L = L.next = ae, Me.lanes |= q, co |= q;
          ae = F.action, aa && s(g, ae), g = F.hasEagerState ? F.eagerState : s(g, ae);
        } else
          q = {
            lane: ae,
            revertLane: F.revertLane,
            gesture: F.gesture,
            action: F.action,
            hasEagerState: F.hasEagerState,
            eagerState: F.eagerState,
            next: null
          }, L === null ? (z = L = q, _ = g) : L = L.next = q, Me.lanes |= ae, co |= ae;
        F = F.next;
      } while (F !== null && F !== a);
      if (L === null ? _ = g : L.next = z, !pn(g, r.memoizedState) && (_t = !0, Q && (s = Xa, s !== null)))
        throw s;
      r.memoizedState = g, r.baseState = _, r.baseQueue = L, u.lastRenderedState = g;
    }
    return p === null && (u.lanes = 0), [r.memoizedState, u.dispatch];
  }
  function dh(r) {
    var a = xt(), s = a.queue;
    if (s === null) throw Error(o(311));
    s.lastRenderedReducer = r;
    var u = s.dispatch, p = s.pending, g = a.memoizedState;
    if (p !== null) {
      s.pending = null;
      var _ = p = p.next;
      do
        g = r(g, _.action), _ = _.next;
      while (_ !== p);
      pn(g, a.memoizedState) || (_t = !0), a.memoizedState = g, a.baseQueue === null && (a.baseState = g), s.lastRenderedState = g;
    }
    return [g, u];
  }
  function _0(r, a, s) {
    var u = Me, p = xt(), g = Ue;
    if (g) {
      if (s === void 0) throw Error(o(407));
      s = s();
    } else s = a();
    var _ = !pn(
      (Xe || p).memoizedState,
      s
    );
    if (_ && (p.memoizedState = s, _t = !0), p = p.queue, mh(A0.bind(null, u, p, r), [
      r
    ]), p.getSnapshot !== a || _ || Et !== null && Et.memoizedState.tag & 1) {
      if (u.flags |= 2048, ni(
        9,
        { destroy: void 0 },
        C0.bind(
          null,
          u,
          p,
          s,
          a
        ),
        null
      ), et === null) throw Error(o(349));
      g || (zr & 127) !== 0 || T0(u, a, s);
    }
    return s;
  }
  function T0(r, a, s) {
    r.flags |= 16384, r = { getSnapshot: a, value: s }, a = Me.updateQueue, a === null ? (a = Rc(), Me.updateQueue = a, a.stores = [r]) : (s = a.stores, s === null ? a.stores = [r] : s.push(r));
  }
  function C0(r, a, s, u) {
    a.value = s, a.getSnapshot = u, R0(a) && M0(r);
  }
  function A0(r, a, s) {
    return s(function() {
      R0(a) && M0(r);
    });
  }
  function R0(r) {
    var a = r.getSnapshot;
    r = r.value;
    try {
      var s = a();
      return !pn(r, s);
    } catch {
      return !0;
    }
  }
  function M0(r) {
    var a = Xo(r, 2);
    a !== null && sn(a, r, 2);
  }
  function hh(r) {
    var a = Gt();
    if (typeof r == "function") {
      var s = r;
      if (r = s(), aa) {
        Wr(!0);
        try {
          s();
        } finally {
          Wr(!1);
        }
      }
    }
    return a.memoizedState = a.baseState = r, a.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Dr,
      lastRenderedState: r
    }, a;
  }
  function z0(r, a, s, u) {
    return r.baseState = s, fh(
      r,
      Xe,
      typeof u == "function" ? u : Dr
    );
  }
  function GD(r, a, s, u, p) {
    if (Oc(r)) throw Error(o(485));
    if (r = a.action, r !== null) {
      var g = {
        payload: p,
        action: r,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(_) {
          g.listeners.push(_);
        }
      };
      I.T !== null ? s(!0) : g.isTransition = !1, u(g), s = a.pending, s === null ? (g.next = a.pending = g, D0(a, g)) : (g.next = s.next, a.pending = s.next = g);
    }
  }
  function D0(r, a) {
    var s = a.action, u = a.payload, p = r.state;
    if (a.isTransition) {
      var g = I.T, _ = {};
      I.T = _;
      try {
        var z = s(p, u), L = I.S;
        L !== null && L(_, z), N0(r, a, z);
      } catch (F) {
        ph(r, a, F);
      } finally {
        g !== null && _.types !== null && (g.types = _.types), I.T = g;
      }
    } else
      try {
        g = s(p, u), N0(r, a, g);
      } catch (F) {
        ph(r, a, F);
      }
  }
  function N0(r, a, s) {
    s !== null && typeof s == "object" && typeof s.then == "function" ? s.then(
      function(u) {
        O0(r, a, u);
      },
      function(u) {
        return ph(r, a, u);
      }
    ) : O0(r, a, s);
  }
  function O0(r, a, s) {
    a.status = "fulfilled", a.value = s, j0(a), r.state = s, a = r.pending, a !== null && (s = a.next, s === a ? r.pending = null : (s = s.next, a.next = s, D0(r, s)));
  }
  function ph(r, a, s) {
    var u = r.pending;
    if (r.pending = null, u !== null) {
      u = u.next;
      do
        a.status = "rejected", a.reason = s, j0(a), a = a.next;
      while (a !== u);
    }
    r.action = null;
  }
  function j0(r) {
    r = r.listeners;
    for (var a = 0; a < r.length; a++) (0, r[a])();
  }
  function k0(r, a) {
    return a;
  }
  function P0(r, a) {
    if (Ue) {
      var s = et.formState;
      if (s !== null) {
        e: {
          var u = Me;
          if (Ue) {
            if (at) {
              t: {
                for (var p = at, g = Nn; p.nodeType !== 8; ) {
                  if (!g) {
                    p = null;
                    break t;
                  }
                  if (p = jn(
                    p.nextSibling
                  ), p === null) {
                    p = null;
                    break t;
                  }
                }
                g = p.data, p = g === "F!" || g === "F" ? p : null;
              }
              if (p) {
                at = jn(
                  p.nextSibling
                ), u = p.data === "F!";
                break e;
              }
            }
            eo(u);
          }
          u = !1;
        }
        u && (a = s[0]);
      }
    }
    return s = Gt(), s.memoizedState = s.baseState = a, u = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: k0,
      lastRenderedState: a
    }, s.queue = u, s = tb.bind(
      null,
      Me,
      u
    ), u.dispatch = s, u = hh(!1), g = xh.bind(
      null,
      Me,
      !1,
      u.queue
    ), u = Gt(), p = {
      state: a,
      dispatch: null,
      action: r,
      pending: null
    }, u.queue = p, s = GD.bind(
      null,
      Me,
      p,
      g,
      s
    ), p.dispatch = s, u.memoizedState = r, [a, s, !1];
  }
  function L0(r) {
    var a = xt();
    return I0(a, Xe, r);
  }
  function I0(r, a, s) {
    if (a = fh(
      r,
      a,
      k0
    )[0], r = zc(Dr)[0], typeof a == "object" && a !== null && typeof a.then == "function")
      try {
        var u = Cs(a);
      } catch (_) {
        throw _ === Ka ? xc : _;
      }
    else u = a;
    a = xt();
    var p = a.queue, g = p.dispatch;
    return s !== a.memoizedState && (Me.flags |= 2048, ni(
      9,
      { destroy: void 0 },
      YD.bind(null, p, s),
      null
    )), [u, g, r];
  }
  function YD(r, a) {
    r.action = a;
  }
  function V0(r) {
    var a = xt(), s = Xe;
    if (s !== null)
      return I0(a, s, r);
    xt(), a = a.memoizedState, s = xt();
    var u = s.queue.dispatch;
    return s.memoizedState = r, [a, u, !1];
  }
  function ni(r, a, s, u) {
    return r = { tag: r, create: s, deps: u, inst: a, next: null }, a = Me.updateQueue, a === null && (a = Rc(), Me.updateQueue = a), s = a.lastEffect, s === null ? a.lastEffect = r.next = r : (u = s.next, s.next = r, r.next = u, a.lastEffect = r), r;
  }
  function U0() {
    return xt().memoizedState;
  }
  function Dc(r, a, s, u) {
    var p = Gt();
    Me.flags |= r, p.memoizedState = ni(
      1 | a,
      { destroy: void 0 },
      s,
      u === void 0 ? null : u
    );
  }
  function Nc(r, a, s, u) {
    var p = xt();
    u = u === void 0 ? null : u;
    var g = p.memoizedState.inst;
    Xe !== null && u !== null && ah(u, Xe.memoizedState.deps) ? p.memoizedState = ni(a, g, s, u) : (Me.flags |= r, p.memoizedState = ni(
      1 | a,
      g,
      s,
      u
    ));
  }
  function B0(r, a) {
    Dc(8390656, 8, r, a);
  }
  function mh(r, a) {
    Nc(2048, 8, r, a);
  }
  function qD(r) {
    Me.flags |= 4;
    var a = Me.updateQueue;
    if (a === null)
      a = Rc(), Me.updateQueue = a, a.events = [r];
    else {
      var s = a.events;
      s === null ? a.events = [r] : s.push(r);
    }
  }
  function $0(r) {
    var a = xt().memoizedState;
    return qD({ ref: a, nextImpl: r }), function() {
      if ((Fe & 2) !== 0) throw Error(o(440));
      return a.impl.apply(void 0, arguments);
    };
  }
  function H0(r, a) {
    return Nc(4, 2, r, a);
  }
  function Z0(r, a) {
    return Nc(4, 4, r, a);
  }
  function F0(r, a) {
    if (typeof a == "function") {
      r = r();
      var s = a(r);
      return function() {
        typeof s == "function" ? s() : a(null);
      };
    }
    if (a != null)
      return r = r(), a.current = r, function() {
        a.current = null;
      };
  }
  function G0(r, a, s) {
    s = s != null ? s.concat([r]) : null, Nc(4, 4, F0.bind(null, a, r), s);
  }
  function gh() {
  }
  function Y0(r, a) {
    var s = xt();
    a = a === void 0 ? null : a;
    var u = s.memoizedState;
    return a !== null && ah(a, u[1]) ? u[0] : (s.memoizedState = [r, a], r);
  }
  function q0(r, a) {
    var s = xt();
    a = a === void 0 ? null : a;
    var u = s.memoizedState;
    if (a !== null && ah(a, u[1]))
      return u[0];
    if (u = r(), aa) {
      Wr(!0);
      try {
        r();
      } finally {
        Wr(!1);
      }
    }
    return s.memoizedState = [u, a], u;
  }
  function vh(r, a, s) {
    return s === void 0 || (zr & 1073741824) !== 0 && (Ie & 261930) === 0 ? r.memoizedState = a : (r.memoizedState = s, r = Wb(), Me.lanes |= r, co |= r, s);
  }
  function W0(r, a, s, u) {
    return pn(s, a) ? s : Qa.current !== null ? (r = vh(r, s, u), pn(r, a) || (_t = !0), r) : (zr & 42) === 0 || (zr & 1073741824) !== 0 && (Ie & 261930) === 0 ? (_t = !0, r.memoizedState = s) : (r = Wb(), Me.lanes |= r, co |= r, a);
  }
  function X0(r, a, s, u, p) {
    var g = G.p;
    G.p = g !== 0 && 8 > g ? g : 8;
    var _ = I.T, z = {};
    I.T = z, xh(r, !1, a, s);
    try {
      var L = p(), F = I.S;
      if (F !== null && F(z, L), L !== null && typeof L == "object" && typeof L.then == "function") {
        var Q = HD(
          L,
          u
        );
        As(
          r,
          a,
          Q,
          xn(r)
        );
      } else
        As(
          r,
          a,
          u,
          xn(r)
        );
    } catch (ae) {
      As(
        r,
        a,
        { then: function() {
        }, status: "rejected", reason: ae },
        xn()
      );
    } finally {
      G.p = g, _ !== null && z.types !== null && (_.types = z.types), I.T = _;
    }
  }
  function WD() {
  }
  function yh(r, a, s, u) {
    if (r.tag !== 5) throw Error(o(476));
    var p = K0(r).queue;
    X0(
      r,
      p,
      a,
      U,
      s === null ? WD : function() {
        return J0(r), s(u);
      }
    );
  }
  function K0(r) {
    var a = r.memoizedState;
    if (a !== null) return a;
    a = {
      memoizedState: U,
      baseState: U,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Dr,
        lastRenderedState: U
      },
      next: null
    };
    var s = {};
    return a.next = {
      memoizedState: s,
      baseState: s,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Dr,
        lastRenderedState: s
      },
      next: null
    }, r.memoizedState = a, r = r.alternate, r !== null && (r.memoizedState = a), a;
  }
  function J0(r) {
    var a = K0(r);
    a.next === null && (a = r.alternate.memoizedState), As(
      r,
      a.next.queue,
      {},
      xn()
    );
  }
  function bh() {
    return It(Zs);
  }
  function Q0() {
    return xt().memoizedState;
  }
  function eb() {
    return xt().memoizedState;
  }
  function XD(r) {
    for (var a = r.return; a !== null; ) {
      switch (a.tag) {
        case 24:
        case 3:
          var s = xn();
          r = ro(s);
          var u = oo(a, r, s);
          u !== null && (sn(u, a, s), ws(u, a, s)), a = { cache: qd() }, r.payload = a;
          return;
      }
      a = a.return;
    }
  }
  function KD(r, a, s) {
    var u = xn();
    s = {
      lane: u,
      revertLane: 0,
      gesture: null,
      action: s,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Oc(r) ? nb(a, s) : (s = Ld(r, a, s, u), s !== null && (sn(s, r, u), rb(s, a, u)));
  }
  function tb(r, a, s) {
    var u = xn();
    As(r, a, s, u);
  }
  function As(r, a, s, u) {
    var p = {
      lane: u,
      revertLane: 0,
      gesture: null,
      action: s,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Oc(r)) nb(a, p);
    else {
      var g = r.alternate;
      if (r.lanes === 0 && (g === null || g.lanes === 0) && (g = a.lastRenderedReducer, g !== null))
        try {
          var _ = a.lastRenderedState, z = g(_, s);
          if (p.hasEagerState = !0, p.eagerState = z, pn(z, _))
            return hc(r, a, p, 0), et === null && dc(), !1;
        } catch {
        }
      if (s = Ld(r, a, p, u), s !== null)
        return sn(s, r, u), rb(s, a, u), !0;
    }
    return !1;
  }
  function xh(r, a, s, u) {
    if (u = {
      lane: 2,
      revertLane: Jh(),
      gesture: null,
      action: u,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Oc(r)) {
      if (a) throw Error(o(479));
    } else
      a = Ld(
        r,
        s,
        u,
        2
      ), a !== null && sn(a, r, 2);
  }
  function Oc(r) {
    var a = r.alternate;
    return r === Me || a !== null && a === Me;
  }
  function nb(r, a) {
    ei = Cc = !0;
    var s = r.pending;
    s === null ? a.next = a : (a.next = s.next, s.next = a), r.pending = a;
  }
  function rb(r, a, s) {
    if ((s & 4194048) !== 0) {
      var u = a.lanes;
      u &= r.pendingLanes, s |= u, a.lanes = s, ly(r, s);
    }
  }
  var Rs = {
    readContext: It,
    use: Mc,
    useCallback: mt,
    useContext: mt,
    useEffect: mt,
    useImperativeHandle: mt,
    useLayoutEffect: mt,
    useInsertionEffect: mt,
    useMemo: mt,
    useReducer: mt,
    useRef: mt,
    useState: mt,
    useDebugValue: mt,
    useDeferredValue: mt,
    useTransition: mt,
    useSyncExternalStore: mt,
    useId: mt,
    useHostTransitionStatus: mt,
    useFormState: mt,
    useActionState: mt,
    useOptimistic: mt,
    useMemoCache: mt,
    useCacheRefresh: mt
  };
  Rs.useEffectEvent = mt;
  var ob = {
    readContext: It,
    use: Mc,
    useCallback: function(r, a) {
      return Gt().memoizedState = [
        r,
        a === void 0 ? null : a
      ], r;
    },
    useContext: It,
    useEffect: B0,
    useImperativeHandle: function(r, a, s) {
      s = s != null ? s.concat([r]) : null, Dc(
        4194308,
        4,
        F0.bind(null, a, r),
        s
      );
    },
    useLayoutEffect: function(r, a) {
      return Dc(4194308, 4, r, a);
    },
    useInsertionEffect: function(r, a) {
      Dc(4, 2, r, a);
    },
    useMemo: function(r, a) {
      var s = Gt();
      a = a === void 0 ? null : a;
      var u = r();
      if (aa) {
        Wr(!0);
        try {
          r();
        } finally {
          Wr(!1);
        }
      }
      return s.memoizedState = [u, a], u;
    },
    useReducer: function(r, a, s) {
      var u = Gt();
      if (s !== void 0) {
        var p = s(a);
        if (aa) {
          Wr(!0);
          try {
            s(a);
          } finally {
            Wr(!1);
          }
        }
      } else p = a;
      return u.memoizedState = u.baseState = p, r = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: r,
        lastRenderedState: p
      }, u.queue = r, r = r.dispatch = KD.bind(
        null,
        Me,
        r
      ), [u.memoizedState, r];
    },
    useRef: function(r) {
      var a = Gt();
      return r = { current: r }, a.memoizedState = r;
    },
    useState: function(r) {
      r = hh(r);
      var a = r.queue, s = tb.bind(null, Me, a);
      return a.dispatch = s, [r.memoizedState, s];
    },
    useDebugValue: gh,
    useDeferredValue: function(r, a) {
      var s = Gt();
      return vh(s, r, a);
    },
    useTransition: function() {
      var r = hh(!1);
      return r = X0.bind(
        null,
        Me,
        r.queue,
        !0,
        !1
      ), Gt().memoizedState = r, [!1, r];
    },
    useSyncExternalStore: function(r, a, s) {
      var u = Me, p = Gt();
      if (Ue) {
        if (s === void 0)
          throw Error(o(407));
        s = s();
      } else {
        if (s = a(), et === null)
          throw Error(o(349));
        (Ie & 127) !== 0 || T0(u, a, s);
      }
      p.memoizedState = s;
      var g = { value: s, getSnapshot: a };
      return p.queue = g, B0(A0.bind(null, u, g, r), [
        r
      ]), u.flags |= 2048, ni(
        9,
        { destroy: void 0 },
        C0.bind(
          null,
          u,
          g,
          s,
          a
        ),
        null
      ), s;
    },
    useId: function() {
      var r = Gt(), a = et.identifierPrefix;
      if (Ue) {
        var s = or, u = rr;
        s = (u & ~(1 << 32 - hn(u) - 1)).toString(32) + s, a = "_" + a + "R_" + s, s = Ac++, 0 < s && (a += "H" + s.toString(32)), a += "_";
      } else
        s = ZD++, a = "_" + a + "r_" + s.toString(32) + "_";
      return r.memoizedState = a;
    },
    useHostTransitionStatus: bh,
    useFormState: P0,
    useActionState: P0,
    useOptimistic: function(r) {
      var a = Gt();
      a.memoizedState = a.baseState = r;
      var s = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return a.queue = s, a = xh.bind(
        null,
        Me,
        !0,
        s
      ), s.dispatch = a, [r, a];
    },
    useMemoCache: uh,
    useCacheRefresh: function() {
      return Gt().memoizedState = XD.bind(
        null,
        Me
      );
    },
    useEffectEvent: function(r) {
      var a = Gt(), s = { impl: r };
      return a.memoizedState = s, function() {
        if ((Fe & 2) !== 0)
          throw Error(o(440));
        return s.impl.apply(void 0, arguments);
      };
    }
  }, Sh = {
    readContext: It,
    use: Mc,
    useCallback: Y0,
    useContext: It,
    useEffect: mh,
    useImperativeHandle: G0,
    useInsertionEffect: H0,
    useLayoutEffect: Z0,
    useMemo: q0,
    useReducer: zc,
    useRef: U0,
    useState: function() {
      return zc(Dr);
    },
    useDebugValue: gh,
    useDeferredValue: function(r, a) {
      var s = xt();
      return W0(
        s,
        Xe.memoizedState,
        r,
        a
      );
    },
    useTransition: function() {
      var r = zc(Dr)[0], a = xt().memoizedState;
      return [
        typeof r == "boolean" ? r : Cs(r),
        a
      ];
    },
    useSyncExternalStore: _0,
    useId: Q0,
    useHostTransitionStatus: bh,
    useFormState: L0,
    useActionState: L0,
    useOptimistic: function(r, a) {
      var s = xt();
      return z0(s, Xe, r, a);
    },
    useMemoCache: uh,
    useCacheRefresh: eb
  };
  Sh.useEffectEvent = $0;
  var ab = {
    readContext: It,
    use: Mc,
    useCallback: Y0,
    useContext: It,
    useEffect: mh,
    useImperativeHandle: G0,
    useInsertionEffect: H0,
    useLayoutEffect: Z0,
    useMemo: q0,
    useReducer: dh,
    useRef: U0,
    useState: function() {
      return dh(Dr);
    },
    useDebugValue: gh,
    useDeferredValue: function(r, a) {
      var s = xt();
      return Xe === null ? vh(s, r, a) : W0(
        s,
        Xe.memoizedState,
        r,
        a
      );
    },
    useTransition: function() {
      var r = dh(Dr)[0], a = xt().memoizedState;
      return [
        typeof r == "boolean" ? r : Cs(r),
        a
      ];
    },
    useSyncExternalStore: _0,
    useId: Q0,
    useHostTransitionStatus: bh,
    useFormState: V0,
    useActionState: V0,
    useOptimistic: function(r, a) {
      var s = xt();
      return Xe !== null ? z0(s, Xe, r, a) : (s.baseState = r, [r, s.queue.dispatch]);
    },
    useMemoCache: uh,
    useCacheRefresh: eb
  };
  ab.useEffectEvent = $0;
  function wh(r, a, s, u) {
    a = r.memoizedState, s = s(u, a), s = s == null ? a : v({}, a, s), r.memoizedState = s, r.lanes === 0 && (r.updateQueue.baseState = s);
  }
  var Eh = {
    enqueueSetState: function(r, a, s) {
      r = r._reactInternals;
      var u = xn(), p = ro(u);
      p.payload = a, s != null && (p.callback = s), a = oo(r, p, u), a !== null && (sn(a, r, u), ws(a, r, u));
    },
    enqueueReplaceState: function(r, a, s) {
      r = r._reactInternals;
      var u = xn(), p = ro(u);
      p.tag = 1, p.payload = a, s != null && (p.callback = s), a = oo(r, p, u), a !== null && (sn(a, r, u), ws(a, r, u));
    },
    enqueueForceUpdate: function(r, a) {
      r = r._reactInternals;
      var s = xn(), u = ro(s);
      u.tag = 2, a != null && (u.callback = a), a = oo(r, u, s), a !== null && (sn(a, r, s), ws(a, r, s));
    }
  };
  function ib(r, a, s, u, p, g, _) {
    return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(u, g, _) : a.prototype && a.prototype.isPureReactComponent ? !ps(s, u) || !ps(p, g) : !0;
  }
  function sb(r, a, s, u) {
    r = a.state, typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(s, u), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(s, u), a.state !== r && Eh.enqueueReplaceState(a, a.state, null);
  }
  function ia(r, a) {
    var s = a;
    if ("ref" in a) {
      s = {};
      for (var u in a)
        u !== "ref" && (s[u] = a[u]);
    }
    if (r = r.defaultProps) {
      s === a && (s = v({}, s));
      for (var p in r)
        s[p] === void 0 && (s[p] = r[p]);
    }
    return s;
  }
  function lb(r) {
    fc(r);
  }
  function cb(r) {
    console.error(r);
  }
  function ub(r) {
    fc(r);
  }
  function jc(r, a) {
    try {
      var s = r.onUncaughtError;
      s(a.value, { componentStack: a.stack });
    } catch (u) {
      setTimeout(function() {
        throw u;
      });
    }
  }
  function fb(r, a, s) {
    try {
      var u = r.onCaughtError;
      u(s.value, {
        componentStack: s.stack,
        errorBoundary: a.tag === 1 ? a.stateNode : null
      });
    } catch (p) {
      setTimeout(function() {
        throw p;
      });
    }
  }
  function _h(r, a, s) {
    return s = ro(s), s.tag = 3, s.payload = { element: null }, s.callback = function() {
      jc(r, a);
    }, s;
  }
  function db(r) {
    return r = ro(r), r.tag = 3, r;
  }
  function hb(r, a, s, u) {
    var p = s.type.getDerivedStateFromError;
    if (typeof p == "function") {
      var g = u.value;
      r.payload = function() {
        return p(g);
      }, r.callback = function() {
        fb(a, s, u);
      };
    }
    var _ = s.stateNode;
    _ !== null && typeof _.componentDidCatch == "function" && (r.callback = function() {
      fb(a, s, u), typeof p != "function" && (uo === null ? uo = /* @__PURE__ */ new Set([this]) : uo.add(this));
      var z = u.stack;
      this.componentDidCatch(u.value, {
        componentStack: z !== null ? z : ""
      });
    });
  }
  function JD(r, a, s, u, p) {
    if (s.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") {
      if (a = s.alternate, a !== null && qa(
        a,
        s,
        p,
        !0
      ), s = gn.current, s !== null) {
        switch (s.tag) {
          case 31:
          case 13:
            return On === null ? Gc() : s.alternate === null && gt === 0 && (gt = 3), s.flags &= -257, s.flags |= 65536, s.lanes = p, u === Sc ? s.flags |= 16384 : (a = s.updateQueue, a === null ? s.updateQueue = /* @__PURE__ */ new Set([u]) : a.add(u), Wh(r, u, p)), !1;
          case 22:
            return s.flags |= 65536, u === Sc ? s.flags |= 16384 : (a = s.updateQueue, a === null ? (a = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([u])
            }, s.updateQueue = a) : (s = a.retryQueue, s === null ? a.retryQueue = /* @__PURE__ */ new Set([u]) : s.add(u)), Wh(r, u, p)), !1;
        }
        throw Error(o(435, s.tag));
      }
      return Wh(r, u, p), Gc(), !1;
    }
    if (Ue)
      return a = gn.current, a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256), a.flags |= 65536, a.lanes = p, u !== Hd && (r = Error(o(422), { cause: u }), vs(Mn(r, s)))) : (u !== Hd && (a = Error(o(423), {
        cause: u
      }), vs(
        Mn(a, s)
      )), r = r.current.alternate, r.flags |= 65536, p &= -p, r.lanes |= p, u = Mn(u, s), p = _h(
        r.stateNode,
        u,
        p
      ), eh(r, p), gt !== 4 && (gt = 2)), !1;
    var g = Error(o(520), { cause: u });
    if (g = Mn(g, s), Ps === null ? Ps = [g] : Ps.push(g), gt !== 4 && (gt = 2), a === null) return !0;
    u = Mn(u, s), s = a;
    do {
      switch (s.tag) {
        case 3:
          return s.flags |= 65536, r = p & -p, s.lanes |= r, r = _h(s.stateNode, u, r), eh(s, r), !1;
        case 1:
          if (a = s.type, g = s.stateNode, (s.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || g !== null && typeof g.componentDidCatch == "function" && (uo === null || !uo.has(g))))
            return s.flags |= 65536, p &= -p, s.lanes |= p, p = db(p), hb(
              p,
              r,
              s,
              u
            ), eh(s, p), !1;
      }
      s = s.return;
    } while (s !== null);
    return !1;
  }
  var Th = Error(o(461)), _t = !1;
  function Vt(r, a, s, u) {
    a.child = r === null ? v0(a, null, s, u) : oa(
      a,
      r.child,
      s,
      u
    );
  }
  function pb(r, a, s, u, p) {
    s = s.render;
    var g = a.ref;
    if ("ref" in u) {
      var _ = {};
      for (var z in u)
        z !== "ref" && (_[z] = u[z]);
    } else _ = u;
    return ea(a), u = ih(
      r,
      a,
      s,
      _,
      g,
      p
    ), z = sh(), r !== null && !_t ? (lh(r, a, p), Nr(r, a, p)) : (Ue && z && Bd(a), a.flags |= 1, Vt(r, a, u, p), a.child);
  }
  function mb(r, a, s, u, p) {
    if (r === null) {
      var g = s.type;
      return typeof g == "function" && !Id(g) && g.defaultProps === void 0 && s.compare === null ? (a.tag = 15, a.type = g, gb(
        r,
        a,
        g,
        u,
        p
      )) : (r = mc(
        s.type,
        null,
        u,
        a,
        a.mode,
        p
      ), r.ref = a.ref, r.return = a, a.child = r);
    }
    if (g = r.child, !Oh(r, p)) {
      var _ = g.memoizedProps;
      if (s = s.compare, s = s !== null ? s : ps, s(_, u) && r.ref === a.ref)
        return Nr(r, a, p);
    }
    return a.flags |= 1, r = Cr(g, u), r.ref = a.ref, r.return = a, a.child = r;
  }
  function gb(r, a, s, u, p) {
    if (r !== null) {
      var g = r.memoizedProps;
      if (ps(g, u) && r.ref === a.ref)
        if (_t = !1, a.pendingProps = u = g, Oh(r, p))
          (r.flags & 131072) !== 0 && (_t = !0);
        else
          return a.lanes = r.lanes, Nr(r, a, p);
    }
    return Ch(
      r,
      a,
      s,
      u,
      p
    );
  }
  function vb(r, a, s, u) {
    var p = u.children, g = r !== null ? r.memoizedState : null;
    if (r === null && a.stateNode === null && (a.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), u.mode === "hidden") {
      if ((a.flags & 128) !== 0) {
        if (g = g !== null ? g.baseLanes | s : s, r !== null) {
          for (u = a.child = r.child, p = 0; u !== null; )
            p = p | u.lanes | u.childLanes, u = u.sibling;
          u = p & ~g;
        } else u = 0, a.child = null;
        return yb(
          r,
          a,
          g,
          s,
          u
        );
      }
      if ((s & 536870912) !== 0)
        a.memoizedState = { baseLanes: 0, cachePool: null }, r !== null && bc(
          a,
          g !== null ? g.cachePool : null
        ), g !== null ? x0(a, g) : nh(), S0(a);
      else
        return u = a.lanes = 536870912, yb(
          r,
          a,
          g !== null ? g.baseLanes | s : s,
          s,
          u
        );
    } else
      g !== null ? (bc(a, g.cachePool), x0(a, g), io(), a.memoizedState = null) : (r !== null && bc(a, null), nh(), io());
    return Vt(r, a, p, s), a.child;
  }
  function Ms(r, a) {
    return r !== null && r.tag === 22 || a.stateNode !== null || (a.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }), a.sibling;
  }
  function yb(r, a, s, u, p) {
    var g = Xd();
    return g = g === null ? null : { parent: wt._currentValue, pool: g }, a.memoizedState = {
      baseLanes: s,
      cachePool: g
    }, r !== null && bc(a, null), nh(), S0(a), r !== null && qa(r, a, u, !0), a.childLanes = p, null;
  }
  function kc(r, a) {
    return a = Lc(
      { mode: a.mode, children: a.children },
      r.mode
    ), a.ref = r.ref, r.child = a, a.return = r, a;
  }
  function bb(r, a, s) {
    return oa(a, r.child, null, s), r = kc(a, a.pendingProps), r.flags |= 2, vn(a), a.memoizedState = null, r;
  }
  function QD(r, a, s) {
    var u = a.pendingProps, p = (a.flags & 128) !== 0;
    if (a.flags &= -129, r === null) {
      if (Ue) {
        if (u.mode === "hidden")
          return r = kc(a, u), a.lanes = 536870912, Ms(null, r);
        if (oh(a), (r = at) ? (r = Dx(
          r,
          Nn
        ), r = r !== null && r.data === "&" ? r : null, r !== null && (a.memoizedState = {
          dehydrated: r,
          treeContext: Jr !== null ? { id: rr, overflow: or } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, s = n0(r), s.return = a, a.child = s, Lt = a, at = null)) : r = null, r === null) throw eo(a);
        return a.lanes = 536870912, null;
      }
      return kc(a, u);
    }
    var g = r.memoizedState;
    if (g !== null) {
      var _ = g.dehydrated;
      if (oh(a), p)
        if (a.flags & 256)
          a.flags &= -257, a = bb(
            r,
            a,
            s
          );
        else if (a.memoizedState !== null)
          a.child = r.child, a.flags |= 128, a = null;
        else throw Error(o(558));
      else if (_t || qa(r, a, s, !1), p = (s & r.childLanes) !== 0, _t || p) {
        if (u = et, u !== null && (_ = cy(u, s), _ !== 0 && _ !== g.retryLane))
          throw g.retryLane = _, Xo(r, _), sn(u, r, _), Th;
        Gc(), a = bb(
          r,
          a,
          s
        );
      } else
        r = g.treeContext, at = jn(_.nextSibling), Lt = a, Ue = !0, Qr = null, Nn = !1, r !== null && a0(a, r), a = kc(a, u), a.flags |= 4096;
      return a;
    }
    return r = Cr(r.child, {
      mode: u.mode,
      children: u.children
    }), r.ref = a.ref, a.child = r, r.return = a, r;
  }
  function Pc(r, a) {
    var s = a.ref;
    if (s === null)
      r !== null && r.ref !== null && (a.flags |= 4194816);
    else {
      if (typeof s != "function" && typeof s != "object")
        throw Error(o(284));
      (r === null || r.ref !== s) && (a.flags |= 4194816);
    }
  }
  function Ch(r, a, s, u, p) {
    return ea(a), s = ih(
      r,
      a,
      s,
      u,
      void 0,
      p
    ), u = sh(), r !== null && !_t ? (lh(r, a, p), Nr(r, a, p)) : (Ue && u && Bd(a), a.flags |= 1, Vt(r, a, s, p), a.child);
  }
  function xb(r, a, s, u, p, g) {
    return ea(a), a.updateQueue = null, s = E0(
      a,
      u,
      s,
      p
    ), w0(r), u = sh(), r !== null && !_t ? (lh(r, a, g), Nr(r, a, g)) : (Ue && u && Bd(a), a.flags |= 1, Vt(r, a, s, g), a.child);
  }
  function Sb(r, a, s, u, p) {
    if (ea(a), a.stateNode === null) {
      var g = Za, _ = s.contextType;
      typeof _ == "object" && _ !== null && (g = It(_)), g = new s(u, g), a.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null, g.updater = Eh, a.stateNode = g, g._reactInternals = a, g = a.stateNode, g.props = u, g.state = a.memoizedState, g.refs = {}, Jd(a), _ = s.contextType, g.context = typeof _ == "object" && _ !== null ? It(_) : Za, g.state = a.memoizedState, _ = s.getDerivedStateFromProps, typeof _ == "function" && (wh(
        a,
        s,
        _,
        u
      ), g.state = a.memoizedState), typeof s.getDerivedStateFromProps == "function" || typeof g.getSnapshotBeforeUpdate == "function" || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (_ = g.state, typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount(), _ !== g.state && Eh.enqueueReplaceState(g, g.state, null), _s(a, u, g, p), Es(), g.state = a.memoizedState), typeof g.componentDidMount == "function" && (a.flags |= 4194308), u = !0;
    } else if (r === null) {
      g = a.stateNode;
      var z = a.memoizedProps, L = ia(s, z);
      g.props = L;
      var F = g.context, Q = s.contextType;
      _ = Za, typeof Q == "object" && Q !== null && (_ = It(Q));
      var ae = s.getDerivedStateFromProps;
      Q = typeof ae == "function" || typeof g.getSnapshotBeforeUpdate == "function", z = a.pendingProps !== z, Q || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (z || F !== _) && sb(
        a,
        g,
        u,
        _
      ), no = !1;
      var q = a.memoizedState;
      g.state = q, _s(a, u, g, p), Es(), F = a.memoizedState, z || q !== F || no ? (typeof ae == "function" && (wh(
        a,
        s,
        ae,
        u
      ), F = a.memoizedState), (L = no || ib(
        a,
        s,
        L,
        u,
        q,
        F,
        _
      )) ? (Q || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (a.flags |= 4194308), a.memoizedProps = u, a.memoizedState = F), g.props = u, g.state = F, g.context = _, u = L) : (typeof g.componentDidMount == "function" && (a.flags |= 4194308), u = !1);
    } else {
      g = a.stateNode, Qd(r, a), _ = a.memoizedProps, Q = ia(s, _), g.props = Q, ae = a.pendingProps, q = g.context, F = s.contextType, L = Za, typeof F == "object" && F !== null && (L = It(F)), z = s.getDerivedStateFromProps, (F = typeof z == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (_ !== ae || q !== L) && sb(
        a,
        g,
        u,
        L
      ), no = !1, q = a.memoizedState, g.state = q, _s(a, u, g, p), Es();
      var K = a.memoizedState;
      _ !== ae || q !== K || no || r !== null && r.dependencies !== null && vc(r.dependencies) ? (typeof z == "function" && (wh(
        a,
        s,
        z,
        u
      ), K = a.memoizedState), (Q = no || ib(
        a,
        s,
        Q,
        u,
        q,
        K,
        L
      ) || r !== null && r.dependencies !== null && vc(r.dependencies)) ? (F || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(u, K, L), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(
        u,
        K,
        L
      )), typeof g.componentDidUpdate == "function" && (a.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || _ === r.memoizedProps && q === r.memoizedState || (a.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || _ === r.memoizedProps && q === r.memoizedState || (a.flags |= 1024), a.memoizedProps = u, a.memoizedState = K), g.props = u, g.state = K, g.context = L, u = Q) : (typeof g.componentDidUpdate != "function" || _ === r.memoizedProps && q === r.memoizedState || (a.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || _ === r.memoizedProps && q === r.memoizedState || (a.flags |= 1024), u = !1);
    }
    return g = u, Pc(r, a), u = (a.flags & 128) !== 0, g || u ? (g = a.stateNode, s = u && typeof s.getDerivedStateFromError != "function" ? null : g.render(), a.flags |= 1, r !== null && u ? (a.child = oa(
      a,
      r.child,
      null,
      p
    ), a.child = oa(
      a,
      null,
      s,
      p
    )) : Vt(r, a, s, p), a.memoizedState = g.state, r = a.child) : r = Nr(
      r,
      a,
      p
    ), r;
  }
  function wb(r, a, s, u) {
    return Jo(), a.flags |= 256, Vt(r, a, s, u), a.child;
  }
  var Ah = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Rh(r) {
    return { baseLanes: r, cachePool: f0() };
  }
  function Mh(r, a, s) {
    return r = r !== null ? r.childLanes & ~s : 0, a && (r |= bn), r;
  }
  function Eb(r, a, s) {
    var u = a.pendingProps, p = !1, g = (a.flags & 128) !== 0, _;
    if ((_ = g) || (_ = r !== null && r.memoizedState === null ? !1 : (bt.current & 2) !== 0), _ && (p = !0, a.flags &= -129), _ = (a.flags & 32) !== 0, a.flags &= -33, r === null) {
      if (Ue) {
        if (p ? ao(a) : io(), (r = at) ? (r = Dx(
          r,
          Nn
        ), r = r !== null && r.data !== "&" ? r : null, r !== null && (a.memoizedState = {
          dehydrated: r,
          treeContext: Jr !== null ? { id: rr, overflow: or } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, s = n0(r), s.return = a, a.child = s, Lt = a, at = null)) : r = null, r === null) throw eo(a);
        return fp(r) ? a.lanes = 32 : a.lanes = 536870912, null;
      }
      var z = u.children;
      return u = u.fallback, p ? (io(), p = a.mode, z = Lc(
        { mode: "hidden", children: z },
        p
      ), u = Ko(
        u,
        p,
        s,
        null
      ), z.return = a, u.return = a, z.sibling = u, a.child = z, u = a.child, u.memoizedState = Rh(s), u.childLanes = Mh(
        r,
        _,
        s
      ), a.memoizedState = Ah, Ms(null, u)) : (ao(a), zh(a, z));
    }
    var L = r.memoizedState;
    if (L !== null && (z = L.dehydrated, z !== null)) {
      if (g)
        a.flags & 256 ? (ao(a), a.flags &= -257, a = Dh(
          r,
          a,
          s
        )) : a.memoizedState !== null ? (io(), a.child = r.child, a.flags |= 128, a = null) : (io(), z = u.fallback, p = a.mode, u = Lc(
          { mode: "visible", children: u.children },
          p
        ), z = Ko(
          z,
          p,
          s,
          null
        ), z.flags |= 2, u.return = a, z.return = a, u.sibling = z, a.child = u, oa(
          a,
          r.child,
          null,
          s
        ), u = a.child, u.memoizedState = Rh(s), u.childLanes = Mh(
          r,
          _,
          s
        ), a.memoizedState = Ah, a = Ms(null, u));
      else if (ao(a), fp(z)) {
        if (_ = z.nextSibling && z.nextSibling.dataset, _) var F = _.dgst;
        _ = F, u = Error(o(419)), u.stack = "", u.digest = _, vs({ value: u, source: null, stack: null }), a = Dh(
          r,
          a,
          s
        );
      } else if (_t || qa(r, a, s, !1), _ = (s & r.childLanes) !== 0, _t || _) {
        if (_ = et, _ !== null && (u = cy(_, s), u !== 0 && u !== L.retryLane))
          throw L.retryLane = u, Xo(r, u), sn(_, r, u), Th;
        up(z) || Gc(), a = Dh(
          r,
          a,
          s
        );
      } else
        up(z) ? (a.flags |= 192, a.child = r.child, a = null) : (r = L.treeContext, at = jn(
          z.nextSibling
        ), Lt = a, Ue = !0, Qr = null, Nn = !1, r !== null && a0(a, r), a = zh(
          a,
          u.children
        ), a.flags |= 4096);
      return a;
    }
    return p ? (io(), z = u.fallback, p = a.mode, L = r.child, F = L.sibling, u = Cr(L, {
      mode: "hidden",
      children: u.children
    }), u.subtreeFlags = L.subtreeFlags & 65011712, F !== null ? z = Cr(
      F,
      z
    ) : (z = Ko(
      z,
      p,
      s,
      null
    ), z.flags |= 2), z.return = a, u.return = a, u.sibling = z, a.child = u, Ms(null, u), u = a.child, z = r.child.memoizedState, z === null ? z = Rh(s) : (p = z.cachePool, p !== null ? (L = wt._currentValue, p = p.parent !== L ? { parent: L, pool: L } : p) : p = f0(), z = {
      baseLanes: z.baseLanes | s,
      cachePool: p
    }), u.memoizedState = z, u.childLanes = Mh(
      r,
      _,
      s
    ), a.memoizedState = Ah, Ms(r.child, u)) : (ao(a), s = r.child, r = s.sibling, s = Cr(s, {
      mode: "visible",
      children: u.children
    }), s.return = a, s.sibling = null, r !== null && (_ = a.deletions, _ === null ? (a.deletions = [r], a.flags |= 16) : _.push(r)), a.child = s, a.memoizedState = null, s);
  }
  function zh(r, a) {
    return a = Lc(
      { mode: "visible", children: a },
      r.mode
    ), a.return = r, r.child = a;
  }
  function Lc(r, a) {
    return r = mn(22, r, null, a), r.lanes = 0, r;
  }
  function Dh(r, a, s) {
    return oa(a, r.child, null, s), r = zh(
      a,
      a.pendingProps.children
    ), r.flags |= 2, a.memoizedState = null, r;
  }
  function _b(r, a, s) {
    r.lanes |= a;
    var u = r.alternate;
    u !== null && (u.lanes |= a), Gd(r.return, a, s);
  }
  function Nh(r, a, s, u, p, g) {
    var _ = r.memoizedState;
    _ === null ? r.memoizedState = {
      isBackwards: a,
      rendering: null,
      renderingStartTime: 0,
      last: u,
      tail: s,
      tailMode: p,
      treeForkCount: g
    } : (_.isBackwards = a, _.rendering = null, _.renderingStartTime = 0, _.last = u, _.tail = s, _.tailMode = p, _.treeForkCount = g);
  }
  function Tb(r, a, s) {
    var u = a.pendingProps, p = u.revealOrder, g = u.tail;
    u = u.children;
    var _ = bt.current, z = (_ & 2) !== 0;
    if (z ? (_ = _ & 1 | 2, a.flags |= 128) : _ &= 1, $(bt, _), Vt(r, a, u, s), u = Ue ? gs : 0, !z && r !== null && (r.flags & 128) !== 0)
      e: for (r = a.child; r !== null; ) {
        if (r.tag === 13)
          r.memoizedState !== null && _b(r, s, a);
        else if (r.tag === 19)
          _b(r, s, a);
        else if (r.child !== null) {
          r.child.return = r, r = r.child;
          continue;
        }
        if (r === a) break e;
        for (; r.sibling === null; ) {
          if (r.return === null || r.return === a)
            break e;
          r = r.return;
        }
        r.sibling.return = r.return, r = r.sibling;
      }
    switch (p) {
      case "forwards":
        for (s = a.child, p = null; s !== null; )
          r = s.alternate, r !== null && Tc(r) === null && (p = s), s = s.sibling;
        s = p, s === null ? (p = a.child, a.child = null) : (p = s.sibling, s.sibling = null), Nh(
          a,
          !1,
          p,
          s,
          g,
          u
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        for (s = null, p = a.child, a.child = null; p !== null; ) {
          if (r = p.alternate, r !== null && Tc(r) === null) {
            a.child = p;
            break;
          }
          r = p.sibling, p.sibling = s, s = p, p = r;
        }
        Nh(
          a,
          !0,
          s,
          null,
          g,
          u
        );
        break;
      case "together":
        Nh(
          a,
          !1,
          null,
          null,
          void 0,
          u
        );
        break;
      default:
        a.memoizedState = null;
    }
    return a.child;
  }
  function Nr(r, a, s) {
    if (r !== null && (a.dependencies = r.dependencies), co |= a.lanes, (s & a.childLanes) === 0)
      if (r !== null) {
        if (qa(
          r,
          a,
          s,
          !1
        ), (s & a.childLanes) === 0)
          return null;
      } else return null;
    if (r !== null && a.child !== r.child)
      throw Error(o(153));
    if (a.child !== null) {
      for (r = a.child, s = Cr(r, r.pendingProps), a.child = s, s.return = a; r.sibling !== null; )
        r = r.sibling, s = s.sibling = Cr(r, r.pendingProps), s.return = a;
      s.sibling = null;
    }
    return a.child;
  }
  function Oh(r, a) {
    return (r.lanes & a) !== 0 ? !0 : (r = r.dependencies, !!(r !== null && vc(r)));
  }
  function eN(r, a, s) {
    switch (a.tag) {
      case 3:
        re(a, a.stateNode.containerInfo), to(a, wt, r.memoizedState.cache), Jo();
        break;
      case 27:
      case 5:
        fe(a);
        break;
      case 4:
        re(a, a.stateNode.containerInfo);
        break;
      case 10:
        to(
          a,
          a.type,
          a.memoizedProps.value
        );
        break;
      case 31:
        if (a.memoizedState !== null)
          return a.flags |= 128, oh(a), null;
        break;
      case 13:
        var u = a.memoizedState;
        if (u !== null)
          return u.dehydrated !== null ? (ao(a), a.flags |= 128, null) : (s & a.child.childLanes) !== 0 ? Eb(r, a, s) : (ao(a), r = Nr(
            r,
            a,
            s
          ), r !== null ? r.sibling : null);
        ao(a);
        break;
      case 19:
        var p = (r.flags & 128) !== 0;
        if (u = (s & a.childLanes) !== 0, u || (qa(
          r,
          a,
          s,
          !1
        ), u = (s & a.childLanes) !== 0), p) {
          if (u)
            return Tb(
              r,
              a,
              s
            );
          a.flags |= 128;
        }
        if (p = a.memoizedState, p !== null && (p.rendering = null, p.tail = null, p.lastEffect = null), $(bt, bt.current), u) break;
        return null;
      case 22:
        return a.lanes = 0, vb(
          r,
          a,
          s,
          a.pendingProps
        );
      case 24:
        to(a, wt, r.memoizedState.cache);
    }
    return Nr(r, a, s);
  }
  function Cb(r, a, s) {
    if (r !== null)
      if (r.memoizedProps !== a.pendingProps)
        _t = !0;
      else {
        if (!Oh(r, s) && (a.flags & 128) === 0)
          return _t = !1, eN(
            r,
            a,
            s
          );
        _t = (r.flags & 131072) !== 0;
      }
    else
      _t = !1, Ue && (a.flags & 1048576) !== 0 && o0(a, gs, a.index);
    switch (a.lanes = 0, a.tag) {
      case 16:
        e: {
          var u = a.pendingProps;
          if (r = na(a.elementType), a.type = r, typeof r == "function")
            Id(r) ? (u = ia(r, u), a.tag = 1, a = Sb(
              null,
              a,
              r,
              u,
              s
            )) : (a.tag = 0, a = Ch(
              null,
              a,
              r,
              u,
              s
            ));
          else {
            if (r != null) {
              var p = r.$$typeof;
              if (p === D) {
                a.tag = 11, a = pb(
                  null,
                  a,
                  r,
                  u,
                  s
                );
                break e;
              } else if (p === R) {
                a.tag = 14, a = mb(
                  null,
                  a,
                  r,
                  u,
                  s
                );
                break e;
              }
            }
            throw a = ue(r) || r, Error(o(306, a, ""));
          }
        }
        return a;
      case 0:
        return Ch(
          r,
          a,
          a.type,
          a.pendingProps,
          s
        );
      case 1:
        return u = a.type, p = ia(
          u,
          a.pendingProps
        ), Sb(
          r,
          a,
          u,
          p,
          s
        );
      case 3:
        e: {
          if (re(
            a,
            a.stateNode.containerInfo
          ), r === null) throw Error(o(387));
          u = a.pendingProps;
          var g = a.memoizedState;
          p = g.element, Qd(r, a), _s(a, u, null, s);
          var _ = a.memoizedState;
          if (u = _.cache, to(a, wt, u), u !== g.cache && Yd(
            a,
            [wt],
            s,
            !0
          ), Es(), u = _.element, g.isDehydrated)
            if (g = {
              element: u,
              isDehydrated: !1,
              cache: _.cache
            }, a.updateQueue.baseState = g, a.memoizedState = g, a.flags & 256) {
              a = wb(
                r,
                a,
                u,
                s
              );
              break e;
            } else if (u !== p) {
              p = Mn(
                Error(o(424)),
                a
              ), vs(p), a = wb(
                r,
                a,
                u,
                s
              );
              break e;
            } else
              for (r = a.stateNode.containerInfo, r.nodeType === 9 ? r = r.body : r = r.nodeName === "HTML" ? r.ownerDocument.body : r, at = jn(r.firstChild), Lt = a, Ue = !0, Qr = null, Nn = !0, s = v0(
                a,
                null,
                u,
                s
              ), a.child = s; s; )
                s.flags = s.flags & -3 | 4096, s = s.sibling;
          else {
            if (Jo(), u === p) {
              a = Nr(
                r,
                a,
                s
              );
              break e;
            }
            Vt(r, a, u, s);
          }
          a = a.child;
        }
        return a;
      case 26:
        return Pc(r, a), r === null ? (s = Lx(
          a.type,
          null,
          a.pendingProps,
          null
        )) ? a.memoizedState = s : Ue || (s = a.type, r = a.pendingProps, u = Qc(
          ie.current
        ).createElement(s), u[Pt] = a, u[en] = r, Ut(u, s, r), Ot(u), a.stateNode = u) : a.memoizedState = Lx(
          a.type,
          r.memoizedProps,
          a.pendingProps,
          r.memoizedState
        ), null;
      case 27:
        return fe(a), r === null && Ue && (u = a.stateNode = jx(
          a.type,
          a.pendingProps,
          ie.current
        ), Lt = a, Nn = !0, p = at, mo(a.type) ? (dp = p, at = jn(u.firstChild)) : at = p), Vt(
          r,
          a,
          a.pendingProps.children,
          s
        ), Pc(r, a), r === null && (a.flags |= 4194304), a.child;
      case 5:
        return r === null && Ue && ((p = u = at) && (u = zN(
          u,
          a.type,
          a.pendingProps,
          Nn
        ), u !== null ? (a.stateNode = u, Lt = a, at = jn(u.firstChild), Nn = !1, p = !0) : p = !1), p || eo(a)), fe(a), p = a.type, g = a.pendingProps, _ = r !== null ? r.memoizedProps : null, u = g.children, sp(p, g) ? u = null : _ !== null && sp(p, _) && (a.flags |= 32), a.memoizedState !== null && (p = ih(
          r,
          a,
          FD,
          null,
          null,
          s
        ), Zs._currentValue = p), Pc(r, a), Vt(r, a, u, s), a.child;
      case 6:
        return r === null && Ue && ((r = s = at) && (s = DN(
          s,
          a.pendingProps,
          Nn
        ), s !== null ? (a.stateNode = s, Lt = a, at = null, r = !0) : r = !1), r || eo(a)), null;
      case 13:
        return Eb(r, a, s);
      case 4:
        return re(
          a,
          a.stateNode.containerInfo
        ), u = a.pendingProps, r === null ? a.child = oa(
          a,
          null,
          u,
          s
        ) : Vt(r, a, u, s), a.child;
      case 11:
        return pb(
          r,
          a,
          a.type,
          a.pendingProps,
          s
        );
      case 7:
        return Vt(
          r,
          a,
          a.pendingProps,
          s
        ), a.child;
      case 8:
        return Vt(
          r,
          a,
          a.pendingProps.children,
          s
        ), a.child;
      case 12:
        return Vt(
          r,
          a,
          a.pendingProps.children,
          s
        ), a.child;
      case 10:
        return u = a.pendingProps, to(a, a.type, u.value), Vt(r, a, u.children, s), a.child;
      case 9:
        return p = a.type._context, u = a.pendingProps.children, ea(a), p = It(p), u = u(p), a.flags |= 1, Vt(r, a, u, s), a.child;
      case 14:
        return mb(
          r,
          a,
          a.type,
          a.pendingProps,
          s
        );
      case 15:
        return gb(
          r,
          a,
          a.type,
          a.pendingProps,
          s
        );
      case 19:
        return Tb(r, a, s);
      case 31:
        return QD(r, a, s);
      case 22:
        return vb(
          r,
          a,
          s,
          a.pendingProps
        );
      case 24:
        return ea(a), u = It(wt), r === null ? (p = Xd(), p === null && (p = et, g = qd(), p.pooledCache = g, g.refCount++, g !== null && (p.pooledCacheLanes |= s), p = g), a.memoizedState = { parent: u, cache: p }, Jd(a), to(a, wt, p)) : ((r.lanes & s) !== 0 && (Qd(r, a), _s(a, null, null, s), Es()), p = r.memoizedState, g = a.memoizedState, p.parent !== u ? (p = { parent: u, cache: u }, a.memoizedState = p, a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = p), to(a, wt, u)) : (u = g.cache, to(a, wt, u), u !== p.cache && Yd(
          a,
          [wt],
          s,
          !0
        ))), Vt(
          r,
          a,
          a.pendingProps.children,
          s
        ), a.child;
      case 29:
        throw a.pendingProps;
    }
    throw Error(o(156, a.tag));
  }
  function Or(r) {
    r.flags |= 4;
  }
  function jh(r, a, s, u, p) {
    if ((a = (r.mode & 32) !== 0) && (a = !1), a) {
      if (r.flags |= 16777216, (p & 335544128) === p)
        if (r.stateNode.complete) r.flags |= 8192;
        else if (Qb()) r.flags |= 8192;
        else
          throw ra = Sc, Kd;
    } else r.flags &= -16777217;
  }
  function Ab(r, a) {
    if (a.type !== "stylesheet" || (a.state.loading & 4) !== 0)
      r.flags &= -16777217;
    else if (r.flags |= 16777216, !$x(a))
      if (Qb()) r.flags |= 8192;
      else
        throw ra = Sc, Kd;
  }
  function Ic(r, a) {
    a !== null && (r.flags |= 4), r.flags & 16384 && (a = r.tag !== 22 ? iy() : 536870912, r.lanes |= a, ii |= a);
  }
  function zs(r, a) {
    if (!Ue)
      switch (r.tailMode) {
        case "hidden":
          a = r.tail;
          for (var s = null; a !== null; )
            a.alternate !== null && (s = a), a = a.sibling;
          s === null ? r.tail = null : s.sibling = null;
          break;
        case "collapsed":
          s = r.tail;
          for (var u = null; s !== null; )
            s.alternate !== null && (u = s), s = s.sibling;
          u === null ? a || r.tail === null ? r.tail = null : r.tail.sibling = null : u.sibling = null;
      }
  }
  function it(r) {
    var a = r.alternate !== null && r.alternate.child === r.child, s = 0, u = 0;
    if (a)
      for (var p = r.child; p !== null; )
        s |= p.lanes | p.childLanes, u |= p.subtreeFlags & 65011712, u |= p.flags & 65011712, p.return = r, p = p.sibling;
    else
      for (p = r.child; p !== null; )
        s |= p.lanes | p.childLanes, u |= p.subtreeFlags, u |= p.flags, p.return = r, p = p.sibling;
    return r.subtreeFlags |= u, r.childLanes = s, a;
  }
  function tN(r, a, s) {
    var u = a.pendingProps;
    switch ($d(a), a.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return it(a), null;
      case 1:
        return it(a), null;
      case 3:
        return s = a.stateNode, u = null, r !== null && (u = r.memoizedState.cache), a.memoizedState.cache !== u && (a.flags |= 2048), Mr(wt), le(), s.pendingContext && (s.context = s.pendingContext, s.pendingContext = null), (r === null || r.child === null) && (Ya(a) ? Or(a) : r === null || r.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024, Zd())), it(a), null;
      case 26:
        var p = a.type, g = a.memoizedState;
        return r === null ? (Or(a), g !== null ? (it(a), Ab(a, g)) : (it(a), jh(
          a,
          p,
          null,
          u,
          s
        ))) : g ? g !== r.memoizedState ? (Or(a), it(a), Ab(a, g)) : (it(a), a.flags &= -16777217) : (r = r.memoizedProps, r !== u && Or(a), it(a), jh(
          a,
          p,
          r,
          u,
          s
        )), null;
      case 27:
        if (me(a), s = ie.current, p = a.type, r !== null && a.stateNode != null)
          r.memoizedProps !== u && Or(a);
        else {
          if (!u) {
            if (a.stateNode === null)
              throw Error(o(166));
            return it(a), null;
          }
          r = X.current, Ya(a) ? i0(a) : (r = jx(p, u, s), a.stateNode = r, Or(a));
        }
        return it(a), null;
      case 5:
        if (me(a), p = a.type, r !== null && a.stateNode != null)
          r.memoizedProps !== u && Or(a);
        else {
          if (!u) {
            if (a.stateNode === null)
              throw Error(o(166));
            return it(a), null;
          }
          if (g = X.current, Ya(a))
            i0(a);
          else {
            var _ = Qc(
              ie.current
            );
            switch (g) {
              case 1:
                g = _.createElementNS(
                  "http://www.w3.org/2000/svg",
                  p
                );
                break;
              case 2:
                g = _.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  p
                );
                break;
              default:
                switch (p) {
                  case "svg":
                    g = _.createElementNS(
                      "http://www.w3.org/2000/svg",
                      p
                    );
                    break;
                  case "math":
                    g = _.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      p
                    );
                    break;
                  case "script":
                    g = _.createElement("div"), g.innerHTML = "<script><\/script>", g = g.removeChild(
                      g.firstChild
                    );
                    break;
                  case "select":
                    g = typeof u.is == "string" ? _.createElement("select", {
                      is: u.is
                    }) : _.createElement("select"), u.multiple ? g.multiple = !0 : u.size && (g.size = u.size);
                    break;
                  default:
                    g = typeof u.is == "string" ? _.createElement(p, { is: u.is }) : _.createElement(p);
                }
            }
            g[Pt] = a, g[en] = u;
            e: for (_ = a.child; _ !== null; ) {
              if (_.tag === 5 || _.tag === 6)
                g.appendChild(_.stateNode);
              else if (_.tag !== 4 && _.tag !== 27 && _.child !== null) {
                _.child.return = _, _ = _.child;
                continue;
              }
              if (_ === a) break e;
              for (; _.sibling === null; ) {
                if (_.return === null || _.return === a)
                  break e;
                _ = _.return;
              }
              _.sibling.return = _.return, _ = _.sibling;
            }
            a.stateNode = g;
            e: switch (Ut(g, p, u), p) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                u = !!u.autoFocus;
                break e;
              case "img":
                u = !0;
                break e;
              default:
                u = !1;
            }
            u && Or(a);
          }
        }
        return it(a), jh(
          a,
          a.type,
          r === null ? null : r.memoizedProps,
          a.pendingProps,
          s
        ), null;
      case 6:
        if (r && a.stateNode != null)
          r.memoizedProps !== u && Or(a);
        else {
          if (typeof u != "string" && a.stateNode === null)
            throw Error(o(166));
          if (r = ie.current, Ya(a)) {
            if (r = a.stateNode, s = a.memoizedProps, u = null, p = Lt, p !== null)
              switch (p.tag) {
                case 27:
                case 5:
                  u = p.memoizedProps;
              }
            r[Pt] = a, r = !!(r.nodeValue === s || u !== null && u.suppressHydrationWarning === !0 || Ex(r.nodeValue, s)), r || eo(a, !0);
          } else
            r = Qc(r).createTextNode(
              u
            ), r[Pt] = a, a.stateNode = r;
        }
        return it(a), null;
      case 31:
        if (s = a.memoizedState, r === null || r.memoizedState !== null) {
          if (u = Ya(a), s !== null) {
            if (r === null) {
              if (!u) throw Error(o(318));
              if (r = a.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(o(557));
              r[Pt] = a;
            } else
              Jo(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
            it(a), r = !1;
          } else
            s = Zd(), r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = s), r = !0;
          if (!r)
            return a.flags & 256 ? (vn(a), a) : (vn(a), null);
          if ((a.flags & 128) !== 0)
            throw Error(o(558));
        }
        return it(a), null;
      case 13:
        if (u = a.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
          if (p = Ya(a), u !== null && u.dehydrated !== null) {
            if (r === null) {
              if (!p) throw Error(o(318));
              if (p = a.memoizedState, p = p !== null ? p.dehydrated : null, !p) throw Error(o(317));
              p[Pt] = a;
            } else
              Jo(), (a.flags & 128) === 0 && (a.memoizedState = null), a.flags |= 4;
            it(a), p = !1;
          } else
            p = Zd(), r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = p), p = !0;
          if (!p)
            return a.flags & 256 ? (vn(a), a) : (vn(a), null);
        }
        return vn(a), (a.flags & 128) !== 0 ? (a.lanes = s, a) : (s = u !== null, r = r !== null && r.memoizedState !== null, s && (u = a.child, p = null, u.alternate !== null && u.alternate.memoizedState !== null && u.alternate.memoizedState.cachePool !== null && (p = u.alternate.memoizedState.cachePool.pool), g = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (g = u.memoizedState.cachePool.pool), g !== p && (u.flags |= 2048)), s !== r && s && (a.child.flags |= 8192), Ic(a, a.updateQueue), it(a), null);
      case 4:
        return le(), r === null && np(a.stateNode.containerInfo), it(a), null;
      case 10:
        return Mr(a.type), it(a), null;
      case 19:
        if (W(bt), u = a.memoizedState, u === null) return it(a), null;
        if (p = (a.flags & 128) !== 0, g = u.rendering, g === null)
          if (p) zs(u, !1);
          else {
            if (gt !== 0 || r !== null && (r.flags & 128) !== 0)
              for (r = a.child; r !== null; ) {
                if (g = Tc(r), g !== null) {
                  for (a.flags |= 128, zs(u, !1), r = g.updateQueue, a.updateQueue = r, Ic(a, r), a.subtreeFlags = 0, r = s, s = a.child; s !== null; )
                    t0(s, r), s = s.sibling;
                  return $(
                    bt,
                    bt.current & 1 | 2
                  ), Ue && Ar(a, u.treeForkCount), a.child;
                }
                r = r.sibling;
              }
            u.tail !== null && fn() > Hc && (a.flags |= 128, p = !0, zs(u, !1), a.lanes = 4194304);
          }
        else {
          if (!p)
            if (r = Tc(g), r !== null) {
              if (a.flags |= 128, p = !0, r = r.updateQueue, a.updateQueue = r, Ic(a, r), zs(u, !0), u.tail === null && u.tailMode === "hidden" && !g.alternate && !Ue)
                return it(a), null;
            } else
              2 * fn() - u.renderingStartTime > Hc && s !== 536870912 && (a.flags |= 128, p = !0, zs(u, !1), a.lanes = 4194304);
          u.isBackwards ? (g.sibling = a.child, a.child = g) : (r = u.last, r !== null ? r.sibling = g : a.child = g, u.last = g);
        }
        return u.tail !== null ? (r = u.tail, u.rendering = r, u.tail = r.sibling, u.renderingStartTime = fn(), r.sibling = null, s = bt.current, $(
          bt,
          p ? s & 1 | 2 : s & 1
        ), Ue && Ar(a, u.treeForkCount), r) : (it(a), null);
      case 22:
      case 23:
        return vn(a), rh(), u = a.memoizedState !== null, r !== null ? r.memoizedState !== null !== u && (a.flags |= 8192) : u && (a.flags |= 8192), u ? (s & 536870912) !== 0 && (a.flags & 128) === 0 && (it(a), a.subtreeFlags & 6 && (a.flags |= 8192)) : it(a), s = a.updateQueue, s !== null && Ic(a, s.retryQueue), s = null, r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (s = r.memoizedState.cachePool.pool), u = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (u = a.memoizedState.cachePool.pool), u !== s && (a.flags |= 2048), r !== null && W(ta), null;
      case 24:
        return s = null, r !== null && (s = r.memoizedState.cache), a.memoizedState.cache !== s && (a.flags |= 2048), Mr(wt), it(a), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(o(156, a.tag));
  }
  function nN(r, a) {
    switch ($d(a), a.tag) {
      case 1:
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 3:
        return Mr(wt), le(), r = a.flags, (r & 65536) !== 0 && (r & 128) === 0 ? (a.flags = r & -65537 | 128, a) : null;
      case 26:
      case 27:
      case 5:
        return me(a), null;
      case 31:
        if (a.memoizedState !== null) {
          if (vn(a), a.alternate === null)
            throw Error(o(340));
          Jo();
        }
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 13:
        if (vn(a), r = a.memoizedState, r !== null && r.dehydrated !== null) {
          if (a.alternate === null)
            throw Error(o(340));
          Jo();
        }
        return r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 19:
        return W(bt), null;
      case 4:
        return le(), null;
      case 10:
        return Mr(a.type), null;
      case 22:
      case 23:
        return vn(a), rh(), r !== null && W(ta), r = a.flags, r & 65536 ? (a.flags = r & -65537 | 128, a) : null;
      case 24:
        return Mr(wt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function Rb(r, a) {
    switch ($d(a), a.tag) {
      case 3:
        Mr(wt), le();
        break;
      case 26:
      case 27:
      case 5:
        me(a);
        break;
      case 4:
        le();
        break;
      case 31:
        a.memoizedState !== null && vn(a);
        break;
      case 13:
        vn(a);
        break;
      case 19:
        W(bt);
        break;
      case 10:
        Mr(a.type);
        break;
      case 22:
      case 23:
        vn(a), rh(), r !== null && W(ta);
        break;
      case 24:
        Mr(wt);
    }
  }
  function Ds(r, a) {
    try {
      var s = a.updateQueue, u = s !== null ? s.lastEffect : null;
      if (u !== null) {
        var p = u.next;
        s = p;
        do {
          if ((s.tag & r) === r) {
            u = void 0;
            var g = s.create, _ = s.inst;
            u = g(), _.destroy = u;
          }
          s = s.next;
        } while (s !== p);
      }
    } catch (z) {
      qe(a, a.return, z);
    }
  }
  function so(r, a, s) {
    try {
      var u = a.updateQueue, p = u !== null ? u.lastEffect : null;
      if (p !== null) {
        var g = p.next;
        u = g;
        do {
          if ((u.tag & r) === r) {
            var _ = u.inst, z = _.destroy;
            if (z !== void 0) {
              _.destroy = void 0, p = a;
              var L = s, F = z;
              try {
                F();
              } catch (Q) {
                qe(
                  p,
                  L,
                  Q
                );
              }
            }
          }
          u = u.next;
        } while (u !== g);
      }
    } catch (Q) {
      qe(a, a.return, Q);
    }
  }
  function Mb(r) {
    var a = r.updateQueue;
    if (a !== null) {
      var s = r.stateNode;
      try {
        b0(a, s);
      } catch (u) {
        qe(r, r.return, u);
      }
    }
  }
  function zb(r, a, s) {
    s.props = ia(
      r.type,
      r.memoizedProps
    ), s.state = r.memoizedState;
    try {
      s.componentWillUnmount();
    } catch (u) {
      qe(r, a, u);
    }
  }
  function Ns(r, a) {
    try {
      var s = r.ref;
      if (s !== null) {
        switch (r.tag) {
          case 26:
          case 27:
          case 5:
            var u = r.stateNode;
            break;
          case 30:
            u = r.stateNode;
            break;
          default:
            u = r.stateNode;
        }
        typeof s == "function" ? r.refCleanup = s(u) : s.current = u;
      }
    } catch (p) {
      qe(r, a, p);
    }
  }
  function ar(r, a) {
    var s = r.ref, u = r.refCleanup;
    if (s !== null)
      if (typeof u == "function")
        try {
          u();
        } catch (p) {
          qe(r, a, p);
        } finally {
          r.refCleanup = null, r = r.alternate, r != null && (r.refCleanup = null);
        }
      else if (typeof s == "function")
        try {
          s(null);
        } catch (p) {
          qe(r, a, p);
        }
      else s.current = null;
  }
  function Db(r) {
    var a = r.type, s = r.memoizedProps, u = r.stateNode;
    try {
      e: switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          s.autoFocus && u.focus();
          break e;
        case "img":
          s.src ? u.src = s.src : s.srcSet && (u.srcset = s.srcSet);
      }
    } catch (p) {
      qe(r, r.return, p);
    }
  }
  function kh(r, a, s) {
    try {
      var u = r.stateNode;
      _N(u, r.type, s, a), u[en] = a;
    } catch (p) {
      qe(r, r.return, p);
    }
  }
  function Nb(r) {
    return r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 && mo(r.type) || r.tag === 4;
  }
  function Ph(r) {
    e: for (; ; ) {
      for (; r.sibling === null; ) {
        if (r.return === null || Nb(r.return)) return null;
        r = r.return;
      }
      for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
        if (r.tag === 27 && mo(r.type) || r.flags & 2 || r.child === null || r.tag === 4) continue e;
        r.child.return = r, r = r.child;
      }
      if (!(r.flags & 2)) return r.stateNode;
    }
  }
  function Lh(r, a, s) {
    var u = r.tag;
    if (u === 5 || u === 6)
      r = r.stateNode, a ? (s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s).insertBefore(r, a) : (a = s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, a.appendChild(r), s = s._reactRootContainer, s != null || a.onclick !== null || (a.onclick = _r));
    else if (u !== 4 && (u === 27 && mo(r.type) && (s = r.stateNode, a = null), r = r.child, r !== null))
      for (Lh(r, a, s), r = r.sibling; r !== null; )
        Lh(r, a, s), r = r.sibling;
  }
  function Vc(r, a, s) {
    var u = r.tag;
    if (u === 5 || u === 6)
      r = r.stateNode, a ? s.insertBefore(r, a) : s.appendChild(r);
    else if (u !== 4 && (u === 27 && mo(r.type) && (s = r.stateNode), r = r.child, r !== null))
      for (Vc(r, a, s), r = r.sibling; r !== null; )
        Vc(r, a, s), r = r.sibling;
  }
  function Ob(r) {
    var a = r.stateNode, s = r.memoizedProps;
    try {
      for (var u = r.type, p = a.attributes; p.length; )
        a.removeAttributeNode(p[0]);
      Ut(a, u, s), a[Pt] = r, a[en] = s;
    } catch (g) {
      qe(r, r.return, g);
    }
  }
  var jr = !1, Tt = !1, Ih = !1, jb = typeof WeakSet == "function" ? WeakSet : Set, jt = null;
  function rN(r, a) {
    if (r = r.containerInfo, ap = iu, r = Gy(r), Dd(r)) {
      if ("selectionStart" in r)
        var s = {
          start: r.selectionStart,
          end: r.selectionEnd
        };
      else
        e: {
          s = (s = r.ownerDocument) && s.defaultView || window;
          var u = s.getSelection && s.getSelection();
          if (u && u.rangeCount !== 0) {
            s = u.anchorNode;
            var p = u.anchorOffset, g = u.focusNode;
            u = u.focusOffset;
            try {
              s.nodeType, g.nodeType;
            } catch {
              s = null;
              break e;
            }
            var _ = 0, z = -1, L = -1, F = 0, Q = 0, ae = r, q = null;
            t: for (; ; ) {
              for (var K; ae !== s || p !== 0 && ae.nodeType !== 3 || (z = _ + p), ae !== g || u !== 0 && ae.nodeType !== 3 || (L = _ + u), ae.nodeType === 3 && (_ += ae.nodeValue.length), (K = ae.firstChild) !== null; )
                q = ae, ae = K;
              for (; ; ) {
                if (ae === r) break t;
                if (q === s && ++F === p && (z = _), q === g && ++Q === u && (L = _), (K = ae.nextSibling) !== null) break;
                ae = q, q = ae.parentNode;
              }
              ae = K;
            }
            s = z === -1 || L === -1 ? null : { start: z, end: L };
          } else s = null;
        }
      s = s || { start: 0, end: 0 };
    } else s = null;
    for (ip = { focusedElem: r, selectionRange: s }, iu = !1, jt = a; jt !== null; )
      if (a = jt, r = a.child, (a.subtreeFlags & 1028) !== 0 && r !== null)
        r.return = a, jt = r;
      else
        for (; jt !== null; ) {
          switch (a = jt, g = a.alternate, r = a.flags, a.tag) {
            case 0:
              if ((r & 4) !== 0 && (r = a.updateQueue, r = r !== null ? r.events : null, r !== null))
                for (s = 0; s < r.length; s++)
                  p = r[s], p.ref.impl = p.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((r & 1024) !== 0 && g !== null) {
                r = void 0, s = a, p = g.memoizedProps, g = g.memoizedState, u = s.stateNode;
                try {
                  var ve = ia(
                    s.type,
                    p
                  );
                  r = u.getSnapshotBeforeUpdate(
                    ve,
                    g
                  ), u.__reactInternalSnapshotBeforeUpdate = r;
                } catch (_e) {
                  qe(
                    s,
                    s.return,
                    _e
                  );
                }
              }
              break;
            case 3:
              if ((r & 1024) !== 0) {
                if (r = a.stateNode.containerInfo, s = r.nodeType, s === 9)
                  cp(r);
                else if (s === 1)
                  switch (r.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      cp(r);
                      break;
                    default:
                      r.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((r & 1024) !== 0) throw Error(o(163));
          }
          if (r = a.sibling, r !== null) {
            r.return = a.return, jt = r;
            break;
          }
          jt = a.return;
        }
  }
  function kb(r, a, s) {
    var u = s.flags;
    switch (s.tag) {
      case 0:
      case 11:
      case 15:
        Pr(r, s), u & 4 && Ds(5, s);
        break;
      case 1:
        if (Pr(r, s), u & 4)
          if (r = s.stateNode, a === null)
            try {
              r.componentDidMount();
            } catch (_) {
              qe(s, s.return, _);
            }
          else {
            var p = ia(
              s.type,
              a.memoizedProps
            );
            a = a.memoizedState;
            try {
              r.componentDidUpdate(
                p,
                a,
                r.__reactInternalSnapshotBeforeUpdate
              );
            } catch (_) {
              qe(
                s,
                s.return,
                _
              );
            }
          }
        u & 64 && Mb(s), u & 512 && Ns(s, s.return);
        break;
      case 3:
        if (Pr(r, s), u & 64 && (r = s.updateQueue, r !== null)) {
          if (a = null, s.child !== null)
            switch (s.child.tag) {
              case 27:
              case 5:
                a = s.child.stateNode;
                break;
              case 1:
                a = s.child.stateNode;
            }
          try {
            b0(r, a);
          } catch (_) {
            qe(s, s.return, _);
          }
        }
        break;
      case 27:
        a === null && u & 4 && Ob(s);
      case 26:
      case 5:
        Pr(r, s), a === null && u & 4 && Db(s), u & 512 && Ns(s, s.return);
        break;
      case 12:
        Pr(r, s);
        break;
      case 31:
        Pr(r, s), u & 4 && Ib(r, s);
        break;
      case 13:
        Pr(r, s), u & 4 && Vb(r, s), u & 64 && (r = s.memoizedState, r !== null && (r = r.dehydrated, r !== null && (s = dN.bind(
          null,
          s
        ), NN(r, s))));
        break;
      case 22:
        if (u = s.memoizedState !== null || jr, !u) {
          a = a !== null && a.memoizedState !== null || Tt, p = jr;
          var g = Tt;
          jr = u, (Tt = a) && !g ? Lr(
            r,
            s,
            (s.subtreeFlags & 8772) !== 0
          ) : Pr(r, s), jr = p, Tt = g;
        }
        break;
      case 30:
        break;
      default:
        Pr(r, s);
    }
  }
  function Pb(r) {
    var a = r.alternate;
    a !== null && (r.alternate = null, Pb(a)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (a = r.stateNode, a !== null && pd(a)), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
  }
  var ft = null, nn = !1;
  function kr(r, a, s) {
    for (s = s.child; s !== null; )
      Lb(r, a, s), s = s.sibling;
  }
  function Lb(r, a, s) {
    if (dn && typeof dn.onCommitFiberUnmount == "function")
      try {
        dn.onCommitFiberUnmount(ns, s);
      } catch {
      }
    switch (s.tag) {
      case 26:
        Tt || ar(s, a), kr(
          r,
          a,
          s
        ), s.memoizedState ? s.memoizedState.count-- : s.stateNode && (s = s.stateNode, s.parentNode.removeChild(s));
        break;
      case 27:
        Tt || ar(s, a);
        var u = ft, p = nn;
        mo(s.type) && (ft = s.stateNode, nn = !1), kr(
          r,
          a,
          s
        ), Bs(s.stateNode), ft = u, nn = p;
        break;
      case 5:
        Tt || ar(s, a);
      case 6:
        if (u = ft, p = nn, ft = null, kr(
          r,
          a,
          s
        ), ft = u, nn = p, ft !== null)
          if (nn)
            try {
              (ft.nodeType === 9 ? ft.body : ft.nodeName === "HTML" ? ft.ownerDocument.body : ft).removeChild(s.stateNode);
            } catch (g) {
              qe(
                s,
                a,
                g
              );
            }
          else
            try {
              ft.removeChild(s.stateNode);
            } catch (g) {
              qe(
                s,
                a,
                g
              );
            }
        break;
      case 18:
        ft !== null && (nn ? (r = ft, Mx(
          r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r,
          s.stateNode
        ), pi(r)) : Mx(ft, s.stateNode));
        break;
      case 4:
        u = ft, p = nn, ft = s.stateNode.containerInfo, nn = !0, kr(
          r,
          a,
          s
        ), ft = u, nn = p;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        so(2, s, a), Tt || so(4, s, a), kr(
          r,
          a,
          s
        );
        break;
      case 1:
        Tt || (ar(s, a), u = s.stateNode, typeof u.componentWillUnmount == "function" && zb(
          s,
          a,
          u
        )), kr(
          r,
          a,
          s
        );
        break;
      case 21:
        kr(
          r,
          a,
          s
        );
        break;
      case 22:
        Tt = (u = Tt) || s.memoizedState !== null, kr(
          r,
          a,
          s
        ), Tt = u;
        break;
      default:
        kr(
          r,
          a,
          s
        );
    }
  }
  function Ib(r, a) {
    if (a.memoizedState === null && (r = a.alternate, r !== null && (r = r.memoizedState, r !== null))) {
      r = r.dehydrated;
      try {
        pi(r);
      } catch (s) {
        qe(a, a.return, s);
      }
    }
  }
  function Vb(r, a) {
    if (a.memoizedState === null && (r = a.alternate, r !== null && (r = r.memoizedState, r !== null && (r = r.dehydrated, r !== null))))
      try {
        pi(r);
      } catch (s) {
        qe(a, a.return, s);
      }
  }
  function oN(r) {
    switch (r.tag) {
      case 31:
      case 13:
      case 19:
        var a = r.stateNode;
        return a === null && (a = r.stateNode = new jb()), a;
      case 22:
        return r = r.stateNode, a = r._retryCache, a === null && (a = r._retryCache = new jb()), a;
      default:
        throw Error(o(435, r.tag));
    }
  }
  function Uc(r, a) {
    var s = oN(r);
    a.forEach(function(u) {
      if (!s.has(u)) {
        s.add(u);
        var p = hN.bind(null, r, u);
        u.then(p, p);
      }
    });
  }
  function rn(r, a) {
    var s = a.deletions;
    if (s !== null)
      for (var u = 0; u < s.length; u++) {
        var p = s[u], g = r, _ = a, z = _;
        e: for (; z !== null; ) {
          switch (z.tag) {
            case 27:
              if (mo(z.type)) {
                ft = z.stateNode, nn = !1;
                break e;
              }
              break;
            case 5:
              ft = z.stateNode, nn = !1;
              break e;
            case 3:
            case 4:
              ft = z.stateNode.containerInfo, nn = !0;
              break e;
          }
          z = z.return;
        }
        if (ft === null) throw Error(o(160));
        Lb(g, _, p), ft = null, nn = !1, g = p.alternate, g !== null && (g.return = null), p.return = null;
      }
    if (a.subtreeFlags & 13886)
      for (a = a.child; a !== null; )
        Ub(a, r), a = a.sibling;
  }
  var Fn = null;
  function Ub(r, a) {
    var s = r.alternate, u = r.flags;
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        rn(a, r), on(r), u & 4 && (so(3, r, r.return), Ds(3, r), so(5, r, r.return));
        break;
      case 1:
        rn(a, r), on(r), u & 512 && (Tt || s === null || ar(s, s.return)), u & 64 && jr && (r = r.updateQueue, r !== null && (u = r.callbacks, u !== null && (s = r.shared.hiddenCallbacks, r.shared.hiddenCallbacks = s === null ? u : s.concat(u))));
        break;
      case 26:
        var p = Fn;
        if (rn(a, r), on(r), u & 512 && (Tt || s === null || ar(s, s.return)), u & 4) {
          var g = s !== null ? s.memoizedState : null;
          if (u = r.memoizedState, s === null)
            if (u === null)
              if (r.stateNode === null) {
                e: {
                  u = r.type, s = r.memoizedProps, p = p.ownerDocument || p;
                  t: switch (u) {
                    case "title":
                      g = p.getElementsByTagName("title")[0], (!g || g[as] || g[Pt] || g.namespaceURI === "http://www.w3.org/2000/svg" || g.hasAttribute("itemprop")) && (g = p.createElement(u), p.head.insertBefore(
                        g,
                        p.querySelector("head > title")
                      )), Ut(g, u, s), g[Pt] = r, Ot(g), u = g;
                      break e;
                    case "link":
                      var _ = Ux(
                        "link",
                        "href",
                        p
                      ).get(u + (s.href || ""));
                      if (_) {
                        for (var z = 0; z < _.length; z++)
                          if (g = _[z], g.getAttribute("href") === (s.href == null || s.href === "" ? null : s.href) && g.getAttribute("rel") === (s.rel == null ? null : s.rel) && g.getAttribute("title") === (s.title == null ? null : s.title) && g.getAttribute("crossorigin") === (s.crossOrigin == null ? null : s.crossOrigin)) {
                            _.splice(z, 1);
                            break t;
                          }
                      }
                      g = p.createElement(u), Ut(g, u, s), p.head.appendChild(g);
                      break;
                    case "meta":
                      if (_ = Ux(
                        "meta",
                        "content",
                        p
                      ).get(u + (s.content || ""))) {
                        for (z = 0; z < _.length; z++)
                          if (g = _[z], g.getAttribute("content") === (s.content == null ? null : "" + s.content) && g.getAttribute("name") === (s.name == null ? null : s.name) && g.getAttribute("property") === (s.property == null ? null : s.property) && g.getAttribute("http-equiv") === (s.httpEquiv == null ? null : s.httpEquiv) && g.getAttribute("charset") === (s.charSet == null ? null : s.charSet)) {
                            _.splice(z, 1);
                            break t;
                          }
                      }
                      g = p.createElement(u), Ut(g, u, s), p.head.appendChild(g);
                      break;
                    default:
                      throw Error(o(468, u));
                  }
                  g[Pt] = r, Ot(g), u = g;
                }
                r.stateNode = u;
              } else
                Bx(
                  p,
                  r.type,
                  r.stateNode
                );
            else
              r.stateNode = Vx(
                p,
                u,
                r.memoizedProps
              );
          else
            g !== u ? (g === null ? s.stateNode !== null && (s = s.stateNode, s.parentNode.removeChild(s)) : g.count--, u === null ? Bx(
              p,
              r.type,
              r.stateNode
            ) : Vx(
              p,
              u,
              r.memoizedProps
            )) : u === null && r.stateNode !== null && kh(
              r,
              r.memoizedProps,
              s.memoizedProps
            );
        }
        break;
      case 27:
        rn(a, r), on(r), u & 512 && (Tt || s === null || ar(s, s.return)), s !== null && u & 4 && kh(
          r,
          r.memoizedProps,
          s.memoizedProps
        );
        break;
      case 5:
        if (rn(a, r), on(r), u & 512 && (Tt || s === null || ar(s, s.return)), r.flags & 32) {
          p = r.stateNode;
          try {
            La(p, "");
          } catch (ve) {
            qe(r, r.return, ve);
          }
        }
        u & 4 && r.stateNode != null && (p = r.memoizedProps, kh(
          r,
          p,
          s !== null ? s.memoizedProps : p
        )), u & 1024 && (Ih = !0);
        break;
      case 6:
        if (rn(a, r), on(r), u & 4) {
          if (r.stateNode === null)
            throw Error(o(162));
          u = r.memoizedProps, s = r.stateNode;
          try {
            s.nodeValue = u;
          } catch (ve) {
            qe(r, r.return, ve);
          }
        }
        break;
      case 3:
        if (nu = null, p = Fn, Fn = eu(a.containerInfo), rn(a, r), Fn = p, on(r), u & 4 && s !== null && s.memoizedState.isDehydrated)
          try {
            pi(a.containerInfo);
          } catch (ve) {
            qe(r, r.return, ve);
          }
        Ih && (Ih = !1, Bb(r));
        break;
      case 4:
        u = Fn, Fn = eu(
          r.stateNode.containerInfo
        ), rn(a, r), on(r), Fn = u;
        break;
      case 12:
        rn(a, r), on(r);
        break;
      case 31:
        rn(a, r), on(r), u & 4 && (u = r.updateQueue, u !== null && (r.updateQueue = null, Uc(r, u)));
        break;
      case 13:
        rn(a, r), on(r), r.child.flags & 8192 && r.memoizedState !== null != (s !== null && s.memoizedState !== null) && ($c = fn()), u & 4 && (u = r.updateQueue, u !== null && (r.updateQueue = null, Uc(r, u)));
        break;
      case 22:
        p = r.memoizedState !== null;
        var L = s !== null && s.memoizedState !== null, F = jr, Q = Tt;
        if (jr = F || p, Tt = Q || L, rn(a, r), Tt = Q, jr = F, on(r), u & 8192)
          e: for (a = r.stateNode, a._visibility = p ? a._visibility & -2 : a._visibility | 1, p && (s === null || L || jr || Tt || sa(r)), s = null, a = r; ; ) {
            if (a.tag === 5 || a.tag === 26) {
              if (s === null) {
                L = s = a;
                try {
                  if (g = L.stateNode, p)
                    _ = g.style, typeof _.setProperty == "function" ? _.setProperty("display", "none", "important") : _.display = "none";
                  else {
                    z = L.stateNode;
                    var ae = L.memoizedProps.style, q = ae != null && ae.hasOwnProperty("display") ? ae.display : null;
                    z.style.display = q == null || typeof q == "boolean" ? "" : ("" + q).trim();
                  }
                } catch (ve) {
                  qe(L, L.return, ve);
                }
              }
            } else if (a.tag === 6) {
              if (s === null) {
                L = a;
                try {
                  L.stateNode.nodeValue = p ? "" : L.memoizedProps;
                } catch (ve) {
                  qe(L, L.return, ve);
                }
              }
            } else if (a.tag === 18) {
              if (s === null) {
                L = a;
                try {
                  var K = L.stateNode;
                  p ? zx(K, !0) : zx(L.stateNode, !1);
                } catch (ve) {
                  qe(L, L.return, ve);
                }
              }
            } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === r) && a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === r) break e;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === r) break e;
              s === a && (s = null), a = a.return;
            }
            s === a && (s = null), a.sibling.return = a.return, a = a.sibling;
          }
        u & 4 && (u = r.updateQueue, u !== null && (s = u.retryQueue, s !== null && (u.retryQueue = null, Uc(r, s))));
        break;
      case 19:
        rn(a, r), on(r), u & 4 && (u = r.updateQueue, u !== null && (r.updateQueue = null, Uc(r, u)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        rn(a, r), on(r);
    }
  }
  function on(r) {
    var a = r.flags;
    if (a & 2) {
      try {
        for (var s, u = r.return; u !== null; ) {
          if (Nb(u)) {
            s = u;
            break;
          }
          u = u.return;
        }
        if (s == null) throw Error(o(160));
        switch (s.tag) {
          case 27:
            var p = s.stateNode, g = Ph(r);
            Vc(r, g, p);
            break;
          case 5:
            var _ = s.stateNode;
            s.flags & 32 && (La(_, ""), s.flags &= -33);
            var z = Ph(r);
            Vc(r, z, _);
            break;
          case 3:
          case 4:
            var L = s.stateNode.containerInfo, F = Ph(r);
            Lh(
              r,
              F,
              L
            );
            break;
          default:
            throw Error(o(161));
        }
      } catch (Q) {
        qe(r, r.return, Q);
      }
      r.flags &= -3;
    }
    a & 4096 && (r.flags &= -4097);
  }
  function Bb(r) {
    if (r.subtreeFlags & 1024)
      for (r = r.child; r !== null; ) {
        var a = r;
        Bb(a), a.tag === 5 && a.flags & 1024 && a.stateNode.reset(), r = r.sibling;
      }
  }
  function Pr(r, a) {
    if (a.subtreeFlags & 8772)
      for (a = a.child; a !== null; )
        kb(r, a.alternate, a), a = a.sibling;
  }
  function sa(r) {
    for (r = r.child; r !== null; ) {
      var a = r;
      switch (a.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          so(4, a, a.return), sa(a);
          break;
        case 1:
          ar(a, a.return);
          var s = a.stateNode;
          typeof s.componentWillUnmount == "function" && zb(
            a,
            a.return,
            s
          ), sa(a);
          break;
        case 27:
          Bs(a.stateNode);
        case 26:
        case 5:
          ar(a, a.return), sa(a);
          break;
        case 22:
          a.memoizedState === null && sa(a);
          break;
        case 30:
          sa(a);
          break;
        default:
          sa(a);
      }
      r = r.sibling;
    }
  }
  function Lr(r, a, s) {
    for (s = s && (a.subtreeFlags & 8772) !== 0, a = a.child; a !== null; ) {
      var u = a.alternate, p = r, g = a, _ = g.flags;
      switch (g.tag) {
        case 0:
        case 11:
        case 15:
          Lr(
            p,
            g,
            s
          ), Ds(4, g);
          break;
        case 1:
          if (Lr(
            p,
            g,
            s
          ), u = g, p = u.stateNode, typeof p.componentDidMount == "function")
            try {
              p.componentDidMount();
            } catch (F) {
              qe(u, u.return, F);
            }
          if (u = g, p = u.updateQueue, p !== null) {
            var z = u.stateNode;
            try {
              var L = p.shared.hiddenCallbacks;
              if (L !== null)
                for (p.shared.hiddenCallbacks = null, p = 0; p < L.length; p++)
                  y0(L[p], z);
            } catch (F) {
              qe(u, u.return, F);
            }
          }
          s && _ & 64 && Mb(g), Ns(g, g.return);
          break;
        case 27:
          Ob(g);
        case 26:
        case 5:
          Lr(
            p,
            g,
            s
          ), s && u === null && _ & 4 && Db(g), Ns(g, g.return);
          break;
        case 12:
          Lr(
            p,
            g,
            s
          );
          break;
        case 31:
          Lr(
            p,
            g,
            s
          ), s && _ & 4 && Ib(p, g);
          break;
        case 13:
          Lr(
            p,
            g,
            s
          ), s && _ & 4 && Vb(p, g);
          break;
        case 22:
          g.memoizedState === null && Lr(
            p,
            g,
            s
          ), Ns(g, g.return);
          break;
        case 30:
          break;
        default:
          Lr(
            p,
            g,
            s
          );
      }
      a = a.sibling;
    }
  }
  function Vh(r, a) {
    var s = null;
    r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (s = r.memoizedState.cachePool.pool), r = null, a.memoizedState !== null && a.memoizedState.cachePool !== null && (r = a.memoizedState.cachePool.pool), r !== s && (r != null && r.refCount++, s != null && ys(s));
  }
  function Uh(r, a) {
    r = null, a.alternate !== null && (r = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== r && (a.refCount++, r != null && ys(r));
  }
  function Gn(r, a, s, u) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; )
        $b(
          r,
          a,
          s,
          u
        ), a = a.sibling;
  }
  function $b(r, a, s, u) {
    var p = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 15:
        Gn(
          r,
          a,
          s,
          u
        ), p & 2048 && Ds(9, a);
        break;
      case 1:
        Gn(
          r,
          a,
          s,
          u
        );
        break;
      case 3:
        Gn(
          r,
          a,
          s,
          u
        ), p & 2048 && (r = null, a.alternate !== null && (r = a.alternate.memoizedState.cache), a = a.memoizedState.cache, a !== r && (a.refCount++, r != null && ys(r)));
        break;
      case 12:
        if (p & 2048) {
          Gn(
            r,
            a,
            s,
            u
          ), r = a.stateNode;
          try {
            var g = a.memoizedProps, _ = g.id, z = g.onPostCommit;
            typeof z == "function" && z(
              _,
              a.alternate === null ? "mount" : "update",
              r.passiveEffectDuration,
              -0
            );
          } catch (L) {
            qe(a, a.return, L);
          }
        } else
          Gn(
            r,
            a,
            s,
            u
          );
        break;
      case 31:
        Gn(
          r,
          a,
          s,
          u
        );
        break;
      case 13:
        Gn(
          r,
          a,
          s,
          u
        );
        break;
      case 23:
        break;
      case 22:
        g = a.stateNode, _ = a.alternate, a.memoizedState !== null ? g._visibility & 2 ? Gn(
          r,
          a,
          s,
          u
        ) : Os(r, a) : g._visibility & 2 ? Gn(
          r,
          a,
          s,
          u
        ) : (g._visibility |= 2, ri(
          r,
          a,
          s,
          u,
          (a.subtreeFlags & 10256) !== 0 || !1
        )), p & 2048 && Vh(_, a);
        break;
      case 24:
        Gn(
          r,
          a,
          s,
          u
        ), p & 2048 && Uh(a.alternate, a);
        break;
      default:
        Gn(
          r,
          a,
          s,
          u
        );
    }
  }
  function ri(r, a, s, u, p) {
    for (p = p && ((a.subtreeFlags & 10256) !== 0 || !1), a = a.child; a !== null; ) {
      var g = r, _ = a, z = s, L = u, F = _.flags;
      switch (_.tag) {
        case 0:
        case 11:
        case 15:
          ri(
            g,
            _,
            z,
            L,
            p
          ), Ds(8, _);
          break;
        case 23:
          break;
        case 22:
          var Q = _.stateNode;
          _.memoizedState !== null ? Q._visibility & 2 ? ri(
            g,
            _,
            z,
            L,
            p
          ) : Os(
            g,
            _
          ) : (Q._visibility |= 2, ri(
            g,
            _,
            z,
            L,
            p
          )), p && F & 2048 && Vh(
            _.alternate,
            _
          );
          break;
        case 24:
          ri(
            g,
            _,
            z,
            L,
            p
          ), p && F & 2048 && Uh(_.alternate, _);
          break;
        default:
          ri(
            g,
            _,
            z,
            L,
            p
          );
      }
      a = a.sibling;
    }
  }
  function Os(r, a) {
    if (a.subtreeFlags & 10256)
      for (a = a.child; a !== null; ) {
        var s = r, u = a, p = u.flags;
        switch (u.tag) {
          case 22:
            Os(s, u), p & 2048 && Vh(
              u.alternate,
              u
            );
            break;
          case 24:
            Os(s, u), p & 2048 && Uh(u.alternate, u);
            break;
          default:
            Os(s, u);
        }
        a = a.sibling;
      }
  }
  var js = 8192;
  function oi(r, a, s) {
    if (r.subtreeFlags & js)
      for (r = r.child; r !== null; )
        Hb(
          r,
          a,
          s
        ), r = r.sibling;
  }
  function Hb(r, a, s) {
    switch (r.tag) {
      case 26:
        oi(
          r,
          a,
          s
        ), r.flags & js && r.memoizedState !== null && ZN(
          s,
          Fn,
          r.memoizedState,
          r.memoizedProps
        );
        break;
      case 5:
        oi(
          r,
          a,
          s
        );
        break;
      case 3:
      case 4:
        var u = Fn;
        Fn = eu(r.stateNode.containerInfo), oi(
          r,
          a,
          s
        ), Fn = u;
        break;
      case 22:
        r.memoizedState === null && (u = r.alternate, u !== null && u.memoizedState !== null ? (u = js, js = 16777216, oi(
          r,
          a,
          s
        ), js = u) : oi(
          r,
          a,
          s
        ));
        break;
      default:
        oi(
          r,
          a,
          s
        );
    }
  }
  function Zb(r) {
    var a = r.alternate;
    if (a !== null && (r = a.child, r !== null)) {
      a.child = null;
      do
        a = r.sibling, r.sibling = null, r = a;
      while (r !== null);
    }
  }
  function ks(r) {
    var a = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var s = 0; s < a.length; s++) {
          var u = a[s];
          jt = u, Gb(
            u,
            r
          );
        }
      Zb(r);
    }
    if (r.subtreeFlags & 10256)
      for (r = r.child; r !== null; )
        Fb(r), r = r.sibling;
  }
  function Fb(r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
        ks(r), r.flags & 2048 && so(9, r, r.return);
        break;
      case 3:
        ks(r);
        break;
      case 12:
        ks(r);
        break;
      case 22:
        var a = r.stateNode;
        r.memoizedState !== null && a._visibility & 2 && (r.return === null || r.return.tag !== 13) ? (a._visibility &= -3, Bc(r)) : ks(r);
        break;
      default:
        ks(r);
    }
  }
  function Bc(r) {
    var a = r.deletions;
    if ((r.flags & 16) !== 0) {
      if (a !== null)
        for (var s = 0; s < a.length; s++) {
          var u = a[s];
          jt = u, Gb(
            u,
            r
          );
        }
      Zb(r);
    }
    for (r = r.child; r !== null; ) {
      switch (a = r, a.tag) {
        case 0:
        case 11:
        case 15:
          so(8, a, a.return), Bc(a);
          break;
        case 22:
          s = a.stateNode, s._visibility & 2 && (s._visibility &= -3, Bc(a));
          break;
        default:
          Bc(a);
      }
      r = r.sibling;
    }
  }
  function Gb(r, a) {
    for (; jt !== null; ) {
      var s = jt;
      switch (s.tag) {
        case 0:
        case 11:
        case 15:
          so(8, s, a);
          break;
        case 23:
        case 22:
          if (s.memoizedState !== null && s.memoizedState.cachePool !== null) {
            var u = s.memoizedState.cachePool.pool;
            u != null && u.refCount++;
          }
          break;
        case 24:
          ys(s.memoizedState.cache);
      }
      if (u = s.child, u !== null) u.return = s, jt = u;
      else
        e: for (s = r; jt !== null; ) {
          u = jt;
          var p = u.sibling, g = u.return;
          if (Pb(u), u === s) {
            jt = null;
            break e;
          }
          if (p !== null) {
            p.return = g, jt = p;
            break e;
          }
          jt = g;
        }
    }
  }
  var aN = {
    getCacheForType: function(r) {
      var a = It(wt), s = a.data.get(r);
      return s === void 0 && (s = r(), a.data.set(r, s)), s;
    },
    cacheSignal: function() {
      return It(wt).controller.signal;
    }
  }, iN = typeof WeakMap == "function" ? WeakMap : Map, Fe = 0, et = null, ke = null, Ie = 0, Ye = 0, yn = null, lo = !1, ai = !1, Bh = !1, Ir = 0, gt = 0, co = 0, la = 0, $h = 0, bn = 0, ii = 0, Ps = null, an = null, Hh = !1, $c = 0, Yb = 0, Hc = 1 / 0, Zc = null, uo = null, Rt = 0, fo = null, si = null, Vr = 0, Zh = 0, Fh = null, qb = null, Ls = 0, Gh = null;
  function xn() {
    return (Fe & 2) !== 0 && Ie !== 0 ? Ie & -Ie : I.T !== null ? Jh() : uy();
  }
  function Wb() {
    if (bn === 0)
      if ((Ie & 536870912) === 0 || Ue) {
        var r = Jl;
        Jl <<= 1, (Jl & 3932160) === 0 && (Jl = 262144), bn = r;
      } else bn = 536870912;
    return r = gn.current, r !== null && (r.flags |= 32), bn;
  }
  function sn(r, a, s) {
    (r === et && (Ye === 2 || Ye === 9) || r.cancelPendingCommit !== null) && (li(r, 0), ho(
      r,
      Ie,
      bn,
      !1
    )), os(r, s), ((Fe & 2) === 0 || r !== et) && (r === et && ((Fe & 2) === 0 && (la |= s), gt === 4 && ho(
      r,
      Ie,
      bn,
      !1
    )), ir(r));
  }
  function Xb(r, a, s) {
    if ((Fe & 6) !== 0) throw Error(o(327));
    var u = !s && (a & 127) === 0 && (a & r.expiredLanes) === 0 || rs(r, a), p = u ? cN(r, a) : qh(r, a, !0), g = u;
    do {
      if (p === 0) {
        ai && !u && ho(r, a, 0, !1);
        break;
      } else {
        if (s = r.current.alternate, g && !sN(s)) {
          p = qh(r, a, !1), g = !1;
          continue;
        }
        if (p === 2) {
          if (g = a, r.errorRecoveryDisabledLanes & g)
            var _ = 0;
          else
            _ = r.pendingLanes & -536870913, _ = _ !== 0 ? _ : _ & 536870912 ? 536870912 : 0;
          if (_ !== 0) {
            a = _;
            e: {
              var z = r;
              p = Ps;
              var L = z.current.memoizedState.isDehydrated;
              if (L && (li(z, _).flags |= 256), _ = qh(
                z,
                _,
                !1
              ), _ !== 2) {
                if (Bh && !L) {
                  z.errorRecoveryDisabledLanes |= g, la |= g, p = 4;
                  break e;
                }
                g = an, an = p, g !== null && (an === null ? an = g : an.push.apply(
                  an,
                  g
                ));
              }
              p = _;
            }
            if (g = !1, p !== 2) continue;
          }
        }
        if (p === 1) {
          li(r, 0), ho(r, a, 0, !0);
          break;
        }
        e: {
          switch (u = r, g = p, g) {
            case 0:
            case 1:
              throw Error(o(345));
            case 4:
              if ((a & 4194048) !== a) break;
            case 6:
              ho(
                u,
                a,
                bn,
                !lo
              );
              break e;
            case 2:
              an = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(o(329));
          }
          if ((a & 62914560) === a && (p = $c + 300 - fn(), 10 < p)) {
            if (ho(
              u,
              a,
              bn,
              !lo
            ), ec(u, 0, !0) !== 0) break e;
            Vr = a, u.timeoutHandle = Ax(
              Kb.bind(
                null,
                u,
                s,
                an,
                Zc,
                Hh,
                a,
                bn,
                la,
                ii,
                lo,
                g,
                "Throttled",
                -0,
                0
              ),
              p
            );
            break e;
          }
          Kb(
            u,
            s,
            an,
            Zc,
            Hh,
            a,
            bn,
            la,
            ii,
            lo,
            g,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    ir(r);
  }
  function Kb(r, a, s, u, p, g, _, z, L, F, Q, ae, q, K) {
    if (r.timeoutHandle = -1, ae = a.subtreeFlags, ae & 8192 || (ae & 16785408) === 16785408) {
      ae = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: !0,
        waitingForViewTransition: !1,
        unsuspend: _r
      }, Hb(
        a,
        g,
        ae
      );
      var ve = (g & 62914560) === g ? $c - fn() : (g & 4194048) === g ? Yb - fn() : 0;
      if (ve = FN(
        ae,
        ve
      ), ve !== null) {
        Vr = g, r.cancelPendingCommit = ve(
          ax.bind(
            null,
            r,
            a,
            g,
            s,
            u,
            p,
            _,
            z,
            L,
            Q,
            ae,
            null,
            q,
            K
          )
        ), ho(r, g, _, !F);
        return;
      }
    }
    ax(
      r,
      a,
      g,
      s,
      u,
      p,
      _,
      z,
      L
    );
  }
  function sN(r) {
    for (var a = r; ; ) {
      var s = a.tag;
      if ((s === 0 || s === 11 || s === 15) && a.flags & 16384 && (s = a.updateQueue, s !== null && (s = s.stores, s !== null)))
        for (var u = 0; u < s.length; u++) {
          var p = s[u], g = p.getSnapshot;
          p = p.value;
          try {
            if (!pn(g(), p)) return !1;
          } catch {
            return !1;
          }
        }
      if (s = a.child, a.subtreeFlags & 16384 && s !== null)
        s.return = a, a = s;
      else {
        if (a === r) break;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === r) return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
    }
    return !0;
  }
  function ho(r, a, s, u) {
    a &= ~$h, a &= ~la, r.suspendedLanes |= a, r.pingedLanes &= ~a, u && (r.warmLanes |= a), u = r.expirationTimes;
    for (var p = a; 0 < p; ) {
      var g = 31 - hn(p), _ = 1 << g;
      u[g] = -1, p &= ~_;
    }
    s !== 0 && sy(r, s, a);
  }
  function Fc() {
    return (Fe & 6) === 0 ? (Is(0), !1) : !0;
  }
  function Yh() {
    if (ke !== null) {
      if (Ye === 0)
        var r = ke.return;
      else
        r = ke, Rr = Qo = null, ch(r), Ja = null, xs = 0, r = ke;
      for (; r !== null; )
        Rb(r.alternate, r), r = r.return;
      ke = null;
    }
  }
  function li(r, a) {
    var s = r.timeoutHandle;
    s !== -1 && (r.timeoutHandle = -1, AN(s)), s = r.cancelPendingCommit, s !== null && (r.cancelPendingCommit = null, s()), Vr = 0, Yh(), et = r, ke = s = Cr(r.current, null), Ie = a, Ye = 0, yn = null, lo = !1, ai = rs(r, a), Bh = !1, ii = bn = $h = la = co = gt = 0, an = Ps = null, Hh = !1, (a & 8) !== 0 && (a |= a & 32);
    var u = r.entangledLanes;
    if (u !== 0)
      for (r = r.entanglements, u &= a; 0 < u; ) {
        var p = 31 - hn(u), g = 1 << p;
        a |= r[p], u &= ~g;
      }
    return Ir = a, dc(), s;
  }
  function Jb(r, a) {
    Me = null, I.H = Rs, a === Ka || a === xc ? (a = p0(), Ye = 3) : a === Kd ? (a = p0(), Ye = 4) : Ye = a === Th ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1, yn = a, ke === null && (gt = 1, jc(
      r,
      Mn(a, r.current)
    ));
  }
  function Qb() {
    var r = gn.current;
    return r === null ? !0 : (Ie & 4194048) === Ie ? On === null : (Ie & 62914560) === Ie || (Ie & 536870912) !== 0 ? r === On : !1;
  }
  function ex() {
    var r = I.H;
    return I.H = Rs, r === null ? Rs : r;
  }
  function tx() {
    var r = I.A;
    return I.A = aN, r;
  }
  function Gc() {
    gt = 4, lo || (Ie & 4194048) !== Ie && gn.current !== null || (ai = !0), (co & 134217727) === 0 && (la & 134217727) === 0 || et === null || ho(
      et,
      Ie,
      bn,
      !1
    );
  }
  function qh(r, a, s) {
    var u = Fe;
    Fe |= 2;
    var p = ex(), g = tx();
    (et !== r || Ie !== a) && (Zc = null, li(r, a)), a = !1;
    var _ = gt;
    e: do
      try {
        if (Ye !== 0 && ke !== null) {
          var z = ke, L = yn;
          switch (Ye) {
            case 8:
              Yh(), _ = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              gn.current === null && (a = !0);
              var F = Ye;
              if (Ye = 0, yn = null, ci(r, z, L, F), s && ai) {
                _ = 0;
                break e;
              }
              break;
            default:
              F = Ye, Ye = 0, yn = null, ci(r, z, L, F);
          }
        }
        lN(), _ = gt;
        break;
      } catch (Q) {
        Jb(r, Q);
      }
    while (!0);
    return a && r.shellSuspendCounter++, Rr = Qo = null, Fe = u, I.H = p, I.A = g, ke === null && (et = null, Ie = 0, dc()), _;
  }
  function lN() {
    for (; ke !== null; ) nx(ke);
  }
  function cN(r, a) {
    var s = Fe;
    Fe |= 2;
    var u = ex(), p = tx();
    et !== r || Ie !== a ? (Zc = null, Hc = fn() + 500, li(r, a)) : ai = rs(
      r,
      a
    );
    e: do
      try {
        if (Ye !== 0 && ke !== null) {
          a = ke;
          var g = yn;
          t: switch (Ye) {
            case 1:
              Ye = 0, yn = null, ci(r, a, g, 1);
              break;
            case 2:
            case 9:
              if (d0(g)) {
                Ye = 0, yn = null, rx(a);
                break;
              }
              a = function() {
                Ye !== 2 && Ye !== 9 || et !== r || (Ye = 7), ir(r);
              }, g.then(a, a);
              break e;
            case 3:
              Ye = 7;
              break e;
            case 4:
              Ye = 5;
              break e;
            case 7:
              d0(g) ? (Ye = 0, yn = null, rx(a)) : (Ye = 0, yn = null, ci(r, a, g, 7));
              break;
            case 5:
              var _ = null;
              switch (ke.tag) {
                case 26:
                  _ = ke.memoizedState;
                case 5:
                case 27:
                  var z = ke;
                  if (_ ? $x(_) : z.stateNode.complete) {
                    Ye = 0, yn = null;
                    var L = z.sibling;
                    if (L !== null) ke = L;
                    else {
                      var F = z.return;
                      F !== null ? (ke = F, Yc(F)) : ke = null;
                    }
                    break t;
                  }
              }
              Ye = 0, yn = null, ci(r, a, g, 5);
              break;
            case 6:
              Ye = 0, yn = null, ci(r, a, g, 6);
              break;
            case 8:
              Yh(), gt = 6;
              break e;
            default:
              throw Error(o(462));
          }
        }
        uN();
        break;
      } catch (Q) {
        Jb(r, Q);
      }
    while (!0);
    return Rr = Qo = null, I.H = u, I.A = p, Fe = s, ke !== null ? 0 : (et = null, Ie = 0, dc(), gt);
  }
  function uN() {
    for (; ke !== null && !Wl(); )
      nx(ke);
  }
  function nx(r) {
    var a = Cb(r.alternate, r, Ir);
    r.memoizedProps = r.pendingProps, a === null ? Yc(r) : ke = a;
  }
  function rx(r) {
    var a = r, s = a.alternate;
    switch (a.tag) {
      case 15:
      case 0:
        a = xb(
          s,
          a,
          a.pendingProps,
          a.type,
          void 0,
          Ie
        );
        break;
      case 11:
        a = xb(
          s,
          a,
          a.pendingProps,
          a.type.render,
          a.ref,
          Ie
        );
        break;
      case 5:
        ch(a);
      default:
        Rb(s, a), a = ke = t0(a, Ir), a = Cb(s, a, Ir);
    }
    r.memoizedProps = r.pendingProps, a === null ? Yc(r) : ke = a;
  }
  function ci(r, a, s, u) {
    Rr = Qo = null, ch(a), Ja = null, xs = 0;
    var p = a.return;
    try {
      if (JD(
        r,
        p,
        a,
        s,
        Ie
      )) {
        gt = 1, jc(
          r,
          Mn(s, r.current)
        ), ke = null;
        return;
      }
    } catch (g) {
      if (p !== null) throw ke = p, g;
      gt = 1, jc(
        r,
        Mn(s, r.current)
      ), ke = null;
      return;
    }
    a.flags & 32768 ? (Ue || u === 1 ? r = !0 : ai || (Ie & 536870912) !== 0 ? r = !1 : (lo = r = !0, (u === 2 || u === 9 || u === 3 || u === 6) && (u = gn.current, u !== null && u.tag === 13 && (u.flags |= 16384))), ox(a, r)) : Yc(a);
  }
  function Yc(r) {
    var a = r;
    do {
      if ((a.flags & 32768) !== 0) {
        ox(
          a,
          lo
        );
        return;
      }
      r = a.return;
      var s = tN(
        a.alternate,
        a,
        Ir
      );
      if (s !== null) {
        ke = s;
        return;
      }
      if (a = a.sibling, a !== null) {
        ke = a;
        return;
      }
      ke = a = r;
    } while (a !== null);
    gt === 0 && (gt = 5);
  }
  function ox(r, a) {
    do {
      var s = nN(r.alternate, r);
      if (s !== null) {
        s.flags &= 32767, ke = s;
        return;
      }
      if (s = r.return, s !== null && (s.flags |= 32768, s.subtreeFlags = 0, s.deletions = null), !a && (r = r.sibling, r !== null)) {
        ke = r;
        return;
      }
      ke = r = s;
    } while (r !== null);
    gt = 6, ke = null;
  }
  function ax(r, a, s, u, p, g, _, z, L) {
    r.cancelPendingCommit = null;
    do
      qc();
    while (Rt !== 0);
    if ((Fe & 6) !== 0) throw Error(o(327));
    if (a !== null) {
      if (a === r.current) throw Error(o(177));
      if (g = a.lanes | a.childLanes, g |= Pd, Hz(
        r,
        s,
        g,
        _,
        z,
        L
      ), r === et && (ke = et = null, Ie = 0), si = a, fo = r, Vr = s, Zh = g, Fh = p, qb = u, (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? (r.callbackNode = null, r.callbackPriority = 0, pN(Xl, function() {
        return ux(), null;
      })) : (r.callbackNode = null, r.callbackPriority = 0), u = (a.flags & 13878) !== 0, (a.subtreeFlags & 13878) !== 0 || u) {
        u = I.T, I.T = null, p = G.p, G.p = 2, _ = Fe, Fe |= 4;
        try {
          rN(r, a, s);
        } finally {
          Fe = _, G.p = p, I.T = u;
        }
      }
      Rt = 1, ix(), sx(), lx();
    }
  }
  function ix() {
    if (Rt === 1) {
      Rt = 0;
      var r = fo, a = si, s = (a.flags & 13878) !== 0;
      if ((a.subtreeFlags & 13878) !== 0 || s) {
        s = I.T, I.T = null;
        var u = G.p;
        G.p = 2;
        var p = Fe;
        Fe |= 4;
        try {
          Ub(a, r);
          var g = ip, _ = Gy(r.containerInfo), z = g.focusedElem, L = g.selectionRange;
          if (_ !== z && z && z.ownerDocument && Fy(
            z.ownerDocument.documentElement,
            z
          )) {
            if (L !== null && Dd(z)) {
              var F = L.start, Q = L.end;
              if (Q === void 0 && (Q = F), "selectionStart" in z)
                z.selectionStart = F, z.selectionEnd = Math.min(
                  Q,
                  z.value.length
                );
              else {
                var ae = z.ownerDocument || document, q = ae && ae.defaultView || window;
                if (q.getSelection) {
                  var K = q.getSelection(), ve = z.textContent.length, _e = Math.min(L.start, ve), Je = L.end === void 0 ? _e : Math.min(L.end, ve);
                  !K.extend && _e > Je && (_ = Je, Je = _e, _e = _);
                  var B = Zy(
                    z,
                    _e
                  ), V = Zy(
                    z,
                    Je
                  );
                  if (B && V && (K.rangeCount !== 1 || K.anchorNode !== B.node || K.anchorOffset !== B.offset || K.focusNode !== V.node || K.focusOffset !== V.offset)) {
                    var Z = ae.createRange();
                    Z.setStart(B.node, B.offset), K.removeAllRanges(), _e > Je ? (K.addRange(Z), K.extend(V.node, V.offset)) : (Z.setEnd(V.node, V.offset), K.addRange(Z));
                  }
                }
              }
            }
            for (ae = [], K = z; K = K.parentNode; )
              K.nodeType === 1 && ae.push({
                element: K,
                left: K.scrollLeft,
                top: K.scrollTop
              });
            for (typeof z.focus == "function" && z.focus(), z = 0; z < ae.length; z++) {
              var oe = ae[z];
              oe.element.scrollLeft = oe.left, oe.element.scrollTop = oe.top;
            }
          }
          iu = !!ap, ip = ap = null;
        } finally {
          Fe = p, G.p = u, I.T = s;
        }
      }
      r.current = a, Rt = 2;
    }
  }
  function sx() {
    if (Rt === 2) {
      Rt = 0;
      var r = fo, a = si, s = (a.flags & 8772) !== 0;
      if ((a.subtreeFlags & 8772) !== 0 || s) {
        s = I.T, I.T = null;
        var u = G.p;
        G.p = 2;
        var p = Fe;
        Fe |= 4;
        try {
          kb(r, a.alternate, a);
        } finally {
          Fe = p, G.p = u, I.T = s;
        }
      }
      Rt = 3;
    }
  }
  function lx() {
    if (Rt === 4 || Rt === 3) {
      Rt = 0, cd();
      var r = fo, a = si, s = Vr, u = qb;
      (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? Rt = 5 : (Rt = 0, si = fo = null, cx(r, r.pendingLanes));
      var p = r.pendingLanes;
      if (p === 0 && (uo = null), dd(s), a = a.stateNode, dn && typeof dn.onCommitFiberRoot == "function")
        try {
          dn.onCommitFiberRoot(
            ns,
            a,
            void 0,
            (a.current.flags & 128) === 128
          );
        } catch {
        }
      if (u !== null) {
        a = I.T, p = G.p, G.p = 2, I.T = null;
        try {
          for (var g = r.onRecoverableError, _ = 0; _ < u.length; _++) {
            var z = u[_];
            g(z.value, {
              componentStack: z.stack
            });
          }
        } finally {
          I.T = a, G.p = p;
        }
      }
      (Vr & 3) !== 0 && qc(), ir(r), p = r.pendingLanes, (s & 261930) !== 0 && (p & 42) !== 0 ? r === Gh ? Ls++ : (Ls = 0, Gh = r) : Ls = 0, Is(0);
    }
  }
  function cx(r, a) {
    (r.pooledCacheLanes &= a) === 0 && (a = r.pooledCache, a != null && (r.pooledCache = null, ys(a)));
  }
  function qc() {
    return ix(), sx(), lx(), ux();
  }
  function ux() {
    if (Rt !== 5) return !1;
    var r = fo, a = Zh;
    Zh = 0;
    var s = dd(Vr), u = I.T, p = G.p;
    try {
      G.p = 32 > s ? 32 : s, I.T = null, s = Fh, Fh = null;
      var g = fo, _ = Vr;
      if (Rt = 0, si = fo = null, Vr = 0, (Fe & 6) !== 0) throw Error(o(331));
      var z = Fe;
      if (Fe |= 4, Fb(g.current), $b(
        g,
        g.current,
        _,
        s
      ), Fe = z, Is(0, !1), dn && typeof dn.onPostCommitFiberRoot == "function")
        try {
          dn.onPostCommitFiberRoot(ns, g);
        } catch {
        }
      return !0;
    } finally {
      G.p = p, I.T = u, cx(r, a);
    }
  }
  function fx(r, a, s) {
    a = Mn(s, a), a = _h(r.stateNode, a, 2), r = oo(r, a, 2), r !== null && (os(r, 2), ir(r));
  }
  function qe(r, a, s) {
    if (r.tag === 3)
      fx(r, r, s);
    else
      for (; a !== null; ) {
        if (a.tag === 3) {
          fx(
            a,
            r,
            s
          );
          break;
        } else if (a.tag === 1) {
          var u = a.stateNode;
          if (typeof a.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (uo === null || !uo.has(u))) {
            r = Mn(s, r), s = db(2), u = oo(a, s, 2), u !== null && (hb(
              s,
              u,
              a,
              r
            ), os(u, 2), ir(u));
            break;
          }
        }
        a = a.return;
      }
  }
  function Wh(r, a, s) {
    var u = r.pingCache;
    if (u === null) {
      u = r.pingCache = new iN();
      var p = /* @__PURE__ */ new Set();
      u.set(a, p);
    } else
      p = u.get(a), p === void 0 && (p = /* @__PURE__ */ new Set(), u.set(a, p));
    p.has(s) || (Bh = !0, p.add(s), r = fN.bind(null, r, a, s), a.then(r, r));
  }
  function fN(r, a, s) {
    var u = r.pingCache;
    u !== null && u.delete(a), r.pingedLanes |= r.suspendedLanes & s, r.warmLanes &= ~s, et === r && (Ie & s) === s && (gt === 4 || gt === 3 && (Ie & 62914560) === Ie && 300 > fn() - $c ? (Fe & 2) === 0 && li(r, 0) : $h |= s, ii === Ie && (ii = 0)), ir(r);
  }
  function dx(r, a) {
    a === 0 && (a = iy()), r = Xo(r, a), r !== null && (os(r, a), ir(r));
  }
  function dN(r) {
    var a = r.memoizedState, s = 0;
    a !== null && (s = a.retryLane), dx(r, s);
  }
  function hN(r, a) {
    var s = 0;
    switch (r.tag) {
      case 31:
      case 13:
        var u = r.stateNode, p = r.memoizedState;
        p !== null && (s = p.retryLane);
        break;
      case 19:
        u = r.stateNode;
        break;
      case 22:
        u = r.stateNode._retryCache;
        break;
      default:
        throw Error(o(314));
    }
    u !== null && u.delete(a), dx(r, s);
  }
  function pN(r, a) {
    return ts(r, a);
  }
  var Wc = null, ui = null, Xh = !1, Xc = !1, Kh = !1, po = 0;
  function ir(r) {
    r !== ui && r.next === null && (ui === null ? Wc = ui = r : ui = ui.next = r), Xc = !0, Xh || (Xh = !0, gN());
  }
  function Is(r, a) {
    if (!Kh && Xc) {
      Kh = !0;
      do
        for (var s = !1, u = Wc; u !== null; ) {
          if (r !== 0) {
            var p = u.pendingLanes;
            if (p === 0) var g = 0;
            else {
              var _ = u.suspendedLanes, z = u.pingedLanes;
              g = (1 << 31 - hn(42 | r) + 1) - 1, g &= p & ~(_ & ~z), g = g & 201326741 ? g & 201326741 | 1 : g ? g | 2 : 0;
            }
            g !== 0 && (s = !0, gx(u, g));
          } else
            g = Ie, g = ec(
              u,
              u === et ? g : 0,
              u.cancelPendingCommit !== null || u.timeoutHandle !== -1
            ), (g & 3) === 0 || rs(u, g) || (s = !0, gx(u, g));
          u = u.next;
        }
      while (s);
      Kh = !1;
    }
  }
  function mN() {
    hx();
  }
  function hx() {
    Xc = Xh = !1;
    var r = 0;
    po !== 0 && CN() && (r = po);
    for (var a = fn(), s = null, u = Wc; u !== null; ) {
      var p = u.next, g = px(u, a);
      g === 0 ? (u.next = null, s === null ? Wc = p : s.next = p, p === null && (ui = s)) : (s = u, (r !== 0 || (g & 3) !== 0) && (Xc = !0)), u = p;
    }
    Rt !== 0 && Rt !== 5 || Is(r), po !== 0 && (po = 0);
  }
  function px(r, a) {
    for (var s = r.suspendedLanes, u = r.pingedLanes, p = r.expirationTimes, g = r.pendingLanes & -62914561; 0 < g; ) {
      var _ = 31 - hn(g), z = 1 << _, L = p[_];
      L === -1 ? ((z & s) === 0 || (z & u) !== 0) && (p[_] = $z(z, a)) : L <= a && (r.expiredLanes |= z), g &= ~z;
    }
    if (a = et, s = Ie, s = ec(
      r,
      r === a ? s : 0,
      r.cancelPendingCommit !== null || r.timeoutHandle !== -1
    ), u = r.callbackNode, s === 0 || r === a && (Ye === 2 || Ye === 9) || r.cancelPendingCommit !== null)
      return u !== null && u !== null && wr(u), r.callbackNode = null, r.callbackPriority = 0;
    if ((s & 3) === 0 || rs(r, s)) {
      if (a = s & -s, a === r.callbackPriority) return a;
      switch (u !== null && wr(u), dd(s)) {
        case 2:
        case 8:
          s = oy;
          break;
        case 32:
          s = Xl;
          break;
        case 268435456:
          s = ay;
          break;
        default:
          s = Xl;
      }
      return u = mx.bind(null, r), s = ts(s, u), r.callbackPriority = a, r.callbackNode = s, a;
    }
    return u !== null && u !== null && wr(u), r.callbackPriority = 2, r.callbackNode = null, 2;
  }
  function mx(r, a) {
    if (Rt !== 0 && Rt !== 5)
      return r.callbackNode = null, r.callbackPriority = 0, null;
    var s = r.callbackNode;
    if (qc() && r.callbackNode !== s)
      return null;
    var u = Ie;
    return u = ec(
      r,
      r === et ? u : 0,
      r.cancelPendingCommit !== null || r.timeoutHandle !== -1
    ), u === 0 ? null : (Xb(r, u, a), px(r, fn()), r.callbackNode != null && r.callbackNode === s ? mx.bind(null, r) : null);
  }
  function gx(r, a) {
    if (qc()) return null;
    Xb(r, a, !0);
  }
  function gN() {
    RN(function() {
      (Fe & 6) !== 0 ? ts(
        ry,
        mN
      ) : hx();
    });
  }
  function Jh() {
    if (po === 0) {
      var r = Wa;
      r === 0 && (r = Kl, Kl <<= 1, (Kl & 261888) === 0 && (Kl = 256)), po = r;
    }
    return po;
  }
  function vx(r) {
    return r == null || typeof r == "symbol" || typeof r == "boolean" ? null : typeof r == "function" ? r : oc("" + r);
  }
  function yx(r, a) {
    var s = a.ownerDocument.createElement("input");
    return s.name = a.name, s.value = a.value, r.id && s.setAttribute("form", r.id), a.parentNode.insertBefore(s, a), r = new FormData(r), s.parentNode.removeChild(s), r;
  }
  function vN(r, a, s, u, p) {
    if (a === "submit" && s && s.stateNode === p) {
      var g = vx(
        (p[en] || null).action
      ), _ = u.submitter;
      _ && (a = (a = _[en] || null) ? vx(a.formAction) : _.getAttribute("formAction"), a !== null && (g = a, _ = null));
      var z = new lc(
        "action",
        "action",
        null,
        u,
        p
      );
      r.push({
        event: z,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (u.defaultPrevented) {
                if (po !== 0) {
                  var L = _ ? yx(p, _) : new FormData(p);
                  yh(
                    s,
                    {
                      pending: !0,
                      data: L,
                      method: p.method,
                      action: g
                    },
                    null,
                    L
                  );
                }
              } else
                typeof g == "function" && (z.preventDefault(), L = _ ? yx(p, _) : new FormData(p), yh(
                  s,
                  {
                    pending: !0,
                    data: L,
                    method: p.method,
                    action: g
                  },
                  g,
                  L
                ));
            },
            currentTarget: p
          }
        ]
      });
    }
  }
  for (var Qh = 0; Qh < kd.length; Qh++) {
    var ep = kd[Qh], yN = ep.toLowerCase(), bN = ep[0].toUpperCase() + ep.slice(1);
    Zn(
      yN,
      "on" + bN
    );
  }
  Zn(Wy, "onAnimationEnd"), Zn(Xy, "onAnimationIteration"), Zn(Ky, "onAnimationStart"), Zn("dblclick", "onDoubleClick"), Zn("focusin", "onFocus"), Zn("focusout", "onBlur"), Zn(kD, "onTransitionRun"), Zn(PD, "onTransitionStart"), Zn(LD, "onTransitionCancel"), Zn(Jy, "onTransitionEnd"), ka("onMouseEnter", ["mouseout", "mouseover"]), ka("onMouseLeave", ["mouseout", "mouseover"]), ka("onPointerEnter", ["pointerout", "pointerover"]), ka("onPointerLeave", ["pointerout", "pointerover"]), Go(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Go(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Go("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Go(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Go(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Go(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Vs = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), xN = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Vs)
  );
  function bx(r, a) {
    a = (a & 4) !== 0;
    for (var s = 0; s < r.length; s++) {
      var u = r[s], p = u.event;
      u = u.listeners;
      e: {
        var g = void 0;
        if (a)
          for (var _ = u.length - 1; 0 <= _; _--) {
            var z = u[_], L = z.instance, F = z.currentTarget;
            if (z = z.listener, L !== g && p.isPropagationStopped())
              break e;
            g = z, p.currentTarget = F;
            try {
              g(p);
            } catch (Q) {
              fc(Q);
            }
            p.currentTarget = null, g = L;
          }
        else
          for (_ = 0; _ < u.length; _++) {
            if (z = u[_], L = z.instance, F = z.currentTarget, z = z.listener, L !== g && p.isPropagationStopped())
              break e;
            g = z, p.currentTarget = F;
            try {
              g(p);
            } catch (Q) {
              fc(Q);
            }
            p.currentTarget = null, g = L;
          }
      }
    }
  }
  function Pe(r, a) {
    var s = a[hd];
    s === void 0 && (s = a[hd] = /* @__PURE__ */ new Set());
    var u = r + "__bubble";
    s.has(u) || (xx(a, r, 2, !1), s.add(u));
  }
  function tp(r, a, s) {
    var u = 0;
    a && (u |= 4), xx(
      s,
      r,
      u,
      a
    );
  }
  var Kc = "_reactListening" + Math.random().toString(36).slice(2);
  function np(r) {
    if (!r[Kc]) {
      r[Kc] = !0, hy.forEach(function(s) {
        s !== "selectionchange" && (xN.has(s) || tp(s, !1, r), tp(s, !0, r));
      });
      var a = r.nodeType === 9 ? r : r.ownerDocument;
      a === null || a[Kc] || (a[Kc] = !0, tp("selectionchange", !1, a));
    }
  }
  function xx(r, a, s, u) {
    switch (Wx(a)) {
      case 2:
        var p = qN;
        break;
      case 8:
        p = WN;
        break;
      default:
        p = vp;
    }
    s = p.bind(
      null,
      a,
      s,
      r
    ), p = void 0, !wd || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (p = !0), u ? p !== void 0 ? r.addEventListener(a, s, {
      capture: !0,
      passive: p
    }) : r.addEventListener(a, s, !0) : p !== void 0 ? r.addEventListener(a, s, {
      passive: p
    }) : r.addEventListener(a, s, !1);
  }
  function rp(r, a, s, u, p) {
    var g = u;
    if ((a & 1) === 0 && (a & 2) === 0 && u !== null)
      e: for (; ; ) {
        if (u === null) return;
        var _ = u.tag;
        if (_ === 3 || _ === 4) {
          var z = u.stateNode.containerInfo;
          if (z === p) break;
          if (_ === 4)
            for (_ = u.return; _ !== null; ) {
              var L = _.tag;
              if ((L === 3 || L === 4) && _.stateNode.containerInfo === p)
                return;
              _ = _.return;
            }
          for (; z !== null; ) {
            if (_ = Na(z), _ === null) return;
            if (L = _.tag, L === 5 || L === 6 || L === 26 || L === 27) {
              u = g = _;
              continue e;
            }
            z = z.parentNode;
          }
        }
        u = u.return;
      }
    Ty(function() {
      var F = g, Q = xd(s), ae = [];
      e: {
        var q = Qy.get(r);
        if (q !== void 0) {
          var K = lc, ve = r;
          switch (r) {
            case "keypress":
              if (ic(s) === 0) break e;
            case "keydown":
            case "keyup":
              K = hD;
              break;
            case "focusin":
              ve = "focus", K = Cd;
              break;
            case "focusout":
              ve = "blur", K = Cd;
              break;
            case "beforeblur":
            case "afterblur":
              K = Cd;
              break;
            case "click":
              if (s.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              K = Ry;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              K = tD;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              K = gD;
              break;
            case Wy:
            case Xy:
            case Ky:
              K = oD;
              break;
            case Jy:
              K = yD;
              break;
            case "scroll":
            case "scrollend":
              K = Qz;
              break;
            case "wheel":
              K = xD;
              break;
            case "copy":
            case "cut":
            case "paste":
              K = iD;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              K = zy;
              break;
            case "toggle":
            case "beforetoggle":
              K = wD;
          }
          var _e = (a & 4) !== 0, Je = !_e && (r === "scroll" || r === "scrollend"), B = _e ? q !== null ? q + "Capture" : null : q;
          _e = [];
          for (var V = F, Z; V !== null; ) {
            var oe = V;
            if (Z = oe.stateNode, oe = oe.tag, oe !== 5 && oe !== 26 && oe !== 27 || Z === null || B === null || (oe = ss(V, B), oe != null && _e.push(
              Us(V, oe, Z)
            )), Je) break;
            V = V.return;
          }
          0 < _e.length && (q = new K(
            q,
            ve,
            null,
            s,
            Q
          ), ae.push({ event: q, listeners: _e }));
        }
      }
      if ((a & 7) === 0) {
        e: {
          if (q = r === "mouseover" || r === "pointerover", K = r === "mouseout" || r === "pointerout", q && s !== bd && (ve = s.relatedTarget || s.fromElement) && (Na(ve) || ve[Da]))
            break e;
          if ((K || q) && (q = Q.window === Q ? Q : (q = Q.ownerDocument) ? q.defaultView || q.parentWindow : window, K ? (ve = s.relatedTarget || s.toElement, K = F, ve = ve ? Na(ve) : null, ve !== null && (Je = l(ve), _e = ve.tag, ve !== Je || _e !== 5 && _e !== 27 && _e !== 6) && (ve = null)) : (K = null, ve = F), K !== ve)) {
            if (_e = Ry, oe = "onMouseLeave", B = "onMouseEnter", V = "mouse", (r === "pointerout" || r === "pointerover") && (_e = zy, oe = "onPointerLeave", B = "onPointerEnter", V = "pointer"), Je = K == null ? q : is(K), Z = ve == null ? q : is(ve), q = new _e(
              oe,
              V + "leave",
              K,
              s,
              Q
            ), q.target = Je, q.relatedTarget = Z, oe = null, Na(Q) === F && (_e = new _e(
              B,
              V + "enter",
              ve,
              s,
              Q
            ), _e.target = Z, _e.relatedTarget = Je, oe = _e), Je = oe, K && ve)
              t: {
                for (_e = SN, B = K, V = ve, Z = 0, oe = B; oe; oe = _e(oe))
                  Z++;
                oe = 0;
                for (var Ee = V; Ee; Ee = _e(Ee))
                  oe++;
                for (; 0 < Z - oe; )
                  B = _e(B), Z--;
                for (; 0 < oe - Z; )
                  V = _e(V), oe--;
                for (; Z--; ) {
                  if (B === V || V !== null && B === V.alternate) {
                    _e = B;
                    break t;
                  }
                  B = _e(B), V = _e(V);
                }
                _e = null;
              }
            else _e = null;
            K !== null && Sx(
              ae,
              q,
              K,
              _e,
              !1
            ), ve !== null && Je !== null && Sx(
              ae,
              Je,
              ve,
              _e,
              !0
            );
          }
        }
        e: {
          if (q = F ? is(F) : window, K = q.nodeName && q.nodeName.toLowerCase(), K === "select" || K === "input" && q.type === "file")
            var He = Iy;
          else if (Py(q))
            if (Vy)
              He = ND;
            else {
              He = zD;
              var Se = MD;
            }
          else
            K = q.nodeName, !K || K.toLowerCase() !== "input" || q.type !== "checkbox" && q.type !== "radio" ? F && yd(F.elementType) && (He = Iy) : He = DD;
          if (He && (He = He(r, F))) {
            Ly(
              ae,
              He,
              s,
              Q
            );
            break e;
          }
          Se && Se(r, q, F), r === "focusout" && F && q.type === "number" && F.memoizedProps.value != null && vd(q, "number", q.value);
        }
        switch (Se = F ? is(F) : window, r) {
          case "focusin":
            (Py(Se) || Se.contentEditable === "true") && (Ba = Se, Nd = F, ms = null);
            break;
          case "focusout":
            ms = Nd = Ba = null;
            break;
          case "mousedown":
            Od = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Od = !1, Yy(ae, s, Q);
            break;
          case "selectionchange":
            if (jD) break;
          case "keydown":
          case "keyup":
            Yy(ae, s, Q);
        }
        var De;
        if (Rd)
          e: {
            switch (r) {
              case "compositionstart":
                var Ve = "onCompositionStart";
                break e;
              case "compositionend":
                Ve = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Ve = "onCompositionUpdate";
                break e;
            }
            Ve = void 0;
          }
        else
          Ua ? jy(r, s) && (Ve = "onCompositionEnd") : r === "keydown" && s.keyCode === 229 && (Ve = "onCompositionStart");
        Ve && (Dy && s.locale !== "ko" && (Ua || Ve !== "onCompositionStart" ? Ve === "onCompositionEnd" && Ua && (De = Cy()) : (Kr = Q, Ed = "value" in Kr ? Kr.value : Kr.textContent, Ua = !0)), Se = Jc(F, Ve), 0 < Se.length && (Ve = new My(
          Ve,
          r,
          null,
          s,
          Q
        ), ae.push({ event: Ve, listeners: Se }), De ? Ve.data = De : (De = ky(s), De !== null && (Ve.data = De)))), (De = _D ? TD(r, s) : CD(r, s)) && (Ve = Jc(F, "onBeforeInput"), 0 < Ve.length && (Se = new My(
          "onBeforeInput",
          "beforeinput",
          null,
          s,
          Q
        ), ae.push({
          event: Se,
          listeners: Ve
        }), Se.data = De)), vN(
          ae,
          r,
          F,
          s,
          Q
        );
      }
      bx(ae, a);
    });
  }
  function Us(r, a, s) {
    return {
      instance: r,
      listener: a,
      currentTarget: s
    };
  }
  function Jc(r, a) {
    for (var s = a + "Capture", u = []; r !== null; ) {
      var p = r, g = p.stateNode;
      if (p = p.tag, p !== 5 && p !== 26 && p !== 27 || g === null || (p = ss(r, s), p != null && u.unshift(
        Us(r, p, g)
      ), p = ss(r, a), p != null && u.push(
        Us(r, p, g)
      )), r.tag === 3) return u;
      r = r.return;
    }
    return [];
  }
  function SN(r) {
    if (r === null) return null;
    do
      r = r.return;
    while (r && r.tag !== 5 && r.tag !== 27);
    return r || null;
  }
  function Sx(r, a, s, u, p) {
    for (var g = a._reactName, _ = []; s !== null && s !== u; ) {
      var z = s, L = z.alternate, F = z.stateNode;
      if (z = z.tag, L !== null && L === u) break;
      z !== 5 && z !== 26 && z !== 27 || F === null || (L = F, p ? (F = ss(s, g), F != null && _.unshift(
        Us(s, F, L)
      )) : p || (F = ss(s, g), F != null && _.push(
        Us(s, F, L)
      ))), s = s.return;
    }
    _.length !== 0 && r.push({ event: a, listeners: _ });
  }
  var wN = /\r\n?/g, EN = /\u0000|\uFFFD/g;
  function wx(r) {
    return (typeof r == "string" ? r : "" + r).replace(wN, `
`).replace(EN, "");
  }
  function Ex(r, a) {
    return a = wx(a), wx(r) === a;
  }
  function Ke(r, a, s, u, p, g) {
    switch (s) {
      case "children":
        typeof u == "string" ? a === "body" || a === "textarea" && u === "" || La(r, u) : (typeof u == "number" || typeof u == "bigint") && a !== "body" && La(r, "" + u);
        break;
      case "className":
        nc(r, "class", u);
        break;
      case "tabIndex":
        nc(r, "tabindex", u);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        nc(r, s, u);
        break;
      case "style":
        Ey(r, u, g);
        break;
      case "data":
        if (a !== "object") {
          nc(r, "data", u);
          break;
        }
      case "src":
      case "href":
        if (u === "" && (a !== "a" || s !== "href")) {
          r.removeAttribute(s);
          break;
        }
        if (u == null || typeof u == "function" || typeof u == "symbol" || typeof u == "boolean") {
          r.removeAttribute(s);
          break;
        }
        u = oc("" + u), r.setAttribute(s, u);
        break;
      case "action":
      case "formAction":
        if (typeof u == "function") {
          r.setAttribute(
            s,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof g == "function" && (s === "formAction" ? (a !== "input" && Ke(r, a, "name", p.name, p, null), Ke(
            r,
            a,
            "formEncType",
            p.formEncType,
            p,
            null
          ), Ke(
            r,
            a,
            "formMethod",
            p.formMethod,
            p,
            null
          ), Ke(
            r,
            a,
            "formTarget",
            p.formTarget,
            p,
            null
          )) : (Ke(r, a, "encType", p.encType, p, null), Ke(r, a, "method", p.method, p, null), Ke(r, a, "target", p.target, p, null)));
        if (u == null || typeof u == "symbol" || typeof u == "boolean") {
          r.removeAttribute(s);
          break;
        }
        u = oc("" + u), r.setAttribute(s, u);
        break;
      case "onClick":
        u != null && (r.onclick = _r);
        break;
      case "onScroll":
        u != null && Pe("scroll", r);
        break;
      case "onScrollEnd":
        u != null && Pe("scrollend", r);
        break;
      case "dangerouslySetInnerHTML":
        if (u != null) {
          if (typeof u != "object" || !("__html" in u))
            throw Error(o(61));
          if (s = u.__html, s != null) {
            if (p.children != null) throw Error(o(60));
            r.innerHTML = s;
          }
        }
        break;
      case "multiple":
        r.multiple = u && typeof u != "function" && typeof u != "symbol";
        break;
      case "muted":
        r.muted = u && typeof u != "function" && typeof u != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (u == null || typeof u == "function" || typeof u == "boolean" || typeof u == "symbol") {
          r.removeAttribute("xlink:href");
          break;
        }
        s = oc("" + u), r.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          s
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        u != null && typeof u != "function" && typeof u != "symbol" ? r.setAttribute(s, "" + u) : r.removeAttribute(s);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        u && typeof u != "function" && typeof u != "symbol" ? r.setAttribute(s, "") : r.removeAttribute(s);
        break;
      case "capture":
      case "download":
        u === !0 ? r.setAttribute(s, "") : u !== !1 && u != null && typeof u != "function" && typeof u != "symbol" ? r.setAttribute(s, u) : r.removeAttribute(s);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        u != null && typeof u != "function" && typeof u != "symbol" && !isNaN(u) && 1 <= u ? r.setAttribute(s, u) : r.removeAttribute(s);
        break;
      case "rowSpan":
      case "start":
        u == null || typeof u == "function" || typeof u == "symbol" || isNaN(u) ? r.removeAttribute(s) : r.setAttribute(s, u);
        break;
      case "popover":
        Pe("beforetoggle", r), Pe("toggle", r), tc(r, "popover", u);
        break;
      case "xlinkActuate":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          u
        );
        break;
      case "xlinkArcrole":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          u
        );
        break;
      case "xlinkRole":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          u
        );
        break;
      case "xlinkShow":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          u
        );
        break;
      case "xlinkTitle":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          u
        );
        break;
      case "xlinkType":
        Er(
          r,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          u
        );
        break;
      case "xmlBase":
        Er(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          u
        );
        break;
      case "xmlLang":
        Er(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          u
        );
        break;
      case "xmlSpace":
        Er(
          r,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          u
        );
        break;
      case "is":
        tc(r, "is", u);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < s.length) || s[0] !== "o" && s[0] !== "O" || s[1] !== "n" && s[1] !== "N") && (s = Kz.get(s) || s, tc(r, s, u));
    }
  }
  function op(r, a, s, u, p, g) {
    switch (s) {
      case "style":
        Ey(r, u, g);
        break;
      case "dangerouslySetInnerHTML":
        if (u != null) {
          if (typeof u != "object" || !("__html" in u))
            throw Error(o(61));
          if (s = u.__html, s != null) {
            if (p.children != null) throw Error(o(60));
            r.innerHTML = s;
          }
        }
        break;
      case "children":
        typeof u == "string" ? La(r, u) : (typeof u == "number" || typeof u == "bigint") && La(r, "" + u);
        break;
      case "onScroll":
        u != null && Pe("scroll", r);
        break;
      case "onScrollEnd":
        u != null && Pe("scrollend", r);
        break;
      case "onClick":
        u != null && (r.onclick = _r);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!py.hasOwnProperty(s))
          e: {
            if (s[0] === "o" && s[1] === "n" && (p = s.endsWith("Capture"), a = s.slice(2, p ? s.length - 7 : void 0), g = r[en] || null, g = g != null ? g[s] : null, typeof g == "function" && r.removeEventListener(a, g, p), typeof u == "function")) {
              typeof g != "function" && g !== null && (s in r ? r[s] = null : r.hasAttribute(s) && r.removeAttribute(s)), r.addEventListener(a, u, p);
              break e;
            }
            s in r ? r[s] = u : u === !0 ? r.setAttribute(s, "") : tc(r, s, u);
          }
    }
  }
  function Ut(r, a, s) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Pe("error", r), Pe("load", r);
        var u = !1, p = !1, g;
        for (g in s)
          if (s.hasOwnProperty(g)) {
            var _ = s[g];
            if (_ != null)
              switch (g) {
                case "src":
                  u = !0;
                  break;
                case "srcSet":
                  p = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(o(137, a));
                default:
                  Ke(r, a, g, _, s, null);
              }
          }
        p && Ke(r, a, "srcSet", s.srcSet, s, null), u && Ke(r, a, "src", s.src, s, null);
        return;
      case "input":
        Pe("invalid", r);
        var z = g = _ = p = null, L = null, F = null;
        for (u in s)
          if (s.hasOwnProperty(u)) {
            var Q = s[u];
            if (Q != null)
              switch (u) {
                case "name":
                  p = Q;
                  break;
                case "type":
                  _ = Q;
                  break;
                case "checked":
                  L = Q;
                  break;
                case "defaultChecked":
                  F = Q;
                  break;
                case "value":
                  g = Q;
                  break;
                case "defaultValue":
                  z = Q;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Q != null)
                    throw Error(o(137, a));
                  break;
                default:
                  Ke(r, a, u, Q, s, null);
              }
          }
        by(
          r,
          g,
          z,
          L,
          F,
          _,
          p,
          !1
        );
        return;
      case "select":
        Pe("invalid", r), u = _ = g = null;
        for (p in s)
          if (s.hasOwnProperty(p) && (z = s[p], z != null))
            switch (p) {
              case "value":
                g = z;
                break;
              case "defaultValue":
                _ = z;
                break;
              case "multiple":
                u = z;
              default:
                Ke(r, a, p, z, s, null);
            }
        a = g, s = _, r.multiple = !!u, a != null ? Pa(r, !!u, a, !1) : s != null && Pa(r, !!u, s, !0);
        return;
      case "textarea":
        Pe("invalid", r), g = p = u = null;
        for (_ in s)
          if (s.hasOwnProperty(_) && (z = s[_], z != null))
            switch (_) {
              case "value":
                u = z;
                break;
              case "defaultValue":
                p = z;
                break;
              case "children":
                g = z;
                break;
              case "dangerouslySetInnerHTML":
                if (z != null) throw Error(o(91));
                break;
              default:
                Ke(r, a, _, z, s, null);
            }
        Sy(r, u, p, g);
        return;
      case "option":
        for (L in s)
          s.hasOwnProperty(L) && (u = s[L], u != null) && (L === "selected" ? r.selected = u && typeof u != "function" && typeof u != "symbol" : Ke(r, a, L, u, s, null));
        return;
      case "dialog":
        Pe("beforetoggle", r), Pe("toggle", r), Pe("cancel", r), Pe("close", r);
        break;
      case "iframe":
      case "object":
        Pe("load", r);
        break;
      case "video":
      case "audio":
        for (u = 0; u < Vs.length; u++)
          Pe(Vs[u], r);
        break;
      case "image":
        Pe("error", r), Pe("load", r);
        break;
      case "details":
        Pe("toggle", r);
        break;
      case "embed":
      case "source":
      case "link":
        Pe("error", r), Pe("load", r);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (F in s)
          if (s.hasOwnProperty(F) && (u = s[F], u != null))
            switch (F) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(o(137, a));
              default:
                Ke(r, a, F, u, s, null);
            }
        return;
      default:
        if (yd(a)) {
          for (Q in s)
            s.hasOwnProperty(Q) && (u = s[Q], u !== void 0 && op(
              r,
              a,
              Q,
              u,
              s,
              void 0
            ));
          return;
        }
    }
    for (z in s)
      s.hasOwnProperty(z) && (u = s[z], u != null && Ke(r, a, z, u, s, null));
  }
  function _N(r, a, s, u) {
    switch (a) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var p = null, g = null, _ = null, z = null, L = null, F = null, Q = null;
        for (K in s) {
          var ae = s[K];
          if (s.hasOwnProperty(K) && ae != null)
            switch (K) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                L = ae;
              default:
                u.hasOwnProperty(K) || Ke(r, a, K, null, u, ae);
            }
        }
        for (var q in u) {
          var K = u[q];
          if (ae = s[q], u.hasOwnProperty(q) && (K != null || ae != null))
            switch (q) {
              case "type":
                g = K;
                break;
              case "name":
                p = K;
                break;
              case "checked":
                F = K;
                break;
              case "defaultChecked":
                Q = K;
                break;
              case "value":
                _ = K;
                break;
              case "defaultValue":
                z = K;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (K != null)
                  throw Error(o(137, a));
                break;
              default:
                K !== ae && Ke(
                  r,
                  a,
                  q,
                  K,
                  u,
                  ae
                );
            }
        }
        gd(
          r,
          _,
          z,
          L,
          F,
          Q,
          g,
          p
        );
        return;
      case "select":
        K = _ = z = q = null;
        for (g in s)
          if (L = s[g], s.hasOwnProperty(g) && L != null)
            switch (g) {
              case "value":
                break;
              case "multiple":
                K = L;
              default:
                u.hasOwnProperty(g) || Ke(
                  r,
                  a,
                  g,
                  null,
                  u,
                  L
                );
            }
        for (p in u)
          if (g = u[p], L = s[p], u.hasOwnProperty(p) && (g != null || L != null))
            switch (p) {
              case "value":
                q = g;
                break;
              case "defaultValue":
                z = g;
                break;
              case "multiple":
                _ = g;
              default:
                g !== L && Ke(
                  r,
                  a,
                  p,
                  g,
                  u,
                  L
                );
            }
        a = z, s = _, u = K, q != null ? Pa(r, !!s, q, !1) : !!u != !!s && (a != null ? Pa(r, !!s, a, !0) : Pa(r, !!s, s ? [] : "", !1));
        return;
      case "textarea":
        K = q = null;
        for (z in s)
          if (p = s[z], s.hasOwnProperty(z) && p != null && !u.hasOwnProperty(z))
            switch (z) {
              case "value":
                break;
              case "children":
                break;
              default:
                Ke(r, a, z, null, u, p);
            }
        for (_ in u)
          if (p = u[_], g = s[_], u.hasOwnProperty(_) && (p != null || g != null))
            switch (_) {
              case "value":
                q = p;
                break;
              case "defaultValue":
                K = p;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (p != null) throw Error(o(91));
                break;
              default:
                p !== g && Ke(r, a, _, p, u, g);
            }
        xy(r, q, K);
        return;
      case "option":
        for (var ve in s)
          q = s[ve], s.hasOwnProperty(ve) && q != null && !u.hasOwnProperty(ve) && (ve === "selected" ? r.selected = !1 : Ke(
            r,
            a,
            ve,
            null,
            u,
            q
          ));
        for (L in u)
          q = u[L], K = s[L], u.hasOwnProperty(L) && q !== K && (q != null || K != null) && (L === "selected" ? r.selected = q && typeof q != "function" && typeof q != "symbol" : Ke(
            r,
            a,
            L,
            q,
            u,
            K
          ));
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var _e in s)
          q = s[_e], s.hasOwnProperty(_e) && q != null && !u.hasOwnProperty(_e) && Ke(r, a, _e, null, u, q);
        for (F in u)
          if (q = u[F], K = s[F], u.hasOwnProperty(F) && q !== K && (q != null || K != null))
            switch (F) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (q != null)
                  throw Error(o(137, a));
                break;
              default:
                Ke(
                  r,
                  a,
                  F,
                  q,
                  u,
                  K
                );
            }
        return;
      default:
        if (yd(a)) {
          for (var Je in s)
            q = s[Je], s.hasOwnProperty(Je) && q !== void 0 && !u.hasOwnProperty(Je) && op(
              r,
              a,
              Je,
              void 0,
              u,
              q
            );
          for (Q in u)
            q = u[Q], K = s[Q], !u.hasOwnProperty(Q) || q === K || q === void 0 && K === void 0 || op(
              r,
              a,
              Q,
              q,
              u,
              K
            );
          return;
        }
    }
    for (var B in s)
      q = s[B], s.hasOwnProperty(B) && q != null && !u.hasOwnProperty(B) && Ke(r, a, B, null, u, q);
    for (ae in u)
      q = u[ae], K = s[ae], !u.hasOwnProperty(ae) || q === K || q == null && K == null || Ke(r, a, ae, q, u, K);
  }
  function _x(r) {
    switch (r) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return !0;
      default:
        return !1;
    }
  }
  function TN() {
    if (typeof performance.getEntriesByType == "function") {
      for (var r = 0, a = 0, s = performance.getEntriesByType("resource"), u = 0; u < s.length; u++) {
        var p = s[u], g = p.transferSize, _ = p.initiatorType, z = p.duration;
        if (g && z && _x(_)) {
          for (_ = 0, z = p.responseEnd, u += 1; u < s.length; u++) {
            var L = s[u], F = L.startTime;
            if (F > z) break;
            var Q = L.transferSize, ae = L.initiatorType;
            Q && _x(ae) && (L = L.responseEnd, _ += Q * (L < z ? 1 : (z - F) / (L - F)));
          }
          if (--u, a += 8 * (g + _) / (p.duration / 1e3), r++, 10 < r) break;
        }
      }
      if (0 < r) return a / r / 1e6;
    }
    return navigator.connection && (r = navigator.connection.downlink, typeof r == "number") ? r : 5;
  }
  var ap = null, ip = null;
  function Qc(r) {
    return r.nodeType === 9 ? r : r.ownerDocument;
  }
  function Tx(r) {
    switch (r) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function Cx(r, a) {
    if (r === 0)
      switch (a) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return r === 1 && a === "foreignObject" ? 0 : r;
  }
  function sp(r, a) {
    return r === "textarea" || r === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.children == "bigint" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
  }
  var lp = null;
  function CN() {
    var r = window.event;
    return r && r.type === "popstate" ? r === lp ? !1 : (lp = r, !0) : (lp = null, !1);
  }
  var Ax = typeof setTimeout == "function" ? setTimeout : void 0, AN = typeof clearTimeout == "function" ? clearTimeout : void 0, Rx = typeof Promise == "function" ? Promise : void 0, RN = typeof queueMicrotask == "function" ? queueMicrotask : typeof Rx < "u" ? function(r) {
    return Rx.resolve(null).then(r).catch(MN);
  } : Ax;
  function MN(r) {
    setTimeout(function() {
      throw r;
    });
  }
  function mo(r) {
    return r === "head";
  }
  function Mx(r, a) {
    var s = a, u = 0;
    do {
      var p = s.nextSibling;
      if (r.removeChild(s), p && p.nodeType === 8)
        if (s = p.data, s === "/$" || s === "/&") {
          if (u === 0) {
            r.removeChild(p), pi(a);
            return;
          }
          u--;
        } else if (s === "$" || s === "$?" || s === "$~" || s === "$!" || s === "&")
          u++;
        else if (s === "html")
          Bs(r.ownerDocument.documentElement);
        else if (s === "head") {
          s = r.ownerDocument.head, Bs(s);
          for (var g = s.firstChild; g; ) {
            var _ = g.nextSibling, z = g.nodeName;
            g[as] || z === "SCRIPT" || z === "STYLE" || z === "LINK" && g.rel.toLowerCase() === "stylesheet" || s.removeChild(g), g = _;
          }
        } else
          s === "body" && Bs(r.ownerDocument.body);
      s = p;
    } while (s);
    pi(a);
  }
  function zx(r, a) {
    var s = r;
    r = 0;
    do {
      var u = s.nextSibling;
      if (s.nodeType === 1 ? a ? (s._stashedDisplay = s.style.display, s.style.display = "none") : (s.style.display = s._stashedDisplay || "", s.getAttribute("style") === "" && s.removeAttribute("style")) : s.nodeType === 3 && (a ? (s._stashedText = s.nodeValue, s.nodeValue = "") : s.nodeValue = s._stashedText || ""), u && u.nodeType === 8)
        if (s = u.data, s === "/$") {
          if (r === 0) break;
          r--;
        } else
          s !== "$" && s !== "$?" && s !== "$~" && s !== "$!" || r++;
      s = u;
    } while (s);
  }
  function cp(r) {
    var a = r.firstChild;
    for (a && a.nodeType === 10 && (a = a.nextSibling); a; ) {
      var s = a;
      switch (a = a.nextSibling, s.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          cp(s), pd(s);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (s.rel.toLowerCase() === "stylesheet") continue;
      }
      r.removeChild(s);
    }
  }
  function zN(r, a, s, u) {
    for (; r.nodeType === 1; ) {
      var p = s;
      if (r.nodeName.toLowerCase() !== a.toLowerCase()) {
        if (!u && (r.nodeName !== "INPUT" || r.type !== "hidden"))
          break;
      } else if (u) {
        if (!r[as])
          switch (a) {
            case "meta":
              if (!r.hasAttribute("itemprop")) break;
              return r;
            case "link":
              if (g = r.getAttribute("rel"), g === "stylesheet" && r.hasAttribute("data-precedence"))
                break;
              if (g !== p.rel || r.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || r.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || r.getAttribute("title") !== (p.title == null ? null : p.title))
                break;
              return r;
            case "style":
              if (r.hasAttribute("data-precedence")) break;
              return r;
            case "script":
              if (g = r.getAttribute("src"), (g !== (p.src == null ? null : p.src) || r.getAttribute("type") !== (p.type == null ? null : p.type) || r.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && g && r.hasAttribute("async") && !r.hasAttribute("itemprop"))
                break;
              return r;
            default:
              return r;
          }
      } else if (a === "input" && r.type === "hidden") {
        var g = p.name == null ? null : "" + p.name;
        if (p.type === "hidden" && r.getAttribute("name") === g)
          return r;
      } else return r;
      if (r = jn(r.nextSibling), r === null) break;
    }
    return null;
  }
  function DN(r, a, s) {
    if (a === "") return null;
    for (; r.nodeType !== 3; )
      if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !s || (r = jn(r.nextSibling), r === null)) return null;
    return r;
  }
  function Dx(r, a) {
    for (; r.nodeType !== 8; )
      if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !a || (r = jn(r.nextSibling), r === null)) return null;
    return r;
  }
  function up(r) {
    return r.data === "$?" || r.data === "$~";
  }
  function fp(r) {
    return r.data === "$!" || r.data === "$?" && r.ownerDocument.readyState !== "loading";
  }
  function NN(r, a) {
    var s = r.ownerDocument;
    if (r.data === "$~") r._reactRetry = a;
    else if (r.data !== "$?" || s.readyState !== "loading")
      a();
    else {
      var u = function() {
        a(), s.removeEventListener("DOMContentLoaded", u);
      };
      s.addEventListener("DOMContentLoaded", u), r._reactRetry = u;
    }
  }
  function jn(r) {
    for (; r != null; r = r.nextSibling) {
      var a = r.nodeType;
      if (a === 1 || a === 3) break;
      if (a === 8) {
        if (a = r.data, a === "$" || a === "$!" || a === "$?" || a === "$~" || a === "&" || a === "F!" || a === "F")
          break;
        if (a === "/$" || a === "/&") return null;
      }
    }
    return r;
  }
  var dp = null;
  function Nx(r) {
    r = r.nextSibling;
    for (var a = 0; r; ) {
      if (r.nodeType === 8) {
        var s = r.data;
        if (s === "/$" || s === "/&") {
          if (a === 0)
            return jn(r.nextSibling);
          a--;
        } else
          s !== "$" && s !== "$!" && s !== "$?" && s !== "$~" && s !== "&" || a++;
      }
      r = r.nextSibling;
    }
    return null;
  }
  function Ox(r) {
    r = r.previousSibling;
    for (var a = 0; r; ) {
      if (r.nodeType === 8) {
        var s = r.data;
        if (s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&") {
          if (a === 0) return r;
          a--;
        } else s !== "/$" && s !== "/&" || a++;
      }
      r = r.previousSibling;
    }
    return null;
  }
  function jx(r, a, s) {
    switch (a = Qc(s), r) {
      case "html":
        if (r = a.documentElement, !r) throw Error(o(452));
        return r;
      case "head":
        if (r = a.head, !r) throw Error(o(453));
        return r;
      case "body":
        if (r = a.body, !r) throw Error(o(454));
        return r;
      default:
        throw Error(o(451));
    }
  }
  function Bs(r) {
    for (var a = r.attributes; a.length; )
      r.removeAttributeNode(a[0]);
    pd(r);
  }
  var kn = /* @__PURE__ */ new Map(), kx = /* @__PURE__ */ new Set();
  function eu(r) {
    return typeof r.getRootNode == "function" ? r.getRootNode() : r.nodeType === 9 ? r : r.ownerDocument;
  }
  var Ur = G.d;
  G.d = {
    f: ON,
    r: jN,
    D: kN,
    C: PN,
    L: LN,
    m: IN,
    X: UN,
    S: VN,
    M: BN
  };
  function ON() {
    var r = Ur.f(), a = Fc();
    return r || a;
  }
  function jN(r) {
    var a = Oa(r);
    a !== null && a.tag === 5 && a.type === "form" ? J0(a) : Ur.r(r);
  }
  var fi = typeof document > "u" ? null : document;
  function Px(r, a, s) {
    var u = fi;
    if (u && typeof a == "string" && a) {
      var p = An(a);
      p = 'link[rel="' + r + '"][href="' + p + '"]', typeof s == "string" && (p += '[crossorigin="' + s + '"]'), kx.has(p) || (kx.add(p), r = { rel: r, crossOrigin: s, href: a }, u.querySelector(p) === null && (a = u.createElement("link"), Ut(a, "link", r), Ot(a), u.head.appendChild(a)));
    }
  }
  function kN(r) {
    Ur.D(r), Px("dns-prefetch", r, null);
  }
  function PN(r, a) {
    Ur.C(r, a), Px("preconnect", r, a);
  }
  function LN(r, a, s) {
    Ur.L(r, a, s);
    var u = fi;
    if (u && r && a) {
      var p = 'link[rel="preload"][as="' + An(a) + '"]';
      a === "image" && s && s.imageSrcSet ? (p += '[imagesrcset="' + An(
        s.imageSrcSet
      ) + '"]', typeof s.imageSizes == "string" && (p += '[imagesizes="' + An(
        s.imageSizes
      ) + '"]')) : p += '[href="' + An(r) + '"]';
      var g = p;
      switch (a) {
        case "style":
          g = di(r);
          break;
        case "script":
          g = hi(r);
      }
      kn.has(g) || (r = v(
        {
          rel: "preload",
          href: a === "image" && s && s.imageSrcSet ? void 0 : r,
          as: a
        },
        s
      ), kn.set(g, r), u.querySelector(p) !== null || a === "style" && u.querySelector($s(g)) || a === "script" && u.querySelector(Hs(g)) || (a = u.createElement("link"), Ut(a, "link", r), Ot(a), u.head.appendChild(a)));
    }
  }
  function IN(r, a) {
    Ur.m(r, a);
    var s = fi;
    if (s && r) {
      var u = a && typeof a.as == "string" ? a.as : "script", p = 'link[rel="modulepreload"][as="' + An(u) + '"][href="' + An(r) + '"]', g = p;
      switch (u) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          g = hi(r);
      }
      if (!kn.has(g) && (r = v({ rel: "modulepreload", href: r }, a), kn.set(g, r), s.querySelector(p) === null)) {
        switch (u) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (s.querySelector(Hs(g)))
              return;
        }
        u = s.createElement("link"), Ut(u, "link", r), Ot(u), s.head.appendChild(u);
      }
    }
  }
  function VN(r, a, s) {
    Ur.S(r, a, s);
    var u = fi;
    if (u && r) {
      var p = ja(u).hoistableStyles, g = di(r);
      a = a || "default";
      var _ = p.get(g);
      if (!_) {
        var z = { loading: 0, preload: null };
        if (_ = u.querySelector(
          $s(g)
        ))
          z.loading = 5;
        else {
          r = v(
            { rel: "stylesheet", href: r, "data-precedence": a },
            s
          ), (s = kn.get(g)) && hp(r, s);
          var L = _ = u.createElement("link");
          Ot(L), Ut(L, "link", r), L._p = new Promise(function(F, Q) {
            L.onload = F, L.onerror = Q;
          }), L.addEventListener("load", function() {
            z.loading |= 1;
          }), L.addEventListener("error", function() {
            z.loading |= 2;
          }), z.loading |= 4, tu(_, a, u);
        }
        _ = {
          type: "stylesheet",
          instance: _,
          count: 1,
          state: z
        }, p.set(g, _);
      }
    }
  }
  function UN(r, a) {
    Ur.X(r, a);
    var s = fi;
    if (s && r) {
      var u = ja(s).hoistableScripts, p = hi(r), g = u.get(p);
      g || (g = s.querySelector(Hs(p)), g || (r = v({ src: r, async: !0 }, a), (a = kn.get(p)) && pp(r, a), g = s.createElement("script"), Ot(g), Ut(g, "link", r), s.head.appendChild(g)), g = {
        type: "script",
        instance: g,
        count: 1,
        state: null
      }, u.set(p, g));
    }
  }
  function BN(r, a) {
    Ur.M(r, a);
    var s = fi;
    if (s && r) {
      var u = ja(s).hoistableScripts, p = hi(r), g = u.get(p);
      g || (g = s.querySelector(Hs(p)), g || (r = v({ src: r, async: !0, type: "module" }, a), (a = kn.get(p)) && pp(r, a), g = s.createElement("script"), Ot(g), Ut(g, "link", r), s.head.appendChild(g)), g = {
        type: "script",
        instance: g,
        count: 1,
        state: null
      }, u.set(p, g));
    }
  }
  function Lx(r, a, s, u) {
    var p = (p = ie.current) ? eu(p) : null;
    if (!p) throw Error(o(446));
    switch (r) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof s.precedence == "string" && typeof s.href == "string" ? (a = di(s.href), s = ja(
          p
        ).hoistableStyles, u = s.get(a), u || (u = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, s.set(a, u)), u) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (s.rel === "stylesheet" && typeof s.href == "string" && typeof s.precedence == "string") {
          r = di(s.href);
          var g = ja(
            p
          ).hoistableStyles, _ = g.get(r);
          if (_ || (p = p.ownerDocument || p, _ = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, g.set(r, _), (g = p.querySelector(
            $s(r)
          )) && !g._p && (_.instance = g, _.state.loading = 5), kn.has(r) || (s = {
            rel: "preload",
            as: "style",
            href: s.href,
            crossOrigin: s.crossOrigin,
            integrity: s.integrity,
            media: s.media,
            hrefLang: s.hrefLang,
            referrerPolicy: s.referrerPolicy
          }, kn.set(r, s), g || $N(
            p,
            r,
            s,
            _.state
          ))), a && u === null)
            throw Error(o(528, ""));
          return _;
        }
        if (a && u !== null)
          throw Error(o(529, ""));
        return null;
      case "script":
        return a = s.async, s = s.src, typeof s == "string" && a && typeof a != "function" && typeof a != "symbol" ? (a = hi(s), s = ja(
          p
        ).hoistableScripts, u = s.get(a), u || (u = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, s.set(a, u)), u) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(o(444, r));
    }
  }
  function di(r) {
    return 'href="' + An(r) + '"';
  }
  function $s(r) {
    return 'link[rel="stylesheet"][' + r + "]";
  }
  function Ix(r) {
    return v({}, r, {
      "data-precedence": r.precedence,
      precedence: null
    });
  }
  function $N(r, a, s, u) {
    r.querySelector('link[rel="preload"][as="style"][' + a + "]") ? u.loading = 1 : (a = r.createElement("link"), u.preload = a, a.addEventListener("load", function() {
      return u.loading |= 1;
    }), a.addEventListener("error", function() {
      return u.loading |= 2;
    }), Ut(a, "link", s), Ot(a), r.head.appendChild(a));
  }
  function hi(r) {
    return '[src="' + An(r) + '"]';
  }
  function Hs(r) {
    return "script[async]" + r;
  }
  function Vx(r, a, s) {
    if (a.count++, a.instance === null)
      switch (a.type) {
        case "style":
          var u = r.querySelector(
            'style[data-href~="' + An(s.href) + '"]'
          );
          if (u)
            return a.instance = u, Ot(u), u;
          var p = v({}, s, {
            "data-href": s.href,
            "data-precedence": s.precedence,
            href: null,
            precedence: null
          });
          return u = (r.ownerDocument || r).createElement(
            "style"
          ), Ot(u), Ut(u, "style", p), tu(u, s.precedence, r), a.instance = u;
        case "stylesheet":
          p = di(s.href);
          var g = r.querySelector(
            $s(p)
          );
          if (g)
            return a.state.loading |= 4, a.instance = g, Ot(g), g;
          u = Ix(s), (p = kn.get(p)) && hp(u, p), g = (r.ownerDocument || r).createElement("link"), Ot(g);
          var _ = g;
          return _._p = new Promise(function(z, L) {
            _.onload = z, _.onerror = L;
          }), Ut(g, "link", u), a.state.loading |= 4, tu(g, s.precedence, r), a.instance = g;
        case "script":
          return g = hi(s.src), (p = r.querySelector(
            Hs(g)
          )) ? (a.instance = p, Ot(p), p) : (u = s, (p = kn.get(g)) && (u = v({}, s), pp(u, p)), r = r.ownerDocument || r, p = r.createElement("script"), Ot(p), Ut(p, "link", u), r.head.appendChild(p), a.instance = p);
        case "void":
          return null;
        default:
          throw Error(o(443, a.type));
      }
    else
      a.type === "stylesheet" && (a.state.loading & 4) === 0 && (u = a.instance, a.state.loading |= 4, tu(u, s.precedence, r));
    return a.instance;
  }
  function tu(r, a, s) {
    for (var u = s.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), p = u.length ? u[u.length - 1] : null, g = p, _ = 0; _ < u.length; _++) {
      var z = u[_];
      if (z.dataset.precedence === a) g = z;
      else if (g !== p) break;
    }
    g ? g.parentNode.insertBefore(r, g.nextSibling) : (a = s.nodeType === 9 ? s.head : s, a.insertBefore(r, a.firstChild));
  }
  function hp(r, a) {
    r.crossOrigin == null && (r.crossOrigin = a.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy), r.title == null && (r.title = a.title);
  }
  function pp(r, a) {
    r.crossOrigin == null && (r.crossOrigin = a.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = a.referrerPolicy), r.integrity == null && (r.integrity = a.integrity);
  }
  var nu = null;
  function Ux(r, a, s) {
    if (nu === null) {
      var u = /* @__PURE__ */ new Map(), p = nu = /* @__PURE__ */ new Map();
      p.set(s, u);
    } else
      p = nu, u = p.get(s), u || (u = /* @__PURE__ */ new Map(), p.set(s, u));
    if (u.has(r)) return u;
    for (u.set(r, null), s = s.getElementsByTagName(r), p = 0; p < s.length; p++) {
      var g = s[p];
      if (!(g[as] || g[Pt] || r === "link" && g.getAttribute("rel") === "stylesheet") && g.namespaceURI !== "http://www.w3.org/2000/svg") {
        var _ = g.getAttribute(a) || "";
        _ = r + _;
        var z = u.get(_);
        z ? z.push(g) : u.set(_, [g]);
      }
    }
    return u;
  }
  function Bx(r, a, s) {
    r = r.ownerDocument || r, r.head.insertBefore(
      s,
      a === "title" ? r.querySelector("head > title") : null
    );
  }
  function HN(r, a, s) {
    if (s === 1 || a.itemProp != null) return !1;
    switch (r) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof a.precedence != "string" || typeof a.href != "string" || a.href === "")
          break;
        return !0;
      case "link":
        if (typeof a.rel != "string" || typeof a.href != "string" || a.href === "" || a.onLoad || a.onError)
          break;
        return a.rel === "stylesheet" ? (r = a.disabled, typeof a.precedence == "string" && r == null) : !0;
      case "script":
        if (a.async && typeof a.async != "function" && typeof a.async != "symbol" && !a.onLoad && !a.onError && a.src && typeof a.src == "string")
          return !0;
    }
    return !1;
  }
  function $x(r) {
    return !(r.type === "stylesheet" && (r.state.loading & 3) === 0);
  }
  function ZN(r, a, s, u) {
    if (s.type === "stylesheet" && (typeof u.media != "string" || matchMedia(u.media).matches !== !1) && (s.state.loading & 4) === 0) {
      if (s.instance === null) {
        var p = di(u.href), g = a.querySelector(
          $s(p)
        );
        if (g) {
          a = g._p, a !== null && typeof a == "object" && typeof a.then == "function" && (r.count++, r = ru.bind(r), a.then(r, r)), s.state.loading |= 4, s.instance = g, Ot(g);
          return;
        }
        g = a.ownerDocument || a, u = Ix(u), (p = kn.get(p)) && hp(u, p), g = g.createElement("link"), Ot(g);
        var _ = g;
        _._p = new Promise(function(z, L) {
          _.onload = z, _.onerror = L;
        }), Ut(g, "link", u), s.instance = g;
      }
      r.stylesheets === null && (r.stylesheets = /* @__PURE__ */ new Map()), r.stylesheets.set(s, a), (a = s.state.preload) && (s.state.loading & 3) === 0 && (r.count++, s = ru.bind(r), a.addEventListener("load", s), a.addEventListener("error", s));
    }
  }
  var mp = 0;
  function FN(r, a) {
    return r.stylesheets && r.count === 0 && au(r, r.stylesheets), 0 < r.count || 0 < r.imgCount ? function(s) {
      var u = setTimeout(function() {
        if (r.stylesheets && au(r, r.stylesheets), r.unsuspend) {
          var g = r.unsuspend;
          r.unsuspend = null, g();
        }
      }, 6e4 + a);
      0 < r.imgBytes && mp === 0 && (mp = 62500 * TN());
      var p = setTimeout(
        function() {
          if (r.waitingForImages = !1, r.count === 0 && (r.stylesheets && au(r, r.stylesheets), r.unsuspend)) {
            var g = r.unsuspend;
            r.unsuspend = null, g();
          }
        },
        (r.imgBytes > mp ? 50 : 800) + a
      );
      return r.unsuspend = s, function() {
        r.unsuspend = null, clearTimeout(u), clearTimeout(p);
      };
    } : null;
  }
  function ru() {
    if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
      if (this.stylesheets) au(this, this.stylesheets);
      else if (this.unsuspend) {
        var r = this.unsuspend;
        this.unsuspend = null, r();
      }
    }
  }
  var ou = null;
  function au(r, a) {
    r.stylesheets = null, r.unsuspend !== null && (r.count++, ou = /* @__PURE__ */ new Map(), a.forEach(GN, r), ou = null, ru.call(r));
  }
  function GN(r, a) {
    if (!(a.state.loading & 4)) {
      var s = ou.get(r);
      if (s) var u = s.get(null);
      else {
        s = /* @__PURE__ */ new Map(), ou.set(r, s);
        for (var p = r.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), g = 0; g < p.length; g++) {
          var _ = p[g];
          (_.nodeName === "LINK" || _.getAttribute("media") !== "not all") && (s.set(_.dataset.precedence, _), u = _);
        }
        u && s.set(null, u);
      }
      p = a.instance, _ = p.getAttribute("data-precedence"), g = s.get(_) || u, g === u && s.set(null, p), s.set(_, p), this.count++, u = ru.bind(this), p.addEventListener("load", u), p.addEventListener("error", u), g ? g.parentNode.insertBefore(p, g.nextSibling) : (r = r.nodeType === 9 ? r.head : r, r.insertBefore(p, r.firstChild)), a.state.loading |= 4;
    }
  }
  var Zs = {
    $$typeof: T,
    Provider: null,
    Consumer: null,
    _currentValue: U,
    _currentValue2: U,
    _threadCount: 0
  };
  function YN(r, a, s, u, p, g, _, z, L) {
    this.tag = 1, this.containerInfo = r, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ud(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ud(0), this.hiddenUpdates = ud(null), this.identifierPrefix = u, this.onUncaughtError = p, this.onCaughtError = g, this.onRecoverableError = _, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = L, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function Hx(r, a, s, u, p, g, _, z, L, F, Q, ae) {
    return r = new YN(
      r,
      a,
      s,
      _,
      L,
      F,
      Q,
      ae,
      z
    ), a = 1, g === !0 && (a |= 24), g = mn(3, null, null, a), r.current = g, g.stateNode = r, a = qd(), a.refCount++, r.pooledCache = a, a.refCount++, g.memoizedState = {
      element: u,
      isDehydrated: s,
      cache: a
    }, Jd(g), r;
  }
  function Zx(r) {
    return r ? (r = Za, r) : Za;
  }
  function Fx(r, a, s, u, p, g) {
    p = Zx(p), u.context === null ? u.context = p : u.pendingContext = p, u = ro(a), u.payload = { element: s }, g = g === void 0 ? null : g, g !== null && (u.callback = g), s = oo(r, u, a), s !== null && (sn(s, r, a), ws(s, r, a));
  }
  function Gx(r, a) {
    if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
      var s = r.retryLane;
      r.retryLane = s !== 0 && s < a ? s : a;
    }
  }
  function gp(r, a) {
    Gx(r, a), (r = r.alternate) && Gx(r, a);
  }
  function Yx(r) {
    if (r.tag === 13 || r.tag === 31) {
      var a = Xo(r, 67108864);
      a !== null && sn(a, r, 67108864), gp(r, 67108864);
    }
  }
  function qx(r) {
    if (r.tag === 13 || r.tag === 31) {
      var a = xn();
      a = fd(a);
      var s = Xo(r, a);
      s !== null && sn(s, r, a), gp(r, a);
    }
  }
  var iu = !0;
  function qN(r, a, s, u) {
    var p = I.T;
    I.T = null;
    var g = G.p;
    try {
      G.p = 2, vp(r, a, s, u);
    } finally {
      G.p = g, I.T = p;
    }
  }
  function WN(r, a, s, u) {
    var p = I.T;
    I.T = null;
    var g = G.p;
    try {
      G.p = 8, vp(r, a, s, u);
    } finally {
      G.p = g, I.T = p;
    }
  }
  function vp(r, a, s, u) {
    if (iu) {
      var p = yp(u);
      if (p === null)
        rp(
          r,
          a,
          u,
          su,
          s
        ), Xx(r, u);
      else if (KN(
        p,
        r,
        a,
        s,
        u
      ))
        u.stopPropagation();
      else if (Xx(r, u), a & 4 && -1 < XN.indexOf(r)) {
        for (; p !== null; ) {
          var g = Oa(p);
          if (g !== null)
            switch (g.tag) {
              case 3:
                if (g = g.stateNode, g.current.memoizedState.isDehydrated) {
                  var _ = Fo(g.pendingLanes);
                  if (_ !== 0) {
                    var z = g;
                    for (z.pendingLanes |= 2, z.entangledLanes |= 2; _; ) {
                      var L = 1 << 31 - hn(_);
                      z.entanglements[1] |= L, _ &= ~L;
                    }
                    ir(g), (Fe & 6) === 0 && (Hc = fn() + 500, Is(0));
                  }
                }
                break;
              case 31:
              case 13:
                z = Xo(g, 2), z !== null && sn(z, g, 2), Fc(), gp(g, 2);
            }
          if (g = yp(u), g === null && rp(
            r,
            a,
            u,
            su,
            s
          ), g === p) break;
          p = g;
        }
        p !== null && u.stopPropagation();
      } else
        rp(
          r,
          a,
          u,
          null,
          s
        );
    }
  }
  function yp(r) {
    return r = xd(r), bp(r);
  }
  var su = null;
  function bp(r) {
    if (su = null, r = Na(r), r !== null) {
      var a = l(r);
      if (a === null) r = null;
      else {
        var s = a.tag;
        if (s === 13) {
          if (r = c(a), r !== null) return r;
          r = null;
        } else if (s === 31) {
          if (r = f(a), r !== null) return r;
          r = null;
        } else if (s === 3) {
          if (a.stateNode.current.memoizedState.isDehydrated)
            return a.tag === 3 ? a.stateNode.containerInfo : null;
          r = null;
        } else a !== r && (r = null);
      }
    }
    return su = r, null;
  }
  function Wx(r) {
    switch (r) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (kz()) {
          case ry:
            return 2;
          case oy:
            return 8;
          case Xl:
          case Pz:
            return 32;
          case ay:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var xp = !1, go = null, vo = null, yo = null, Fs = /* @__PURE__ */ new Map(), Gs = /* @__PURE__ */ new Map(), bo = [], XN = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function Xx(r, a) {
    switch (r) {
      case "focusin":
      case "focusout":
        go = null;
        break;
      case "dragenter":
      case "dragleave":
        vo = null;
        break;
      case "mouseover":
      case "mouseout":
        yo = null;
        break;
      case "pointerover":
      case "pointerout":
        Fs.delete(a.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Gs.delete(a.pointerId);
    }
  }
  function Ys(r, a, s, u, p, g) {
    return r === null || r.nativeEvent !== g ? (r = {
      blockedOn: a,
      domEventName: s,
      eventSystemFlags: u,
      nativeEvent: g,
      targetContainers: [p]
    }, a !== null && (a = Oa(a), a !== null && Yx(a)), r) : (r.eventSystemFlags |= u, a = r.targetContainers, p !== null && a.indexOf(p) === -1 && a.push(p), r);
  }
  function KN(r, a, s, u, p) {
    switch (a) {
      case "focusin":
        return go = Ys(
          go,
          r,
          a,
          s,
          u,
          p
        ), !0;
      case "dragenter":
        return vo = Ys(
          vo,
          r,
          a,
          s,
          u,
          p
        ), !0;
      case "mouseover":
        return yo = Ys(
          yo,
          r,
          a,
          s,
          u,
          p
        ), !0;
      case "pointerover":
        var g = p.pointerId;
        return Fs.set(
          g,
          Ys(
            Fs.get(g) || null,
            r,
            a,
            s,
            u,
            p
          )
        ), !0;
      case "gotpointercapture":
        return g = p.pointerId, Gs.set(
          g,
          Ys(
            Gs.get(g) || null,
            r,
            a,
            s,
            u,
            p
          )
        ), !0;
    }
    return !1;
  }
  function Kx(r) {
    var a = Na(r.target);
    if (a !== null) {
      var s = l(a);
      if (s !== null) {
        if (a = s.tag, a === 13) {
          if (a = c(s), a !== null) {
            r.blockedOn = a, fy(r.priority, function() {
              qx(s);
            });
            return;
          }
        } else if (a === 31) {
          if (a = f(s), a !== null) {
            r.blockedOn = a, fy(r.priority, function() {
              qx(s);
            });
            return;
          }
        } else if (a === 3 && s.stateNode.current.memoizedState.isDehydrated) {
          r.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null;
          return;
        }
      }
    }
    r.blockedOn = null;
  }
  function lu(r) {
    if (r.blockedOn !== null) return !1;
    for (var a = r.targetContainers; 0 < a.length; ) {
      var s = yp(r.nativeEvent);
      if (s === null) {
        s = r.nativeEvent;
        var u = new s.constructor(
          s.type,
          s
        );
        bd = u, s.target.dispatchEvent(u), bd = null;
      } else
        return a = Oa(s), a !== null && Yx(a), r.blockedOn = s, !1;
      a.shift();
    }
    return !0;
  }
  function Jx(r, a, s) {
    lu(r) && s.delete(a);
  }
  function JN() {
    xp = !1, go !== null && lu(go) && (go = null), vo !== null && lu(vo) && (vo = null), yo !== null && lu(yo) && (yo = null), Fs.forEach(Jx), Gs.forEach(Jx);
  }
  function cu(r, a) {
    r.blockedOn === a && (r.blockedOn = null, xp || (xp = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      JN
    )));
  }
  var uu = null;
  function Qx(r) {
    uu !== r && (uu = r, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        uu === r && (uu = null);
        for (var a = 0; a < r.length; a += 3) {
          var s = r[a], u = r[a + 1], p = r[a + 2];
          if (typeof u != "function") {
            if (bp(u || s) === null)
              continue;
            break;
          }
          var g = Oa(s);
          g !== null && (r.splice(a, 3), a -= 3, yh(
            g,
            {
              pending: !0,
              data: p,
              method: s.method,
              action: u
            },
            u,
            p
          ));
        }
      }
    ));
  }
  function pi(r) {
    function a(L) {
      return cu(L, r);
    }
    go !== null && cu(go, r), vo !== null && cu(vo, r), yo !== null && cu(yo, r), Fs.forEach(a), Gs.forEach(a);
    for (var s = 0; s < bo.length; s++) {
      var u = bo[s];
      u.blockedOn === r && (u.blockedOn = null);
    }
    for (; 0 < bo.length && (s = bo[0], s.blockedOn === null); )
      Kx(s), s.blockedOn === null && bo.shift();
    if (s = (r.ownerDocument || r).$$reactFormReplay, s != null)
      for (u = 0; u < s.length; u += 3) {
        var p = s[u], g = s[u + 1], _ = p[en] || null;
        if (typeof g == "function")
          _ || Qx(s);
        else if (_) {
          var z = null;
          if (g && g.hasAttribute("formAction")) {
            if (p = g, _ = g[en] || null)
              z = _.formAction;
            else if (bp(p) !== null) continue;
          } else z = _.action;
          typeof z == "function" ? s[u + 1] = z : (s.splice(u, 3), u -= 3), Qx(s);
        }
      }
  }
  function eS() {
    function r(g) {
      g.canIntercept && g.info === "react-transition" && g.intercept({
        handler: function() {
          return new Promise(function(_) {
            return p = _;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function a() {
      p !== null && (p(), p = null), u || setTimeout(s, 20);
    }
    function s() {
      if (!u && !navigation.transition) {
        var g = navigation.currentEntry;
        g && g.url != null && navigation.navigate(g.url, {
          state: g.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if (typeof navigation == "object") {
      var u = !1, p = null;
      return navigation.addEventListener("navigate", r), navigation.addEventListener("navigatesuccess", a), navigation.addEventListener("navigateerror", a), setTimeout(s, 100), function() {
        u = !0, navigation.removeEventListener("navigate", r), navigation.removeEventListener("navigatesuccess", a), navigation.removeEventListener("navigateerror", a), p !== null && (p(), p = null);
      };
    }
  }
  function Sp(r) {
    this._internalRoot = r;
  }
  fu.prototype.render = Sp.prototype.render = function(r) {
    var a = this._internalRoot;
    if (a === null) throw Error(o(409));
    var s = a.current, u = xn();
    Fx(s, u, r, a, null, null);
  }, fu.prototype.unmount = Sp.prototype.unmount = function() {
    var r = this._internalRoot;
    if (r !== null) {
      this._internalRoot = null;
      var a = r.containerInfo;
      Fx(r.current, 2, null, r, null, null), Fc(), a[Da] = null;
    }
  };
  function fu(r) {
    this._internalRoot = r;
  }
  fu.prototype.unstable_scheduleHydration = function(r) {
    if (r) {
      var a = uy();
      r = { blockedOn: null, target: r, priority: a };
      for (var s = 0; s < bo.length && a !== 0 && a < bo[s].priority; s++) ;
      bo.splice(s, 0, r), s === 0 && Kx(r);
    }
  };
  var tS = t.version;
  if (tS !== "19.2.4")
    throw Error(
      o(
        527,
        tS,
        "19.2.4"
      )
    );
  G.findDOMNode = function(r) {
    var a = r._reactInternals;
    if (a === void 0)
      throw typeof r.render == "function" ? Error(o(188)) : (r = Object.keys(r).join(","), Error(o(268, r)));
    return r = h(a), r = r !== null ? m(r) : null, r = r === null ? null : r.stateNode, r;
  };
  var QN = {
    bundleType: 0,
    version: "19.2.4",
    rendererPackageName: "react-dom",
    currentDispatcherRef: I,
    reconcilerVersion: "19.2.4"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var du = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!du.isDisabled && du.supportsFiber)
      try {
        ns = du.inject(
          QN
        ), dn = du;
      } catch {
      }
  }
  return qs.createRoot = function(r, a) {
    if (!i(r)) throw Error(o(299));
    var s = !1, u = "", p = lb, g = cb, _ = ub;
    return a != null && (a.unstable_strictMode === !0 && (s = !0), a.identifierPrefix !== void 0 && (u = a.identifierPrefix), a.onUncaughtError !== void 0 && (p = a.onUncaughtError), a.onCaughtError !== void 0 && (g = a.onCaughtError), a.onRecoverableError !== void 0 && (_ = a.onRecoverableError)), a = Hx(
      r,
      1,
      !1,
      null,
      null,
      s,
      u,
      null,
      p,
      g,
      _,
      eS
    ), r[Da] = a.current, np(r), new Sp(a);
  }, qs.hydrateRoot = function(r, a, s) {
    if (!i(r)) throw Error(o(299));
    var u = !1, p = "", g = lb, _ = cb, z = ub, L = null;
    return s != null && (s.unstable_strictMode === !0 && (u = !0), s.identifierPrefix !== void 0 && (p = s.identifierPrefix), s.onUncaughtError !== void 0 && (g = s.onUncaughtError), s.onCaughtError !== void 0 && (_ = s.onCaughtError), s.onRecoverableError !== void 0 && (z = s.onRecoverableError), s.formState !== void 0 && (L = s.formState)), a = Hx(
      r,
      1,
      !0,
      a,
      s ?? null,
      u,
      p,
      L,
      g,
      _,
      z,
      eS
    ), a.context = Zx(null), s = a.current, u = xn(), u = fd(u), p = ro(u), p.callback = null, oo(s, p, u), s = u, a.current.lanes = s, os(a, s), ir(a), r[Da] = a.current, np(r), new fu(a);
  }, qs.version = "19.2.4", qs;
}
var cS;
function lO() {
  if (cS) return Ep.exports;
  cS = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Ep.exports = sO(), Ep.exports;
}
var cO = lO();
const uO = /* @__PURE__ */ jl(cO);
var Ap = { exports: {} }, Ws = {};
var uS;
function fO() {
  if (uS) return Ws;
  uS = 1;
  var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
  function n(o, i, l) {
    var c = null;
    if (l !== void 0 && (c = "" + l), i.key !== void 0 && (c = "" + i.key), "key" in i) {
      l = {};
      for (var f in i)
        f !== "key" && (l[f] = i[f]);
    } else l = i;
    return i = l.ref, {
      $$typeof: e,
      type: o,
      key: c,
      ref: i !== void 0 ? i : null,
      props: l
    };
  }
  return Ws.Fragment = t, Ws.jsx = n, Ws.jsxs = n, Ws;
}
var fS;
function dO() {
  return fS || (fS = 1, Ap.exports = fO()), Ap.exports;
}
var S = dO(), Vo = Cf();
const hO = /* @__PURE__ */ jl(Vo);
var Xs = { exports: {} }, Rp = {}, Mp = { exports: {} }, zp, dS;
function pO() {
  if (dS) return zp;
  dS = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return zp = e, zp;
}
var Dp, hS;
function mO() {
  if (hS) return Dp;
  hS = 1;
  var e = /* @__PURE__ */ pO();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Dp = function() {
    function o(c, f, d, h, m, v) {
      if (v !== e) {
        var b = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw b.name = "Invariant Violation", b;
      }
    }
    o.isRequired = o;
    function i() {
      return o;
    }
    var l = {
      array: o,
      bigint: o,
      bool: o,
      func: o,
      number: o,
      object: o,
      string: o,
      symbol: o,
      any: o,
      arrayOf: i,
      element: o,
      elementType: o,
      instanceOf: i,
      node: o,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return l.PropTypes = l, l;
  }, Dp;
}
var pS;
function DE() {
  return pS || (pS = 1, Mp.exports = /* @__PURE__ */ mO()()), Mp.exports;
}
function NE(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = NE(e[t])) && (o && (o += " "), o += n);
  else for (t in e) e[t] && (o && (o += " "), o += t);
  return o;
}
function mS() {
  for (var e, t, n = 0, o = ""; n < arguments.length; ) (e = arguments[n++]) && (t = NE(e)) && (o && (o += " "), o += t);
  return o;
}
const gO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: mS,
  default: mS
}, Symbol.toStringTag, { value: "Module" })), vO = /* @__PURE__ */ nO(gO);
var St = {}, So = {}, gS;
function Af() {
  if (gS) return So;
  gS = 1, Object.defineProperty(So, "__esModule", {
    value: !0
  }), So.dontSetMe = i, So.findInArray = e, So.int = o, So.isFunction = t, So.isNum = n;
  function e(l, c) {
    for (let f = 0, d = l.length; f < d; f++)
      if (c.apply(c, [l[f], f, l])) return l[f];
  }
  function t(l) {
    return typeof l == "function" || Object.prototype.toString.call(l) === "[object Function]";
  }
  function n(l) {
    return typeof l == "number" && !isNaN(l);
  }
  function o(l) {
    return parseInt(l, 10);
  }
  function i(l, c, f) {
    if (l[c])
      return new Error("Invalid prop ".concat(c, " passed to ").concat(f, " - do not set this, set it on the child."));
  }
  return So;
}
var wo = {}, vS;
function yO() {
  if (vS) return wo;
  vS = 1, Object.defineProperty(wo, "__esModule", {
    value: !0
  }), wo.browserPrefixToKey = n, wo.browserPrefixToStyle = o, wo.default = void 0, wo.getPrefix = t;
  const e = ["Moz", "Webkit", "O", "ms"];
  function t() {
    var l;
    let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
    if (typeof window > "u") return "";
    const f = (l = window.document) === null || l === void 0 || (l = l.documentElement) === null || l === void 0 ? void 0 : l.style;
    if (!f || c in f) return "";
    for (let d = 0; d < e.length; d++)
      if (n(c, e[d]) in f) return e[d];
    return "";
  }
  function n(l, c) {
    return c ? "".concat(c).concat(i(l)) : l;
  }
  function o(l, c) {
    return c ? "-".concat(c.toLowerCase(), "-").concat(l) : l;
  }
  function i(l) {
    let c = "", f = !0;
    for (let d = 0; d < l.length; d++)
      f ? (c += l[d].toUpperCase(), f = !1) : l[d] === "-" ? f = !0 : c += l[d];
    return c;
  }
  return wo.default = t(), wo;
}
var yS;
function Eg() {
  if (yS) return St;
  yS = 1, Object.defineProperty(St, "__esModule", {
    value: !0
  }), St.addClassName = O, St.addEvent = f, St.addUserSelectStyles = T, St.createCSSTransform = E, St.createSVGTransform = w, St.getTouch = A, St.getTouchIdentifier = M, St.getTranslation = C, St.innerHeight = v, St.innerWidth = b, St.matchesSelector = l, St.matchesSelectorAndParentsTo = c, St.offsetXYFromParent = x, St.outerHeight = h, St.outerWidth = m, St.removeClassName = k, St.removeEvent = d, St.removeUserSelectStyles = D;
  var e = Af(), t = o(yO());
  function n(R) {
    if (typeof WeakMap != "function") return null;
    var N = /* @__PURE__ */ new WeakMap(), P = /* @__PURE__ */ new WeakMap();
    return (n = function(Y) {
      return Y ? P : N;
    })(R);
  }
  function o(R, N) {
    if (R && R.__esModule)
      return R;
    if (R === null || typeof R != "object" && typeof R != "function")
      return { default: R };
    var P = n(N);
    if (P && P.has(R))
      return P.get(R);
    var Y = {}, ne = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var J in R)
      if (J !== "default" && Object.prototype.hasOwnProperty.call(R, J)) {
        var ce = ne ? Object.getOwnPropertyDescriptor(R, J) : null;
        ce && (ce.get || ce.set) ? Object.defineProperty(Y, J, ce) : Y[J] = R[J];
      }
    return Y.default = R, P && P.set(R, Y), Y;
  }
  let i = "";
  function l(R, N) {
    return i || (i = (0, e.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(P) {
      return (0, e.isFunction)(R[P]);
    })), (0, e.isFunction)(R[i]) ? R[i](N) : !1;
  }
  function c(R, N, P) {
    let Y = R;
    do {
      if (l(Y, N)) return !0;
      if (Y === P) return !1;
      Y = Y.parentNode;
    } while (Y);
    return !1;
  }
  function f(R, N, P, Y) {
    if (!R) return;
    const ne = {
      capture: !0,
      ...Y
    };
    R.addEventListener ? R.addEventListener(N, P, ne) : R.attachEvent ? R.attachEvent("on" + N, P) : R["on" + N] = P;
  }
  function d(R, N, P, Y) {
    if (!R) return;
    const ne = {
      capture: !0,
      ...Y
    };
    R.removeEventListener ? R.removeEventListener(N, P, ne) : R.detachEvent ? R.detachEvent("on" + N, P) : R["on" + N] = null;
  }
  function h(R) {
    let N = R.clientHeight;
    const P = R.ownerDocument.defaultView.getComputedStyle(R);
    return N += (0, e.int)(P.borderTopWidth), N += (0, e.int)(P.borderBottomWidth), N;
  }
  function m(R) {
    let N = R.clientWidth;
    const P = R.ownerDocument.defaultView.getComputedStyle(R);
    return N += (0, e.int)(P.borderLeftWidth), N += (0, e.int)(P.borderRightWidth), N;
  }
  function v(R) {
    let N = R.clientHeight;
    const P = R.ownerDocument.defaultView.getComputedStyle(R);
    return N -= (0, e.int)(P.paddingTop), N -= (0, e.int)(P.paddingBottom), N;
  }
  function b(R) {
    let N = R.clientWidth;
    const P = R.ownerDocument.defaultView.getComputedStyle(R);
    return N -= (0, e.int)(P.paddingLeft), N -= (0, e.int)(P.paddingRight), N;
  }
  function x(R, N, P) {
    const ne = N === N.ownerDocument.body ? {
      left: 0,
      top: 0
    } : N.getBoundingClientRect(), J = (R.clientX + N.scrollLeft - ne.left) / P, ce = (R.clientY + N.scrollTop - ne.top) / P;
    return {
      x: J,
      y: ce
    };
  }
  function E(R, N) {
    const P = C(R, N, "px");
    return {
      [(0, t.browserPrefixToKey)("transform", t.default)]: P
    };
  }
  function w(R, N) {
    return C(R, N, "");
  }
  function C(R, N, P) {
    let {
      x: Y,
      y: ne
    } = R, J = "translate(".concat(Y).concat(P, ",").concat(ne).concat(P, ")");
    if (N) {
      const ce = "".concat(typeof N.x == "string" ? N.x : N.x + P), ue = "".concat(typeof N.y == "string" ? N.y : N.y + P);
      J = "translate(".concat(ce, ", ").concat(ue, ")") + J;
    }
    return J;
  }
  function A(R, N) {
    return R.targetTouches && (0, e.findInArray)(R.targetTouches, (P) => N === P.identifier) || R.changedTouches && (0, e.findInArray)(R.changedTouches, (P) => N === P.identifier);
  }
  function M(R) {
    if (R.targetTouches && R.targetTouches[0]) return R.targetTouches[0].identifier;
    if (R.changedTouches && R.changedTouches[0]) return R.changedTouches[0].identifier;
  }
  function T(R) {
    if (!R) return;
    let N = R.getElementById("react-draggable-style-el");
    N || (N = R.createElement("style"), N.type = "text/css", N.id = "react-draggable-style-el", N.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, N.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, R.getElementsByTagName("head")[0].appendChild(N)), R.body && O(R.body, "react-draggable-transparent-selection");
  }
  function D(R) {
    if (R)
      try {
        if (R.body && k(R.body, "react-draggable-transparent-selection"), R.selection)
          R.selection.empty();
        else {
          const N = (R.defaultView || window).getSelection();
          N && N.type !== "Caret" && N.removeAllRanges();
        }
      } catch {
      }
  }
  function O(R, N) {
    R.classList ? R.classList.add(N) : R.className.match(new RegExp("(?:^|\\s)".concat(N, "(?!\\S)"))) || (R.className += " ".concat(N));
  }
  function k(R, N) {
    R.classList ? R.classList.remove(N) : R.className = R.className.replace(new RegExp("(?:^|\\s)".concat(N, "(?!\\S)"), "g"), "");
  }
  return St;
}
var sr = {}, bS;
function OE() {
  if (bS) return sr;
  bS = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.canDragX = i, sr.canDragY = l, sr.createCoreData = f, sr.createDraggableData = d, sr.getBoundPosition = n, sr.getControlPosition = c, sr.snapToGrid = o;
  var e = Af(), t = Eg();
  function n(v, b, x) {
    if (!v.props.bounds) return [b, x];
    let {
      bounds: E
    } = v.props;
    E = typeof E == "string" ? E : h(E);
    const w = m(v);
    if (typeof E == "string") {
      const {
        ownerDocument: C
      } = w, A = C.defaultView;
      let M;
      if (E === "parent" ? M = w.parentNode : M = C.querySelector(E), !(M instanceof A.HTMLElement))
        throw new Error('Bounds selector "' + E + '" could not find an element.');
      const T = M, D = A.getComputedStyle(w), O = A.getComputedStyle(T);
      E = {
        left: -w.offsetLeft + (0, e.int)(O.paddingLeft) + (0, e.int)(D.marginLeft),
        top: -w.offsetTop + (0, e.int)(O.paddingTop) + (0, e.int)(D.marginTop),
        right: (0, t.innerWidth)(T) - (0, t.outerWidth)(w) - w.offsetLeft + (0, e.int)(O.paddingRight) - (0, e.int)(D.marginRight),
        bottom: (0, t.innerHeight)(T) - (0, t.outerHeight)(w) - w.offsetTop + (0, e.int)(O.paddingBottom) - (0, e.int)(D.marginBottom)
      };
    }
    return (0, e.isNum)(E.right) && (b = Math.min(b, E.right)), (0, e.isNum)(E.bottom) && (x = Math.min(x, E.bottom)), (0, e.isNum)(E.left) && (b = Math.max(b, E.left)), (0, e.isNum)(E.top) && (x = Math.max(x, E.top)), [b, x];
  }
  function o(v, b, x) {
    const E = Math.round(b / v[0]) * v[0], w = Math.round(x / v[1]) * v[1];
    return [E, w];
  }
  function i(v) {
    return v.props.axis === "both" || v.props.axis === "x";
  }
  function l(v) {
    return v.props.axis === "both" || v.props.axis === "y";
  }
  function c(v, b, x) {
    const E = typeof b == "number" ? (0, t.getTouch)(v, b) : null;
    if (typeof b == "number" && !E) return null;
    const w = m(x), C = x.props.offsetParent || w.offsetParent || w.ownerDocument.body;
    return (0, t.offsetXYFromParent)(E || v, C, x.props.scale);
  }
  function f(v, b, x) {
    const E = !(0, e.isNum)(v.lastX), w = m(v);
    return E ? {
      node: w,
      deltaX: 0,
      deltaY: 0,
      lastX: b,
      lastY: x,
      x: b,
      y: x
    } : {
      node: w,
      deltaX: b - v.lastX,
      deltaY: x - v.lastY,
      lastX: v.lastX,
      lastY: v.lastY,
      x: b,
      y: x
    };
  }
  function d(v, b) {
    const x = v.props.scale;
    return {
      node: b.node,
      x: v.state.x + b.deltaX / x,
      y: v.state.y + b.deltaY / x,
      deltaX: b.deltaX / x,
      deltaY: b.deltaY / x,
      lastX: v.state.x,
      lastY: v.state.y
    };
  }
  function h(v) {
    return {
      left: v.left,
      top: v.top,
      right: v.right,
      bottom: v.bottom
    };
  }
  function m(v) {
    const b = v.findDOMNode();
    if (!b)
      throw new Error("<DraggableCore>: Unmounted during event!");
    return b;
  }
  return sr;
}
var Ks = {}, hu = {}, xS;
function jE() {
  if (xS) return hu;
  xS = 1, Object.defineProperty(hu, "__esModule", {
    value: !0
  }), hu.default = e;
  function e() {
  }
  return hu;
}
var SS;
function bO() {
  if (SS) return Ks;
  SS = 1, Object.defineProperty(Ks, "__esModule", {
    value: !0
  }), Ks.default = void 0;
  var e = h(kl()), t = f(/* @__PURE__ */ DE()), n = f(Cf()), o = Eg(), i = OE(), l = Af(), c = f(jE());
  function f(C) {
    return C && C.__esModule ? C : { default: C };
  }
  function d(C) {
    if (typeof WeakMap != "function") return null;
    var A = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap();
    return (d = function(T) {
      return T ? M : A;
    })(C);
  }
  function h(C, A) {
    if (C && C.__esModule)
      return C;
    if (C === null || typeof C != "object" && typeof C != "function")
      return { default: C };
    var M = d(A);
    if (M && M.has(C))
      return M.get(C);
    var T = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var O in C)
      if (O !== "default" && Object.prototype.hasOwnProperty.call(C, O)) {
        var k = D ? Object.getOwnPropertyDescriptor(C, O) : null;
        k && (k.get || k.set) ? Object.defineProperty(T, O, k) : T[O] = C[O];
      }
    return T.default = C, M && M.set(C, T), T;
  }
  function m(C, A, M) {
    return A = v(A), A in C ? Object.defineProperty(C, A, { value: M, enumerable: !0, configurable: !0, writable: !0 }) : C[A] = M, C;
  }
  function v(C) {
    var A = b(C, "string");
    return typeof A == "symbol" ? A : String(A);
  }
  function b(C, A) {
    if (typeof C != "object" || C === null) return C;
    var M = C[Symbol.toPrimitive];
    if (M !== void 0) {
      var T = M.call(C, A);
      if (typeof T != "object") return T;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (A === "string" ? String : Number)(C);
  }
  const x = {
    touch: {
      start: "touchstart",
      move: "touchmove",
      stop: "touchend"
    },
    mouse: {
      start: "mousedown",
      move: "mousemove",
      stop: "mouseup"
    }
  };
  let E = x.mouse, w = class extends e.Component {
    constructor() {
      super(...arguments), m(this, "dragging", !1), m(this, "lastX", NaN), m(this, "lastY", NaN), m(this, "touchIdentifier", null), m(this, "mounted", !1), m(this, "handleDragStart", (A) => {
        if (this.props.onMouseDown(A), !this.props.allowAnyClick && typeof A.button == "number" && A.button !== 0) return !1;
        const M = this.findDOMNode();
        if (!M || !M.ownerDocument || !M.ownerDocument.body)
          throw new Error("<DraggableCore> not mounted on DragStart!");
        const {
          ownerDocument: T
        } = M;
        if (this.props.disabled || !(A.target instanceof T.defaultView.Node) || this.props.handle && !(0, o.matchesSelectorAndParentsTo)(A.target, this.props.handle, M) || this.props.cancel && (0, o.matchesSelectorAndParentsTo)(A.target, this.props.cancel, M))
          return;
        A.type === "touchstart" && A.preventDefault();
        const D = (0, o.getTouchIdentifier)(A);
        this.touchIdentifier = D;
        const O = (0, i.getControlPosition)(A, D, this);
        if (O == null) return;
        const {
          x: k,
          y: R
        } = O, N = (0, i.createCoreData)(this, k, R);
        (0, c.default)("DraggableCore: handleDragStart: %j", N), (0, c.default)("calling", this.props.onStart), !(this.props.onStart(A, N) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, o.addUserSelectStyles)(T), this.dragging = !0, this.lastX = k, this.lastY = R, (0, o.addEvent)(T, E.move, this.handleDrag), (0, o.addEvent)(T, E.stop, this.handleDragStop));
      }), m(this, "handleDrag", (A) => {
        const M = (0, i.getControlPosition)(A, this.touchIdentifier, this);
        if (M == null) return;
        let {
          x: T,
          y: D
        } = M;
        if (Array.isArray(this.props.grid)) {
          let R = T - this.lastX, N = D - this.lastY;
          if ([R, N] = (0, i.snapToGrid)(this.props.grid, R, N), !R && !N) return;
          T = this.lastX + R, D = this.lastY + N;
        }
        const O = (0, i.createCoreData)(this, T, D);
        if ((0, c.default)("DraggableCore: handleDrag: %j", O), this.props.onDrag(A, O) === !1 || this.mounted === !1) {
          try {
            this.handleDragStop(new MouseEvent("mouseup"));
          } catch {
            const N = document.createEvent("MouseEvents");
            N.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(N);
          }
          return;
        }
        this.lastX = T, this.lastY = D;
      }), m(this, "handleDragStop", (A) => {
        if (!this.dragging) return;
        const M = (0, i.getControlPosition)(A, this.touchIdentifier, this);
        if (M == null) return;
        let {
          x: T,
          y: D
        } = M;
        if (Array.isArray(this.props.grid)) {
          let N = T - this.lastX || 0, P = D - this.lastY || 0;
          [N, P] = (0, i.snapToGrid)(this.props.grid, N, P), T = this.lastX + N, D = this.lastY + P;
        }
        const O = (0, i.createCoreData)(this, T, D);
        if (this.props.onStop(A, O) === !1 || this.mounted === !1) return !1;
        const R = this.findDOMNode();
        R && this.props.enableUserSelectHack && (0, o.removeUserSelectStyles)(R.ownerDocument), (0, c.default)("DraggableCore: handleDragStop: %j", O), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, R && ((0, c.default)("DraggableCore: Removing handlers"), (0, o.removeEvent)(R.ownerDocument, E.move, this.handleDrag), (0, o.removeEvent)(R.ownerDocument, E.stop, this.handleDragStop));
      }), m(this, "onMouseDown", (A) => (E = x.mouse, this.handleDragStart(A))), m(this, "onMouseUp", (A) => (E = x.mouse, this.handleDragStop(A))), m(this, "onTouchStart", (A) => (E = x.touch, this.handleDragStart(A))), m(this, "onTouchEnd", (A) => (E = x.touch, this.handleDragStop(A)));
    }
    componentDidMount() {
      this.mounted = !0;
      const A = this.findDOMNode();
      A && (0, o.addEvent)(A, x.touch.start, this.onTouchStart, {
        passive: !1
      });
    }
    componentWillUnmount() {
      this.mounted = !1;
      const A = this.findDOMNode();
      if (A) {
        const {
          ownerDocument: M
        } = A;
        (0, o.removeEvent)(M, x.mouse.move, this.handleDrag), (0, o.removeEvent)(M, x.touch.move, this.handleDrag), (0, o.removeEvent)(M, x.mouse.stop, this.handleDragStop), (0, o.removeEvent)(M, x.touch.stop, this.handleDragStop), (0, o.removeEvent)(A, x.touch.start, this.onTouchStart, {
          passive: !1
        }), this.props.enableUserSelectHack && (0, o.removeUserSelectStyles)(M);
      }
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var A, M;
      return (A = this.props) !== null && A !== void 0 && A.nodeRef ? (M = this.props) === null || M === void 0 || (M = M.nodeRef) === null || M === void 0 ? void 0 : M.current : n.default.findDOMNode(this);
    }
    render() {
      return /* @__PURE__ */ e.cloneElement(e.Children.only(this.props.children), {
        // Note: mouseMove handler is attached to document so it will still function
        // when the user drags quickly and leaves the bounds of the element.
        onMouseDown: this.onMouseDown,
        onMouseUp: this.onMouseUp,
        // onTouchStart is added on `componentDidMount` so they can be added with
        // {passive: false}, which allows it to cancel. See
        // https://developers.google.com/web/updates/2017/01/scrolling-intervention
        onTouchEnd: this.onTouchEnd
      });
    }
  };
  return Ks.default = w, m(w, "displayName", "DraggableCore"), m(w, "propTypes", {
    /**
     * `allowAnyClick` allows dragging using any mouse button.
     * By default, we only accept the left button.
     *
     * Defaults to `false`.
     */
    allowAnyClick: t.default.bool,
    children: t.default.node.isRequired,
    /**
     * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
     * with the exception of `onMouseDown`, will not fire.
     */
    disabled: t.default.bool,
    /**
     * By default, we add 'user-select:none' attributes to the document body
     * to prevent ugly text selection during drag. If this is causing problems
     * for your app, set this to `false`.
     */
    enableUserSelectHack: t.default.bool,
    /**
     * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
     * instead of using the parent node.
     */
    offsetParent: function(C, A) {
      if (C[A] && C[A].nodeType !== 1)
        throw new Error("Draggable's offsetParent must be a DOM Node.");
    },
    /**
     * `grid` specifies the x and y that dragging should snap to.
     */
    grid: t.default.arrayOf(t.default.number),
    /**
     * `handle` specifies a selector to be used as the handle that initiates drag.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable handle=".handle">
     *              <div>
     *                  <div className="handle">Click me to drag</div>
     *                  <div>This is some other content</div>
     *              </div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    handle: t.default.string,
    /**
     * `cancel` specifies a selector to be used to prevent drag initialization.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *           return(
     *               <Draggable cancel=".cancel">
     *                   <div>
     *                     <div className="cancel">You can't drag from here</div>
     *                     <div>Dragging here works fine</div>
     *                   </div>
     *               </Draggable>
     *           );
     *       }
     *   });
     * ```
     */
    cancel: t.default.string,
    /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
     * Unfortunately, in order for <Draggable> to work properly, we need raw access
     * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
     * as in this example:
     *
     * function MyComponent() {
     *   const nodeRef = React.useRef(null);
     *   return (
     *     <Draggable nodeRef={nodeRef}>
     *       <div ref={nodeRef}>Example Target</div>
     *     </Draggable>
     *   );
     * }
     *
     * This can be used for arbitrarily nested components, so long as the ref ends up
     * pointing to the actual child DOM node and not a custom component.
     */
    nodeRef: t.default.object,
    /**
     * Called when dragging starts.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onStart: t.default.func,
    /**
     * Called while dragging.
     * If this function returns the boolean false, dragging will be canceled.
     */
    onDrag: t.default.func,
    /**
     * Called when dragging stops.
     * If this function returns the boolean false, the drag will remain active.
     */
    onStop: t.default.func,
    /**
     * A workaround option which can be passed if onMouseDown needs to be accessed,
     * since it'll always be blocked (as there is internal use of onMouseDown)
     */
    onMouseDown: t.default.func,
    /**
     * `scale`, if set, applies scaling while dragging an element
     */
    scale: t.default.number,
    /**
     * These properties should be defined on the child, not here.
     */
    className: l.dontSetMe,
    style: l.dontSetMe,
    transform: l.dontSetMe
  }), m(w, "defaultProps", {
    allowAnyClick: !1,
    // by default only accept left click
    disabled: !1,
    enableUserSelectHack: !0,
    onStart: function() {
    },
    onDrag: function() {
    },
    onStop: function() {
    },
    onMouseDown: function() {
    },
    scale: 1
  }), Ks;
}
var wS;
function xO() {
  return wS || (wS = 1, (function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DraggableCore", {
      enumerable: !0,
      get: function() {
        return d.default;
      }
    }), e.default = void 0;
    var t = b(kl()), n = m(/* @__PURE__ */ DE()), o = m(Cf()), i = m(vO), l = Eg(), c = OE(), f = Af(), d = m(bO()), h = m(jE());
    function m(M) {
      return M && M.__esModule ? M : { default: M };
    }
    function v(M) {
      if (typeof WeakMap != "function") return null;
      var T = /* @__PURE__ */ new WeakMap(), D = /* @__PURE__ */ new WeakMap();
      return (v = function(O) {
        return O ? D : T;
      })(M);
    }
    function b(M, T) {
      if (M && M.__esModule)
        return M;
      if (M === null || typeof M != "object" && typeof M != "function")
        return { default: M };
      var D = v(T);
      if (D && D.has(M))
        return D.get(M);
      var O = {}, k = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var R in M)
        if (R !== "default" && Object.prototype.hasOwnProperty.call(M, R)) {
          var N = k ? Object.getOwnPropertyDescriptor(M, R) : null;
          N && (N.get || N.set) ? Object.defineProperty(O, R, N) : O[R] = M[R];
        }
      return O.default = M, D && D.set(M, O), O;
    }
    function x() {
      return x = Object.assign ? Object.assign.bind() : function(M) {
        for (var T = 1; T < arguments.length; T++) {
          var D = arguments[T];
          for (var O in D)
            Object.prototype.hasOwnProperty.call(D, O) && (M[O] = D[O]);
        }
        return M;
      }, x.apply(this, arguments);
    }
    function E(M, T, D) {
      return T = w(T), T in M ? Object.defineProperty(M, T, { value: D, enumerable: !0, configurable: !0, writable: !0 }) : M[T] = D, M;
    }
    function w(M) {
      var T = C(M, "string");
      return typeof T == "symbol" ? T : String(T);
    }
    function C(M, T) {
      if (typeof M != "object" || M === null) return M;
      var D = M[Symbol.toPrimitive];
      if (D !== void 0) {
        var O = D.call(M, T);
        if (typeof O != "object") return O;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (T === "string" ? String : Number)(M);
    }
    class A extends t.Component {
      // React 16.3+
      // Arity (props, state)
      static getDerivedStateFromProps(T, D) {
        let {
          position: O
        } = T, {
          prevPropsPosition: k
        } = D;
        return O && (!k || O.x !== k.x || O.y !== k.y) ? ((0, h.default)("Draggable: getDerivedStateFromProps %j", {
          position: O,
          prevPropsPosition: k
        }), {
          x: O.x,
          y: O.y,
          prevPropsPosition: {
            ...O
          }
        }) : null;
      }
      constructor(T) {
        super(T), E(this, "onDragStart", (D, O) => {
          if ((0, h.default)("Draggable: onDragStart: %j", O), this.props.onStart(D, (0, c.createDraggableData)(this, O)) === !1) return !1;
          this.setState({
            dragging: !0,
            dragged: !0
          });
        }), E(this, "onDrag", (D, O) => {
          if (!this.state.dragging) return !1;
          (0, h.default)("Draggable: onDrag: %j", O);
          const k = (0, c.createDraggableData)(this, O), R = {
            x: k.x,
            y: k.y,
            slackX: 0,
            slackY: 0
          };
          if (this.props.bounds) {
            const {
              x: P,
              y: Y
            } = R;
            R.x += this.state.slackX, R.y += this.state.slackY;
            const [ne, J] = (0, c.getBoundPosition)(this, R.x, R.y);
            R.x = ne, R.y = J, R.slackX = this.state.slackX + (P - R.x), R.slackY = this.state.slackY + (Y - R.y), k.x = R.x, k.y = R.y, k.deltaX = R.x - this.state.x, k.deltaY = R.y - this.state.y;
          }
          if (this.props.onDrag(D, k) === !1) return !1;
          this.setState(R);
        }), E(this, "onDragStop", (D, O) => {
          if (!this.state.dragging || this.props.onStop(D, (0, c.createDraggableData)(this, O)) === !1) return !1;
          (0, h.default)("Draggable: onDragStop: %j", O);
          const R = {
            dragging: !1,
            slackX: 0,
            slackY: 0
          };
          if (!!this.props.position) {
            const {
              x: P,
              y: Y
            } = this.props.position;
            R.x = P, R.y = Y;
          }
          this.setState(R);
        }), this.state = {
          // Whether or not we are currently dragging.
          dragging: !1,
          // Whether or not we have been dragged before.
          dragged: !1,
          // Current transform x and y.
          x: T.position ? T.position.x : T.defaultPosition.x,
          y: T.position ? T.position.y : T.defaultPosition.y,
          prevPropsPosition: {
            ...T.position
          },
          // Used for compensating for out-of-bounds drags
          slackX: 0,
          slackY: 0,
          // Can only determine if SVG after mounting
          isElementSVG: !1
        }, T.position && !(T.onDrag || T.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
      }
      componentDidMount() {
        typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
          isElementSVG: !0
        });
      }
      componentWillUnmount() {
        this.setState({
          dragging: !1
        });
      }
      // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
      // the underlying DOM node ourselves. See the README for more information.
      findDOMNode() {
        var T, D;
        return (T = (D = this.props) === null || D === void 0 || (D = D.nodeRef) === null || D === void 0 ? void 0 : D.current) !== null && T !== void 0 ? T : o.default.findDOMNode(this);
      }
      render() {
        const {
          axis: T,
          bounds: D,
          children: O,
          defaultPosition: k,
          defaultClassName: R,
          defaultClassNameDragging: N,
          defaultClassNameDragged: P,
          position: Y,
          positionOffset: ne,
          scale: J,
          ...ce
        } = this.props;
        let ue = {}, de = null;
        const G = !!!Y || this.state.dragging, U = Y || k, te = {
          // Set left if horizontal drag is enabled
          x: (0, c.canDragX)(this) && G ? this.state.x : U.x,
          // Set top if vertical drag is enabled
          y: (0, c.canDragY)(this) && G ? this.state.y : U.y
        };
        this.state.isElementSVG ? de = (0, l.createSVGTransform)(te, ne) : ue = (0, l.createCSSTransform)(te, ne);
        const he = (0, i.default)(O.props.className || "", R, {
          [N]: this.state.dragging,
          [P]: this.state.dragged
        });
        return /* @__PURE__ */ t.createElement(d.default, x({}, ce, {
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop
        }), /* @__PURE__ */ t.cloneElement(t.Children.only(O), {
          className: he,
          style: {
            ...O.props.style,
            ...ue
          },
          transform: de
        }));
      }
    }
    e.default = A, E(A, "displayName", "Draggable"), E(A, "propTypes", {
      // Accepts all props <DraggableCore> accepts.
      ...d.default.propTypes,
      /**
       * `axis` determines which axis the draggable can move.
       *
       *  Note that all callbacks will still return data as normal. This only
       *  controls flushing to the DOM.
       *
       * 'both' allows movement horizontally and vertically.
       * 'x' limits movement to horizontal axis.
       * 'y' limits movement to vertical axis.
       * 'none' limits all movement.
       *
       * Defaults to 'both'.
       */
      axis: n.default.oneOf(["both", "x", "y", "none"]),
      /**
       * `bounds` determines the range of movement available to the element.
       * Available values are:
       *
       * 'parent' restricts movement within the Draggable's parent node.
       *
       * Alternatively, pass an object with the following properties, all of which are optional:
       *
       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
       *
       * All values are in px.
       *
       * Example:
       *
       * ```jsx
       *   let App = React.createClass({
       *       render: function () {
       *         return (
       *            <Draggable bounds={{right: 300, bottom: 300}}>
       *              <div>Content</div>
       *           </Draggable>
       *         );
       *       }
       *   });
       * ```
       */
      bounds: n.default.oneOfType([n.default.shape({
        left: n.default.number,
        right: n.default.number,
        top: n.default.number,
        bottom: n.default.number
      }), n.default.string, n.default.oneOf([!1])]),
      defaultClassName: n.default.string,
      defaultClassNameDragging: n.default.string,
      defaultClassNameDragged: n.default.string,
      /**
       * `defaultPosition` specifies the x and y that the dragged item should start at
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      defaultPosition: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      positionOffset: n.default.shape({
        x: n.default.oneOfType([n.default.number, n.default.string]),
        y: n.default.oneOfType([n.default.number, n.default.string])
      }),
      /**
       * `position`, if present, defines the current position of the element.
       *
       *  This is similar to how form elements in React work - if no `position` is supplied, the component
       *  is uncontrolled.
       *
       * Example:
       *
       * ```jsx
       *      let App = React.createClass({
       *          render: function () {
       *              return (
       *                  <Draggable position={{x: 25, y: 25}}>
       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
       *                  </Draggable>
       *              );
       *          }
       *      });
       * ```
       */
      position: n.default.shape({
        x: n.default.number,
        y: n.default.number
      }),
      /**
       * These properties should be defined on the child, not here.
       */
      className: f.dontSetMe,
      style: f.dontSetMe,
      transform: f.dontSetMe
    }), E(A, "defaultProps", {
      ...d.default.defaultProps,
      axis: "both",
      bounds: !1,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    });
  })(Rp)), Rp;
}
var ES;
function SO() {
  if (ES) return Xs.exports;
  ES = 1;
  const {
    default: e,
    DraggableCore: t
  } = xO();
  return Xs.exports = e, Xs.exports.default = e, Xs.exports.DraggableCore = t, Xs.exports;
}
var wO = SO();
const EO = /* @__PURE__ */ jl(wO);
var Ct = function() {
  return Ct = Object.assign || function(e) {
    for (var t, n = 1, o = arguments.length; n < o; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, Ct.apply(this, arguments);
}, _S = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
}, TS = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
}, pu = {
  width: "20px",
  height: "20px",
  position: "absolute",
  zIndex: 1
}, _O = {
  top: Ct(Ct({}, _S), { top: "-5px" }),
  right: Ct(Ct({}, TS), { left: void 0, right: "-5px" }),
  bottom: Ct(Ct({}, _S), { top: void 0, bottom: "-5px" }),
  left: Ct(Ct({}, TS), { left: "-5px" }),
  topRight: Ct(Ct({}, pu), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: Ct(Ct({}, pu), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: Ct(Ct({}, pu), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: Ct(Ct({}, pu), { left: "-10px", top: "-10px", cursor: "nw-resize" })
}, TO = y.memo(function(e) {
  var t = e.onResizeStart, n = e.direction, o = e.children, i = e.replaceStyles, l = e.className, c = y.useCallback(function(h) {
    t(h, n);
  }, [t, n]), f = y.useCallback(function(h) {
    t(h, n);
  }, [t, n]), d = y.useMemo(function() {
    return Ct(Ct({ position: "absolute", userSelect: "none" }, _O[n]), i ?? {});
  }, [i, n]);
  return S.jsx("div", { className: l || void 0, style: d, onMouseDown: c, onTouchStart: f, children: o });
}), CO = /* @__PURE__ */ (function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
      o.__proto__ = i;
    } || function(o, i) {
      for (var l in i) Object.prototype.hasOwnProperty.call(i, l) && (o[l] = i[l]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function o() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (o.prototype = n.prototype, new o());
  };
})(), cr = function() {
  return cr = Object.assign || function(e) {
    for (var t, n = 1, o = arguments.length; n < o; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, cr.apply(this, arguments);
}, AO = {
  width: "auto",
  height: "auto"
}, mu = function(e, t, n) {
  return Math.max(Math.min(e, n), t);
}, CS = function(e, t, n) {
  var o = Math.round(e / t);
  return o * t + n * (o - 1);
}, mi = function(e, t) {
  return new RegExp(e, "i").test(t);
}, gu = function(e) {
  return !!(e.touches && e.touches.length);
}, RO = function(e) {
  return !!((e.clientX || e.clientX === 0) && (e.clientY || e.clientY === 0));
}, AS = function(e, t, n) {
  n === void 0 && (n = 0);
  var o = t.reduce(function(l, c, f) {
    return Math.abs(c - e) < Math.abs(t[l] - e) ? f : l;
  }, 0), i = Math.abs(t[o] - e);
  return n === 0 || i < n ? t[o] : e;
}, Np = function(e) {
  return e = e.toString(), e === "auto" || e.endsWith("px") || e.endsWith("%") || e.endsWith("vh") || e.endsWith("vw") || e.endsWith("vmax") || e.endsWith("vmin") ? e : "".concat(e, "px");
}, vu = function(e, t, n, o) {
  if (e && typeof e == "string") {
    if (e.endsWith("px"))
      return Number(e.replace("px", ""));
    if (e.endsWith("%")) {
      var i = Number(e.replace("%", "")) / 100;
      return t * i;
    }
    if (e.endsWith("vw")) {
      var i = Number(e.replace("vw", "")) / 100;
      return n * i;
    }
    if (e.endsWith("vh")) {
      var i = Number(e.replace("vh", "")) / 100;
      return o * i;
    }
  }
  return e;
}, MO = function(e, t, n, o, i, l, c) {
  return o = vu(o, e.width, t, n), i = vu(i, e.height, t, n), l = vu(l, e.width, t, n), c = vu(c, e.height, t, n), {
    maxWidth: typeof o > "u" ? void 0 : Number(o),
    maxHeight: typeof i > "u" ? void 0 : Number(i),
    minWidth: typeof l > "u" ? void 0 : Number(l),
    minHeight: typeof c > "u" ? void 0 : Number(c)
  };
}, zO = function(e) {
  return Array.isArray(e) ? e : [e, e];
}, DO = [
  "as",
  "ref",
  "style",
  "className",
  "grid",
  "gridGap",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
], RS = "__resizable_base__", NO = (
  /** @class */
  (function(e) {
    CO(t, e);
    function t(n) {
      var o, i, l, c, f = e.call(this, n) || this;
      return f.ratio = 1, f.resizable = null, f.parentLeft = 0, f.parentTop = 0, f.resizableLeft = 0, f.resizableRight = 0, f.resizableTop = 0, f.resizableBottom = 0, f.targetLeft = 0, f.targetTop = 0, f.delta = {
        width: 0,
        height: 0
      }, f.appendBase = function() {
        if (!f.resizable || !f.window)
          return null;
        var d = f.parentNode;
        if (!d)
          return null;
        var h = f.window.document.createElement("div");
        return h.style.width = "100%", h.style.height = "100%", h.style.position = "absolute", h.style.transform = "scale(0, 0)", h.style.left = "0", h.style.flex = "0 0 100%", h.classList ? h.classList.add(RS) : h.className += RS, d.appendChild(h), h;
      }, f.removeBase = function(d) {
        var h = f.parentNode;
        h && h.removeChild(d);
      }, f.state = {
        isResizing: !1,
        width: (i = (o = f.propsSize) === null || o === void 0 ? void 0 : o.width) !== null && i !== void 0 ? i : "auto",
        height: (c = (l = f.propsSize) === null || l === void 0 ? void 0 : l.height) !== null && c !== void 0 ? c : "auto",
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      }, f.onResizeStart = f.onResizeStart.bind(f), f.onMouseMove = f.onMouseMove.bind(f), f.onMouseUp = f.onMouseUp.bind(f), f;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      get: function() {
        return this.resizable ? this.resizable.parentNode : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "window", {
      get: function() {
        return !this.resizable || !this.resizable.ownerDocument ? null : this.resizable.ownerDocument.defaultView;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || AO;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "size", {
      get: function() {
        var n = 0, o = 0;
        if (this.resizable && this.window) {
          var i = this.resizable.offsetWidth, l = this.resizable.offsetHeight, c = this.resizable.style.position;
          c !== "relative" && (this.resizable.style.position = "relative"), n = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : i, o = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : l, this.resizable.style.position = c;
        }
        return { width: n, height: o };
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "sizeStyle", {
      get: function() {
        var n = this, o = this.props.size, i = function(f) {
          var d;
          if (typeof n.state[f] > "u" || n.state[f] === "auto")
            return "auto";
          if (n.propsSize && n.propsSize[f] && (!((d = n.propsSize[f]) === null || d === void 0) && d.toString().endsWith("%"))) {
            if (n.state[f].toString().endsWith("%"))
              return n.state[f].toString();
            var h = n.getParentSize(), m = Number(n.state[f].toString().replace("px", "")), v = m / h[f] * 100;
            return "".concat(v, "%");
          }
          return Np(n.state[f]);
        }, l = o && typeof o.width < "u" && !this.state.isResizing ? Np(o.width) : i("width"), c = o && typeof o.height < "u" && !this.state.isResizing ? Np(o.height) : i("height");
        return { width: l, height: c };
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.getParentSize = function() {
      if (!this.parentNode)
        return this.window ? { width: this.window.innerWidth, height: this.window.innerHeight } : { width: 0, height: 0 };
      var n = this.appendBase();
      if (!n)
        return { width: 0, height: 0 };
      var o = !1, i = this.parentNode.style.flexWrap;
      i !== "wrap" && (o = !0, this.parentNode.style.flexWrap = "wrap"), n.style.position = "relative", n.style.minWidth = "100%", n.style.minHeight = "100%";
      var l = {
        width: n.offsetWidth,
        height: n.offsetHeight
      };
      return o && (this.parentNode.style.flexWrap = i), this.removeBase(n), l;
    }, t.prototype.bindEvents = function() {
      this.window && (this.window.addEventListener("mouseup", this.onMouseUp), this.window.addEventListener("mousemove", this.onMouseMove), this.window.addEventListener("mouseleave", this.onMouseUp), this.window.addEventListener("touchmove", this.onMouseMove, {
        capture: !0,
        passive: !1
      }), this.window.addEventListener("touchend", this.onMouseUp));
    }, t.prototype.unbindEvents = function() {
      this.window && (this.window.removeEventListener("mouseup", this.onMouseUp), this.window.removeEventListener("mousemove", this.onMouseMove), this.window.removeEventListener("mouseleave", this.onMouseUp), this.window.removeEventListener("touchmove", this.onMouseMove, !0), this.window.removeEventListener("touchend", this.onMouseUp));
    }, t.prototype.componentDidMount = function() {
      if (!(!this.resizable || !this.window)) {
        var n = this.window.getComputedStyle(this.resizable);
        this.setState({
          width: this.state.width || this.size.width,
          height: this.state.height || this.size.height,
          flexBasis: n.flexBasis !== "auto" ? n.flexBasis : void 0
        });
      }
    }, t.prototype.componentWillUnmount = function() {
      this.window && this.unbindEvents();
    }, t.prototype.createSizeForCssProperty = function(n, o) {
      var i = this.propsSize && this.propsSize[o];
      return this.state[o] === "auto" && this.state.original[o] === n && (typeof i > "u" || i === "auto") ? "auto" : n;
    }, t.prototype.calculateNewMaxFromBoundary = function(n, o) {
      var i = this.props.boundsByDirection, l = this.state.direction, c = i && mi("left", l), f = i && mi("top", l), d, h;
      if (this.props.bounds === "parent") {
        var m = this.parentNode;
        m && (d = c ? this.resizableRight - this.parentLeft : m.offsetWidth + (this.parentLeft - this.resizableLeft), h = f ? this.resizableBottom - this.parentTop : m.offsetHeight + (this.parentTop - this.resizableTop));
      } else this.props.bounds === "window" ? this.window && (d = c ? this.resizableRight : this.window.innerWidth - this.resizableLeft, h = f ? this.resizableBottom : this.window.innerHeight - this.resizableTop) : this.props.bounds && (d = c ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft), h = f ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop));
      return d && Number.isFinite(d) && (n = n && n < d ? n : d), h && Number.isFinite(h) && (o = o && o < h ? o : h), { maxWidth: n, maxHeight: o };
    }, t.prototype.calculateNewSizeFromDirection = function(n, o) {
      var i = this.props.scale || 1, l = zO(this.props.resizeRatio || 1), c = l[0], f = l[1], d = this.state, h = d.direction, m = d.original, v = this.props, b = v.lockAspectRatio, x = v.lockAspectRatioExtraHeight, E = v.lockAspectRatioExtraWidth, w = m.width, C = m.height, A = x || 0, M = E || 0;
      return mi("right", h) && (w = m.width + (n - m.x) * c / i, b && (C = (w - M) / this.ratio + A)), mi("left", h) && (w = m.width - (n - m.x) * c / i, b && (C = (w - M) / this.ratio + A)), mi("bottom", h) && (C = m.height + (o - m.y) * f / i, b && (w = (C - A) * this.ratio + M)), mi("top", h) && (C = m.height - (o - m.y) * f / i, b && (w = (C - A) * this.ratio + M)), { newWidth: w, newHeight: C };
    }, t.prototype.calculateNewSizeFromAspectRatio = function(n, o, i, l) {
      var c = this.props, f = c.lockAspectRatio, d = c.lockAspectRatioExtraHeight, h = c.lockAspectRatioExtraWidth, m = typeof l.width > "u" ? 10 : l.width, v = typeof i.width > "u" || i.width < 0 ? n : i.width, b = typeof l.height > "u" ? 10 : l.height, x = typeof i.height > "u" || i.height < 0 ? o : i.height, E = d || 0, w = h || 0;
      if (f) {
        var C = (b - E) * this.ratio + w, A = (x - E) * this.ratio + w, M = (m - w) / this.ratio + E, T = (v - w) / this.ratio + E, D = Math.max(m, C), O = Math.min(v, A), k = Math.max(b, M), R = Math.min(x, T);
        n = mu(n, D, O), o = mu(o, k, R);
      } else
        n = mu(n, m, v), o = mu(o, b, x);
      return { newWidth: n, newHeight: o };
    }, t.prototype.setBoundingClientRect = function() {
      var n = 1 / (this.props.scale || 1);
      if (this.props.bounds === "parent") {
        var o = this.parentNode;
        if (o) {
          var i = o.getBoundingClientRect();
          this.parentLeft = i.left * n, this.parentTop = i.top * n;
        }
      }
      if (this.props.bounds && typeof this.props.bounds != "string") {
        var l = this.props.bounds.getBoundingClientRect();
        this.targetLeft = l.left * n, this.targetTop = l.top * n;
      }
      if (this.resizable) {
        var c = this.resizable.getBoundingClientRect(), f = c.left, d = c.top, h = c.right, m = c.bottom;
        this.resizableLeft = f * n, this.resizableRight = h * n, this.resizableTop = d * n, this.resizableBottom = m * n;
      }
    }, t.prototype.onResizeStart = function(n, o) {
      if (!(!this.resizable || !this.window)) {
        var i = 0, l = 0;
        if (n.nativeEvent && RO(n.nativeEvent) ? (i = n.nativeEvent.clientX, l = n.nativeEvent.clientY) : n.nativeEvent && gu(n.nativeEvent) && (i = n.nativeEvent.touches[0].clientX, l = n.nativeEvent.touches[0].clientY), this.props.onResizeStart && this.resizable) {
          var c = this.props.onResizeStart(n, o, this.resizable);
          if (c === !1)
            return;
        }
        this.props.size && (typeof this.props.size.height < "u" && this.props.size.height !== this.state.height && this.setState({ height: this.props.size.height }), typeof this.props.size.width < "u" && this.props.size.width !== this.state.width && this.setState({ width: this.props.size.width })), this.ratio = typeof this.props.lockAspectRatio == "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
        var f, d = this.window.getComputedStyle(this.resizable);
        if (d.flexBasis !== "auto") {
          var h = this.parentNode;
          if (h) {
            var m = this.window.getComputedStyle(h).flexDirection;
            this.flexDir = m.startsWith("row") ? "row" : "column", f = d.flexBasis;
          }
        }
        this.setBoundingClientRect(), this.bindEvents();
        var v = {
          original: {
            x: i,
            y: l,
            width: this.size.width,
            height: this.size.height
          },
          isResizing: !0,
          backgroundStyle: cr(cr({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(n.target).cursor || "auto" }),
          direction: o,
          flexBasis: f
        };
        this.setState(v);
      }
    }, t.prototype.onMouseMove = function(n) {
      var o = this;
      if (!(!this.state.isResizing || !this.resizable || !this.window)) {
        if (this.window.TouchEvent && gu(n))
          try {
            n.preventDefault(), n.stopPropagation();
          } catch {
          }
        var i = this.props, l = i.maxWidth, c = i.maxHeight, f = i.minWidth, d = i.minHeight, h = gu(n) ? n.touches[0].clientX : n.clientX, m = gu(n) ? n.touches[0].clientY : n.clientY, v = this.state, b = v.direction, x = v.original, E = v.width, w = v.height, C = this.getParentSize(), A = MO(C, this.window.innerWidth, this.window.innerHeight, l, c, f, d);
        l = A.maxWidth, c = A.maxHeight, f = A.minWidth, d = A.minHeight;
        var M = this.calculateNewSizeFromDirection(h, m), T = M.newHeight, D = M.newWidth, O = this.calculateNewMaxFromBoundary(l, c);
        this.props.snap && this.props.snap.x && (D = AS(D, this.props.snap.x, this.props.snapGap)), this.props.snap && this.props.snap.y && (T = AS(T, this.props.snap.y, this.props.snapGap));
        var k = this.calculateNewSizeFromAspectRatio(D, T, { width: O.maxWidth, height: O.maxHeight }, { width: f, height: d });
        if (D = k.newWidth, T = k.newHeight, this.props.grid) {
          var R = CS(D, this.props.grid[0], this.props.gridGap ? this.props.gridGap[0] : 0), N = CS(T, this.props.grid[1], this.props.gridGap ? this.props.gridGap[1] : 0), P = this.props.snapGap || 0, Y = P === 0 || Math.abs(R - D) <= P ? R : D, ne = P === 0 || Math.abs(N - T) <= P ? N : T;
          D = Y, T = ne;
        }
        var J = {
          width: D - x.width,
          height: T - x.height
        };
        if (this.delta = J, E && typeof E == "string") {
          if (E.endsWith("%")) {
            var ce = D / C.width * 100;
            D = "".concat(ce, "%");
          } else if (E.endsWith("vw")) {
            var ue = D / this.window.innerWidth * 100;
            D = "".concat(ue, "vw");
          } else if (E.endsWith("vh")) {
            var de = D / this.window.innerHeight * 100;
            D = "".concat(de, "vh");
          }
        }
        if (w && typeof w == "string") {
          if (w.endsWith("%")) {
            var ce = T / C.height * 100;
            T = "".concat(ce, "%");
          } else if (w.endsWith("vw")) {
            var ue = T / this.window.innerWidth * 100;
            T = "".concat(ue, "vw");
          } else if (w.endsWith("vh")) {
            var de = T / this.window.innerHeight * 100;
            T = "".concat(de, "vh");
          }
        }
        var I = {
          width: this.createSizeForCssProperty(D, "width"),
          height: this.createSizeForCssProperty(T, "height")
        };
        this.flexDir === "row" ? I.flexBasis = I.width : this.flexDir === "column" && (I.flexBasis = I.height);
        var G = this.state.width !== I.width, U = this.state.height !== I.height, te = this.state.flexBasis !== I.flexBasis, he = G || U || te;
        he && Vo.flushSync(function() {
          o.setState(I);
        }), this.props.onResize && he && this.props.onResize(n, b, this.resizable, J);
      }
    }, t.prototype.onMouseUp = function(n) {
      var o, i, l = this.state, c = l.isResizing, f = l.direction;
      l.original, !(!c || !this.resizable) && (this.props.onResizeStop && this.props.onResizeStop(n, f, this.resizable, this.delta), this.props.size && this.setState({ width: (o = this.props.size.width) !== null && o !== void 0 ? o : "auto", height: (i = this.props.size.height) !== null && i !== void 0 ? i : "auto" }), this.unbindEvents(), this.setState({
        isResizing: !1,
        backgroundStyle: cr(cr({}, this.state.backgroundStyle), { cursor: "auto" })
      }));
    }, t.prototype.updateSize = function(n) {
      var o, i;
      this.setState({ width: (o = n.width) !== null && o !== void 0 ? o : "auto", height: (i = n.height) !== null && i !== void 0 ? i : "auto" });
    }, t.prototype.renderResizer = function() {
      var n = this, o = this.props, i = o.enable, l = o.handleStyles, c = o.handleClasses, f = o.handleWrapperStyle, d = o.handleWrapperClass, h = o.handleComponent;
      if (!i)
        return null;
      var m = Object.keys(i).map(function(v) {
        return i[v] !== !1 ? S.jsx(TO, { direction: v, onResizeStart: n.onResizeStart, replaceStyles: l && l[v], className: c && c[v], children: h && h[v] ? h[v] : null }, v) : null;
      });
      return S.jsx("div", { className: d, style: f, children: m });
    }, t.prototype.render = function() {
      var n = this, o = Object.keys(this.props).reduce(function(c, f) {
        return DO.indexOf(f) !== -1 || (c[f] = n.props[f]), c;
      }, {}), i = cr(cr(cr({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      this.state.flexBasis && (i.flexBasis = this.state.flexBasis);
      var l = this.props.as || "div";
      return S.jsxs(l, cr({ style: i, className: this.props.className }, o, {
        // `ref` is after `extendsProps` to ensure this one wins over a version
        // passed in
        ref: function(c) {
          c && (n.resizable = c);
        },
        children: [this.state.isResizing && S.jsx("div", { style: this.state.backgroundStyle }), this.props.children, this.renderResizer()]
      }));
    }, t.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: !0,
        right: !0,
        bottom: !0,
        left: !0,
        topRight: !0,
        bottomRight: !0,
        bottomLeft: !0,
        topLeft: !0
      },
      style: {},
      grid: [1, 1],
      gridGap: [0, 0],
      lockAspectRatio: !1,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    }, t;
  })(y.PureComponent)
);
var Tm = function(e, t) {
  return Tm = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, o) {
    n.__proto__ = o;
  } || function(n, o) {
    for (var i in o) o.hasOwnProperty(i) && (n[i] = o[i]);
  }, Tm(e, t);
};
function OO(e, t) {
  Tm(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var zt = function() {
  return zt = Object.assign || function(t) {
    for (var n, o = 1, i = arguments.length; o < i; o++) {
      n = arguments[o];
      for (var l in n) Object.prototype.hasOwnProperty.call(n, l) && (t[l] = n[l]);
    }
    return t;
  }, zt.apply(this, arguments);
};
function jO(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, o = Object.getOwnPropertySymbols(e); i < o.length; i++)
      t.indexOf(o[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[i]) && (n[o[i]] = e[o[i]]);
  return n;
}
var kO = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
}, PO = function(e) {
  return {
    bottom: e,
    bottomLeft: e,
    bottomRight: e,
    left: e,
    right: e,
    top: e,
    topLeft: e,
    topRight: e
  };
}, LO = (
  /** @class */
  (function(e) {
    OO(t, e);
    function t(n) {
      var o = e.call(this, n) || this;
      return o.resizingPosition = { x: 0, y: 0 }, o.offsetFromParent = { left: 0, top: 0 }, o.resizableElement = { current: null }, o.originalPosition = { x: 0, y: 0 }, o.state = {
        resizing: !1,
        bounds: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        maxWidth: n.maxWidth,
        maxHeight: n.maxHeight
      }, o.onResizeStart = o.onResizeStart.bind(o), o.onResize = o.onResize.bind(o), o.onResizeStop = o.onResizeStop.bind(o), o.onDragStart = o.onDragStart.bind(o), o.onDrag = o.onDrag.bind(o), o.onDragStop = o.onDragStop.bind(o), o.getMaxSizesFromProps = o.getMaxSizesFromProps.bind(o), o;
    }
    return t.prototype.componentDidMount = function() {
      this.updateOffsetFromParent();
      var n = this.offsetFromParent, o = n.left, i = n.top, l = this.getDraggablePosition(), c = l.x, f = l.y;
      this.draggable.setState({
        x: c - o,
        y: f - i
      }), this.forceUpdate();
    }, t.prototype.getDraggablePosition = function() {
      var n = this.draggable.state, o = n.x, i = n.y;
      return { x: o, y: i };
    }, t.prototype.getParent = function() {
      return this.resizable && this.resizable.parentNode;
    }, t.prototype.getParentSize = function() {
      return this.resizable.getParentSize();
    }, t.prototype.getMaxSizesFromProps = function() {
      var n = typeof this.props.maxWidth > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth, o = typeof this.props.maxHeight > "u" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
      return { maxWidth: n, maxHeight: o };
    }, t.prototype.getSelfElement = function() {
      return this.resizable && this.resizable.resizable;
    }, t.prototype.getOffsetHeight = function(n) {
      var o = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerHeight / o;
        case "body":
          return document.body.offsetHeight / o;
        default:
          return n.offsetHeight;
      }
    }, t.prototype.getOffsetWidth = function(n) {
      var o = this.props.scale;
      switch (this.props.bounds) {
        case "window":
          return window.innerWidth / o;
        case "body":
          return document.body.offsetWidth / o;
        default:
          return n.offsetWidth;
      }
    }, t.prototype.onDragStart = function(n, o) {
      this.props.onDragStart && this.props.onDragStart(n, o);
      var i = this.getDraggablePosition();
      if (this.originalPosition = i, !!this.props.bounds) {
        var l = this.getParent(), c = this.props.scale, f;
        if (this.props.bounds === "parent")
          f = l;
        else if (this.props.bounds === "body") {
          var d = l.getBoundingClientRect(), h = d.left, m = d.top, v = document.body.getBoundingClientRect(), b = -(h - l.offsetLeft * c - v.left) / c, x = -(m - l.offsetTop * c - v.top) / c, E = (document.body.offsetWidth - this.resizable.size.width * c) / c + b, w = (document.body.offsetHeight - this.resizable.size.height * c) / c + x;
          return this.setState({ bounds: { top: x, right: E, bottom: w, left: b } });
        } else if (this.props.bounds === "window") {
          if (!this.resizable)
            return;
          var C = l.getBoundingClientRect(), A = C.left, M = C.top, T = -(A - l.offsetLeft * c) / c, D = -(M - l.offsetTop * c) / c, E = (window.innerWidth - this.resizable.size.width * c) / c + T, w = (window.innerHeight - this.resizable.size.height * c) / c + D;
          return this.setState({ bounds: { top: D, right: E, bottom: w, left: T } });
        } else typeof this.props.bounds == "string" ? f = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (f = this.props.bounds);
        if (!(!(f instanceof HTMLElement) || !(l instanceof HTMLElement))) {
          var O = f.getBoundingClientRect(), k = O.left, R = O.top, N = l.getBoundingClientRect(), P = N.left, Y = N.top, ne = (k - P) / c, J = R - Y;
          if (this.resizable) {
            this.updateOffsetFromParent();
            var ce = this.offsetFromParent;
            this.setState({
              bounds: {
                top: J - ce.top,
                right: ne + (f.offsetWidth - this.resizable.size.width) - ce.left / c,
                bottom: J + (f.offsetHeight - this.resizable.size.height) - ce.top,
                left: ne - ce.left / c
              }
            });
          }
        }
      }
    }, t.prototype.onDrag = function(n, o) {
      if (this.props.onDrag) {
        var i = this.offsetFromParent, l = i.left, c = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDrag(n, zt(zt({}, o), { x: o.x + l, y: o.y + c }));
        if (this.props.dragAxis === "x")
          return this.props.onDrag(n, zt(zt({}, o), { x: o.x + l, y: this.originalPosition.y + c, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDrag(n, zt(zt({}, o), { x: this.originalPosition.x + l, y: o.y + c, deltaX: 0 }));
      }
    }, t.prototype.onDragStop = function(n, o) {
      if (this.props.onDragStop) {
        var i = this.offsetFromParent, l = i.left, c = i.top;
        if (!this.props.dragAxis || this.props.dragAxis === "both")
          return this.props.onDragStop(n, zt(zt({}, o), { x: o.x + l, y: o.y + c }));
        if (this.props.dragAxis === "x")
          return this.props.onDragStop(n, zt(zt({}, o), { x: o.x + l, y: this.originalPosition.y + c, deltaY: 0 }));
        if (this.props.dragAxis === "y")
          return this.props.onDragStop(n, zt(zt({}, o), { x: this.originalPosition.x + l, y: o.y + c, deltaX: 0 }));
      }
    }, t.prototype.onResizeStart = function(n, o, i) {
      n.stopPropagation(), this.setState({
        resizing: !0
      });
      var l = this.props.scale, c = this.offsetFromParent, f = this.getDraggablePosition();
      if (this.resizingPosition = { x: f.x + c.left, y: f.y + c.top }, this.originalPosition = f, this.props.bounds) {
        var d = this.getParent(), h = void 0;
        this.props.bounds === "parent" ? h = d : this.props.bounds === "body" ? h = document.body : this.props.bounds === "window" ? h = window : typeof this.props.bounds == "string" ? h = document.querySelector(this.props.bounds) : this.props.bounds instanceof HTMLElement && (h = this.props.bounds);
        var m = this.getSelfElement();
        if (m instanceof Element && (h instanceof HTMLElement || h === window) && d instanceof HTMLElement) {
          var v = this.getMaxSizesFromProps(), b = v.maxWidth, x = v.maxHeight, E = this.getParentSize();
          if (b && typeof b == "string")
            if (b.endsWith("%")) {
              var w = Number(b.replace("%", "")) / 100;
              b = E.width * w;
            } else b.endsWith("px") && (b = Number(b.replace("px", "")));
          if (x && typeof x == "string")
            if (x.endsWith("%")) {
              var w = Number(x.replace("%", "")) / 100;
              x = E.height * w;
            } else x.endsWith("px") && (x = Number(x.replace("px", "")));
          var C = m.getBoundingClientRect(), A = C.left, M = C.top, T = this.props.bounds === "window" ? { left: 0, top: 0 } : h.getBoundingClientRect(), D = T.left, O = T.top, k = this.getOffsetWidth(h), R = this.getOffsetHeight(h), N = o.toLowerCase().endsWith("left"), P = o.toLowerCase().endsWith("right"), Y = o.startsWith("top"), ne = o.startsWith("bottom");
          if ((N || Y) && this.resizable) {
            var J = (A - D) / l + this.resizable.size.width;
            this.setState({ maxWidth: J > Number(b) ? b : J });
          }
          if (P || this.props.lockAspectRatio && !N && !Y) {
            var J = k + (D - A) / l;
            this.setState({ maxWidth: J > Number(b) ? b : J });
          }
          if ((Y || N) && this.resizable) {
            var J = (M - O) / l + this.resizable.size.height;
            this.setState({
              maxHeight: J > Number(x) ? x : J
            });
          }
          if (ne || this.props.lockAspectRatio && !Y && !N) {
            var J = R + (O - M) / l;
            this.setState({
              maxHeight: J > Number(x) ? x : J
            });
          }
        }
      } else
        this.setState({
          maxWidth: this.props.maxWidth,
          maxHeight: this.props.maxHeight
        });
      this.props.onResizeStart && this.props.onResizeStart(n, o, i);
    }, t.prototype.onResize = function(n, o, i, l) {
      var c = this, f = { x: this.originalPosition.x, y: this.originalPosition.y }, d = -l.width, h = -l.height, m = ["top", "left", "topLeft", "bottomLeft", "topRight"];
      m.includes(o) && (o === "bottomLeft" ? f.x += d : (o === "topRight" || (f.x += d), f.y += h));
      var v = this.draggable.state;
      (f.x !== v.x || f.y !== v.y) && Vo.flushSync(function() {
        c.draggable.setState(f);
      }), this.updateOffsetFromParent();
      var b = this.offsetFromParent, x = this.getDraggablePosition().x + b.left, E = this.getDraggablePosition().y + b.top;
      this.resizingPosition = { x, y: E }, this.props.onResize && this.props.onResize(n, o, i, l, {
        x,
        y: E
      });
    }, t.prototype.onResizeStop = function(n, o, i, l) {
      this.setState({
        resizing: !1
      });
      var c = this.getMaxSizesFromProps(), f = c.maxWidth, d = c.maxHeight;
      this.setState({ maxWidth: f, maxHeight: d }), this.props.onResizeStop && this.props.onResizeStop(n, o, i, l, this.resizingPosition);
    }, t.prototype.updateSize = function(n) {
      this.resizable && this.resizable.updateSize({ width: n.width, height: n.height });
    }, t.prototype.updatePosition = function(n) {
      this.draggable.setState(n);
    }, t.prototype.updateOffsetFromParent = function() {
      var n = this.props.scale, o = this.getParent(), i = this.getSelfElement();
      if (!o || i === null)
        return {
          top: 0,
          left: 0
        };
      var l = o.getBoundingClientRect(), c = l.left, f = l.top, d = i.getBoundingClientRect(), h = this.getDraggablePosition(), m = o.scrollLeft, v = o.scrollTop;
      this.offsetFromParent = {
        left: d.left - c + m - h.x * n,
        top: d.top - f + v - h.y * n
      };
    }, t.prototype.render = function() {
      var n = this, o = this.props, i = o.disableDragging, l = o.style, c = o.dragHandleClassName, f = o.position, d = o.onMouseDown, h = o.onMouseUp, m = o.dragAxis, v = o.dragGrid, b = o.bounds, x = o.enableUserSelectHack, E = o.cancel, w = o.children;
      o.onResizeStart, o.onResize, o.onResizeStop, o.onDragStart, o.onDrag, o.onDragStop;
      var C = o.resizeHandleStyles, A = o.resizeHandleClasses, M = o.resizeHandleComponent, T = o.enableResizing, D = o.resizeGrid, O = o.resizeHandleWrapperClass, k = o.resizeHandleWrapperStyle, R = o.scale, N = o.allowAnyClick, P = o.dragPositionOffset, Y = jO(o, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick", "dragPositionOffset"]), ne = this.props.default ? zt({}, this.props.default) : void 0;
      delete Y.default;
      var J = i || c ? { cursor: "auto" } : { cursor: "move" }, ce = zt(zt(zt({}, kO), J), l), ue = this.offsetFromParent, de = ue.left, I = ue.top, G;
      f && (G = {
        x: f.x - de,
        y: f.y - I
      });
      var U = this.state.resizing ? void 0 : G, te = this.state.resizing ? "both" : m;
      return y.createElement(
        EO,
        {
          ref: function(he) {
            he && (n.draggable = he);
          },
          handle: c ? ".".concat(c) : void 0,
          defaultPosition: ne,
          onMouseDown: d,
          // @ts-expect-error
          onMouseUp: h,
          onStart: this.onDragStart,
          onDrag: this.onDrag,
          onStop: this.onDragStop,
          axis: te,
          disabled: i,
          grid: v,
          bounds: b ? this.state.bounds : void 0,
          position: U,
          enableUserSelectHack: x,
          cancel: E,
          scale: R,
          allowAnyClick: N,
          nodeRef: this.resizableElement,
          positionOffset: P
        },
        y.createElement(NO, zt({}, Y, { ref: function(he) {
          he && (n.resizable = he, n.resizableElement.current = he.resizable);
        }, defaultSize: ne, size: this.props.size, enable: typeof T == "boolean" ? PO(T) : T, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: ce, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: D, handleWrapperClass: O, handleWrapperStyle: k, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: C, handleClasses: A, handleComponent: M, scale: this.props.scale }), w)
      );
    }, t.defaultProps = {
      maxWidth: Number.MAX_SAFE_INTEGER,
      maxHeight: Number.MAX_SAFE_INTEGER,
      scale: 1,
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      onDragStart: function() {
      },
      onDrag: function() {
      },
      onDragStop: function() {
      }
    }, t;
  })(y.PureComponent)
);
const kE = (...e) => e.filter((t, n, o) => !!t && t.trim() !== "" && o.indexOf(t) === n).join(" ").trim();
const IO = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const VO = (e) => e.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (t, n, o) => o ? o.toUpperCase() : n.toLowerCase()
);
const MS = (e) => {
  const t = VO(e);
  return t.charAt(0).toUpperCase() + t.slice(1);
};
var UO = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
const BO = (e) => {
  for (const t in e)
    if (t.startsWith("aria-") || t === "role" || t === "title")
      return !0;
  return !1;
};
const $O = y.forwardRef(
  ({
    color: e = "currentColor",
    size: t = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: o,
    className: i = "",
    children: l,
    iconNode: c,
    ...f
  }, d) => y.createElement(
    "svg",
    {
      ref: d,
      ...UO,
      width: t,
      height: t,
      stroke: e,
      strokeWidth: o ? Number(n) * 24 / Number(t) : n,
      className: kE("lucide", i),
      ...!l && !BO(f) && { "aria-hidden": "true" },
      ...f
    },
    [
      ...c.map(([h, m]) => y.createElement(h, m)),
      ...Array.isArray(l) ? l : [l]
    ]
  )
);
const ot = (e, t) => {
  const n = y.forwardRef(
    ({ className: o, ...i }, l) => y.createElement($O, {
      ref: l,
      iconNode: t,
      className: kE(
        `lucide-${IO(MS(e))}`,
        `lucide-${e}`,
        o
      ),
      ...i
    })
  );
  return n.displayName = MS(e), n;
};
const HO = [
  [
    "path",
    {
      d: "M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z",
      key: "oz39mx"
    }
  ]
], ZO = ot("bookmark", HO);
const FO = [
  ["path", { d: "M12 6V2H8", key: "1155em" }],
  ["path", { d: "M15 11v2", key: "i11awn" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  [
    "path",
    {
      d: "M20 16a2 2 0 0 1-2 2H8.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 4 20.286V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2z",
      key: "11gyqh"
    }
  ],
  ["path", { d: "M9 11v2", key: "1ueba0" }]
], _g = ot("bot-message-square", FO);
const GO = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], PE = ot("check", GO);
const YO = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Tg = ot("chevron-down", YO);
const qO = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], LE = ot("chevron-up", qO);
const WO = [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
], Cm = ot("copy", WO);
const XO = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
], KO = ot("ellipsis-vertical", XO);
const JO = [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
], QO = ot("grip-vertical", JO);
const e2 = [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
], t2 = ot("lightbulb", e2);
const n2 = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], r2 = ot("loader-circle", n2);
const o2 = [
  ["path", { d: "M4 5h16", key: "1tepv9" }],
  ["path", { d: "M4 12h16", key: "1lakjw" }],
  ["path", { d: "M4 19h16", key: "1djgab" }]
], a2 = ot("menu", o2);
const i2 = [
  [
    "path",
    {
      d: "M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719",
      key: "1sd12s"
    }
  ]
], s2 = ot("message-circle", i2);
const l2 = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ],
  ["path", { d: "M7 11h10", key: "1twpyw" }],
  ["path", { d: "M7 15h6", key: "d9of3u" }],
  ["path", { d: "M7 7h8", key: "af5zfr" }]
], c2 = ot("message-square-text", l2);
const u2 = [
  [
    "path",
    {
      d: "M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z",
      key: "18887p"
    }
  ]
], zS = ot("message-square", u2);
const f2 = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M16.95 16.95A7 7 0 0 1 5 12v-2", key: "cqa7eg" }],
  ["path", { d: "M18.89 13.23A7 7 0 0 0 19 12v-2", key: "16hl24" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }]
], d2 = ot("mic-off", f2);
const h2 = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
], p2 = ot("mic", h2);
const m2 = [
  [
    "path",
    {
      d: "m16 6-8.414 8.586a2 2 0 0 0 2.829 2.829l8.414-8.586a4 4 0 1 0-5.657-5.657l-8.379 8.551a6 6 0 1 0 8.485 8.485l8.379-8.551",
      key: "1miecu"
    }
  ]
], g2 = ot("paperclip", m2);
const v2 = [
  ["rect", { x: "14", y: "3", width: "5", height: "18", rx: "1", key: "kaeet6" }],
  ["rect", { x: "5", y: "3", width: "5", height: "18", rx: "1", key: "1wsw3u" }]
], y2 = ot("pause", v2);
const b2 = [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
], x2 = ot("plus", b2);
const S2 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
], w2 = ot("send", S2);
const E2 = [
  [
    "path",
    {
      d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915",
      key: "1i5ecw"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
], _2 = ot("settings", E2);
const T2 = [
  ["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }],
  [
    "path",
    {
      d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z",
      key: "ohrbg2"
    }
  ]
], C2 = ot("square-pen", T2);
const A2 = [
  ["path", { d: "M10 11v6", key: "nco0om" }],
  ["path", { d: "M14 11v6", key: "outv1u" }],
  ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }],
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]
], R2 = ot("trash-2", A2);
const M2 = [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
], z2 = ot("triangle-alert", M2);
const D2 = [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
], N2 = ot("user", D2);
const O2 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
], Rf = ot("x", O2);
var IE = "vercel.ai.error", j2 = Symbol.for(IE), DS, NS, Bn = class VE extends (NS = Error, DS = j2, NS) {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: t,
    message: n,
    cause: o
  }) {
    super(n), this[DS] = !0, this.name = t, this.cause = o;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(t) {
    return VE.hasMarker(t, IE);
  }
  static hasMarker(t, n) {
    const o = Symbol.for(n);
    return t != null && typeof t == "object" && o in t && typeof t[o] == "boolean" && t[o] === !0;
  }
};
function Cg(e) {
  return e == null ? "unknown error" : typeof e == "string" ? e : e instanceof Error ? e.message : JSON.stringify(e);
}
var UE = "AI_InvalidArgumentError", BE = `vercel.ai.error.${UE}`, k2 = Symbol.for(BE), OS, jS, P2 = class extends (jS = Bn, OS = k2, jS) {
  constructor({
    message: e,
    cause: t,
    argument: n
  }) {
    super({ name: UE, message: e, cause: t }), this[OS] = !0, this.argument = n;
  }
  static isInstance(e) {
    return Bn.hasMarker(e, BE);
  }
}, $E = "AI_JSONParseError", HE = `vercel.ai.error.${$E}`, L2 = Symbol.for(HE), kS, PS, LS = class extends (PS = Bn, kS = L2, PS) {
  constructor({ text: e, cause: t }) {
    super({
      name: $E,
      message: `JSON parsing failed: Text: ${e}.
Error message: ${Cg(t)}`,
      cause: t
    }), this[kS] = !0, this.text = e;
  }
  static isInstance(e) {
    return Bn.hasMarker(e, HE);
  }
}, ZE = "AI_TypeValidationError", FE = `vercel.ai.error.${ZE}`, I2 = Symbol.for(FE), IS, VS, Li = class Am extends (VS = Bn, IS = I2, VS) {
  constructor({
    value: t,
    cause: n,
    context: o
  }) {
    let i = "Type validation failed";
    if (o?.field && (i += ` for ${o.field}`), o?.entityName || o?.entityId) {
      i += " (";
      const l = [];
      o.entityName && l.push(o.entityName), o.entityId && l.push(`id: "${o.entityId}"`), i += l.join(", "), i += ")";
    }
    super({
      name: ZE,
      message: `${i}: Value: ${JSON.stringify(t)}.
Error message: ${Cg(n)}`,
      cause: n
    }), this[IS] = !0, this.value = t, this.context = o;
  }
  static isInstance(t) {
    return Bn.hasMarker(t, FE);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value and context, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @param {TypeValidationContext} params.context - Optional context about what is being validated.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value: t,
    cause: n,
    context: o
  }) {
    var i, l, c;
    return Am.isInstance(n) && n.value === t && ((i = n.context) == null ? void 0 : i.field) === o?.field && ((l = n.context) == null ? void 0 : l.entityName) === o?.entityName && ((c = n.context) == null ? void 0 : c.entityId) === o?.entityId ? n : new Am({ value: t, cause: n, context: o });
  }
};
function ee(e, t, n) {
  function o(f, d) {
    if (f._zod || Object.defineProperty(f, "_zod", {
      value: {
        def: d,
        constr: c,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), f._zod.traits.has(e))
      return;
    f._zod.traits.add(e), t(f, d);
    const h = c.prototype, m = Object.keys(h);
    for (let v = 0; v < m.length; v++) {
      const b = m[v];
      b in f || (f[b] = h[b].bind(f));
    }
  }
  const i = n?.Parent ?? Object;
  class l extends i {
  }
  Object.defineProperty(l, "name", { value: e });
  function c(f) {
    var d;
    const h = n?.Parent ? new l() : this;
    o(h, f), (d = h._zod).deferred ?? (d.deferred = []);
    for (const m of h._zod.deferred)
      m();
    return h;
  }
  return Object.defineProperty(c, "init", { value: o }), Object.defineProperty(c, Symbol.hasInstance, {
    value: (f) => n?.Parent && f instanceof n.Parent ? !0 : f?._zod?.traits?.has(e)
  }), Object.defineProperty(c, "name", { value: e }), c;
}
class Ni extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class GE extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const YE = {};
function Oo(e) {
  return YE;
}
function qE(e) {
  const t = Object.values(e).filter((o) => typeof o == "number");
  return Object.entries(e).filter(([o, i]) => t.indexOf(+o) === -1).map(([o, i]) => i);
}
function Rm(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Mf(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function Ag(e) {
  return e == null;
}
function Rg(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function V2(e, t) {
  const n = (e.toString().split(".")[1] || "").length, o = t.toString();
  let i = (o.split(".")[1] || "").length;
  if (i === 0 && /\d?e-\d?/.test(o)) {
    const d = o.match(/\d?e-(\d?)/);
    d?.[1] && (i = Number.parseInt(d[1]));
  }
  const l = n > i ? n : i, c = Number.parseInt(e.toFixed(l).replace(".", "")), f = Number.parseInt(t.toFixed(l).replace(".", ""));
  return c % f / 10 ** l;
}
const US = /* @__PURE__ */ Symbol("evaluating");
function $e(e, t, n) {
  let o;
  Object.defineProperty(e, t, {
    get() {
      if (o !== US)
        return o === void 0 && (o = US, o = n()), o;
    },
    set(i) {
      Object.defineProperty(e, t, {
        value: i
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function Aa(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function Uo(...e) {
  const t = {};
  for (const n of e) {
    const o = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, o);
  }
  return Object.defineProperties({}, t);
}
function BS(e) {
  return JSON.stringify(e);
}
function U2(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const WE = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function vl(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const B2 = Mf(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function Ii(e) {
  if (vl(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const n = t.prototype;
  return !(vl(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
function XE(e) {
  return Ii(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
const $2 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function Vi(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Bo(e, t, n) {
  const o = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (o._zod.parent = e), o;
}
function we(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function H2(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const Z2 = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
function F2(e, t) {
  const n = e._zod.def, o = n.checks;
  if (o && o.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  const l = Uo(e._zod.def, {
    get shape() {
      const c = {};
      for (const f in t) {
        if (!(f in n.shape))
          throw new Error(`Unrecognized key: "${f}"`);
        t[f] && (c[f] = n.shape[f]);
      }
      return Aa(this, "shape", c), c;
    },
    checks: []
  });
  return Bo(e, l);
}
function G2(e, t) {
  const n = e._zod.def, o = n.checks;
  if (o && o.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  const l = Uo(e._zod.def, {
    get shape() {
      const c = { ...e._zod.def.shape };
      for (const f in t) {
        if (!(f in n.shape))
          throw new Error(`Unrecognized key: "${f}"`);
        t[f] && delete c[f];
      }
      return Aa(this, "shape", c), c;
    },
    checks: []
  });
  return Bo(e, l);
}
function Y2(e, t) {
  if (!Ii(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = e._zod.def.checks;
  if (n && n.length > 0) {
    const l = e._zod.def.shape;
    for (const c in t)
      if (Object.getOwnPropertyDescriptor(l, c) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  const i = Uo(e._zod.def, {
    get shape() {
      const l = { ...e._zod.def.shape, ...t };
      return Aa(this, "shape", l), l;
    }
  });
  return Bo(e, i);
}
function q2(e, t) {
  if (!Ii(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const n = Uo(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return Aa(this, "shape", o), o;
    }
  });
  return Bo(e, n);
}
function W2(e, t) {
  const n = Uo(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t._zod.def.shape };
      return Aa(this, "shape", o), o;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Bo(e, n);
}
function X2(e, t, n) {
  const i = t._zod.def.checks;
  if (i && i.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  const c = Uo(t._zod.def, {
    get shape() {
      const f = t._zod.def.shape, d = { ...f };
      if (n)
        for (const h in n) {
          if (!(h in f))
            throw new Error(`Unrecognized key: "${h}"`);
          n[h] && (d[h] = e ? new e({
            type: "optional",
            innerType: f[h]
          }) : f[h]);
        }
      else
        for (const h in f)
          d[h] = e ? new e({
            type: "optional",
            innerType: f[h]
          }) : f[h];
      return Aa(this, "shape", d), d;
    },
    checks: []
  });
  return Bo(t, c);
}
function K2(e, t, n) {
  const o = Uo(t._zod.def, {
    get shape() {
      const i = t._zod.def.shape, l = { ...i };
      if (n)
        for (const c in n) {
          if (!(c in l))
            throw new Error(`Unrecognized key: "${c}"`);
          n[c] && (l[c] = new e({
            type: "nonoptional",
            innerType: i[c]
          }));
        }
      else
        for (const c in i)
          l[c] = new e({
            type: "nonoptional",
            innerType: i[c]
          });
      return Aa(this, "shape", l), l;
    }
  });
  return Bo(t, o);
}
function Ti(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Ci(e, t) {
  return t.map((n) => {
    var o;
    return (o = n).path ?? (o.path = []), n.path.unshift(e), n;
  });
}
function yu(e) {
  return typeof e == "string" ? e : e?.message;
}
function jo(e, t, n) {
  const o = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const i = yu(e.inst?._zod.def?.error?.(e)) ?? yu(t?.error?.(e)) ?? yu(n.customError?.(e)) ?? yu(n.localeError?.(e)) ?? "Invalid input";
    o.message = i;
  }
  return delete o.inst, delete o.continue, t?.reportInput || delete o.input, o;
}
function Mg(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function yl(...e) {
  const [t, n, o] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: o
  } : { ...t };
}
const KE = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, Rm, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, JE = ee("$ZodError", KE), QE = ee("$ZodError", KE, { Parent: Error });
function J2(e, t = (n) => n.message) {
  const n = {}, o = [];
  for (const i of e.issues)
    i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : o.push(t(i));
  return { formErrors: o, fieldErrors: n };
}
function Q2(e, t = (n) => n.message) {
  const n = { _errors: [] }, o = (i) => {
    for (const l of i.issues)
      if (l.code === "invalid_union" && l.errors.length)
        l.errors.map((c) => o({ issues: c }));
      else if (l.code === "invalid_key")
        o({ issues: l.issues });
      else if (l.code === "invalid_element")
        o({ issues: l.issues });
      else if (l.path.length === 0)
        n._errors.push(t(l));
      else {
        let c = n, f = 0;
        for (; f < l.path.length; ) {
          const d = l.path[f];
          f === l.path.length - 1 ? (c[d] = c[d] || { _errors: [] }, c[d]._errors.push(t(l))) : c[d] = c[d] || { _errors: [] }, c = c[d], f++;
        }
      }
  };
  return o(e), n;
}
const zg = (e) => (t, n, o, i) => {
  const l = o ? Object.assign(o, { async: !1 }) : { async: !1 }, c = t._zod.run({ value: n, issues: [] }, l);
  if (c instanceof Promise)
    throw new Ni();
  if (c.issues.length) {
    const f = new (i?.Err ?? e)(c.issues.map((d) => jo(d, l, Oo())));
    throw WE(f, i?.callee), f;
  }
  return c.value;
}, Dg = (e) => async (t, n, o, i) => {
  const l = o ? Object.assign(o, { async: !0 }) : { async: !0 };
  let c = t._zod.run({ value: n, issues: [] }, l);
  if (c instanceof Promise && (c = await c), c.issues.length) {
    const f = new (i?.Err ?? e)(c.issues.map((d) => jo(d, l, Oo())));
    throw WE(f, i?.callee), f;
  }
  return c.value;
}, zf = (e) => (t, n, o) => {
  const i = o ? { ...o, async: !1 } : { async: !1 }, l = t._zod.run({ value: n, issues: [] }, i);
  if (l instanceof Promise)
    throw new Ni();
  return l.issues.length ? {
    success: !1,
    error: new (e ?? JE)(l.issues.map((c) => jo(c, i, Oo())))
  } : { success: !0, data: l.value };
}, ej = /* @__PURE__ */ zf(QE), Df = (e) => async (t, n, o) => {
  const i = o ? Object.assign(o, { async: !0 }) : { async: !0 };
  let l = t._zod.run({ value: n, issues: [] }, i);
  return l instanceof Promise && (l = await l), l.issues.length ? {
    success: !1,
    error: new e(l.issues.map((c) => jo(c, i, Oo())))
  } : { success: !0, data: l.value };
}, tj = /* @__PURE__ */ Df(QE), nj = (e) => (t, n, o) => {
  const i = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return zg(e)(t, n, i);
}, rj = (e) => (t, n, o) => zg(e)(t, n, o), oj = (e) => async (t, n, o) => {
  const i = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return Dg(e)(t, n, i);
}, aj = (e) => async (t, n, o) => Dg(e)(t, n, o), ij = (e) => (t, n, o) => {
  const i = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return zf(e)(t, n, i);
}, sj = (e) => (t, n, o) => zf(e)(t, n, o), lj = (e) => async (t, n, o) => {
  const i = o ? Object.assign(o, { direction: "backward" }) : { direction: "backward" };
  return Df(e)(t, n, i);
}, cj = (e) => async (t, n, o) => Df(e)(t, n, o), uj = /^[cC][^\s-]{8,}$/, fj = /^[0-9a-z]+$/, dj = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, hj = /^[0-9a-vA-V]{20}$/, pj = /^[A-Za-z0-9]{27}$/, mj = /^[a-zA-Z0-9_-]{21}$/, gj = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, vj = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, $S = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, yj = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, bj = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function xj() {
  return new RegExp(bj, "u");
}
const Sj = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, wj = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Ej = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, _j = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Tj = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, e_ = /^[A-Za-z0-9_-]*$/, Cj = /^\+[1-9]\d{6,14}$/, t_ = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Aj = /* @__PURE__ */ new RegExp(`^${t_}$`);
function n_(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Rj(e) {
  return new RegExp(`^${n_(e)}$`);
}
function Mj(e) {
  const t = n_({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const o = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${t_}T(?:${o})$`);
}
const zj = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, Dj = /^-?\d+$/, r_ = /^-?\d+(?:\.\d+)?$/, Nj = /^(?:true|false)$/i, Oj = /^null$/i, jj = /^[^A-Z]*$/, kj = /^[^a-z]*$/, ln = /* @__PURE__ */ ee("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), o_ = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, a_ = /* @__PURE__ */ ee("$ZodCheckLessThan", (e, t) => {
  ln.init(e, t);
  const n = o_[typeof t.value];
  e._zod.onattach.push((o) => {
    const i = o._zod.bag, l = (t.inclusive ? i.maximum : i.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < l && (t.inclusive ? i.maximum = t.value : i.exclusiveMaximum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value <= t.value : o.value < t.value) || o.issues.push({
      origin: n,
      code: "too_big",
      maximum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: o.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), i_ = /* @__PURE__ */ ee("$ZodCheckGreaterThan", (e, t) => {
  ln.init(e, t);
  const n = o_[typeof t.value];
  e._zod.onattach.push((o) => {
    const i = o._zod.bag, l = (t.inclusive ? i.minimum : i.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > l && (t.inclusive ? i.minimum = t.value : i.exclusiveMinimum = t.value);
  }), e._zod.check = (o) => {
    (t.inclusive ? o.value >= t.value : o.value > t.value) || o.issues.push({
      origin: n,
      code: "too_small",
      minimum: typeof t.value == "object" ? t.value.getTime() : t.value,
      input: o.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Pj = /* @__PURE__ */ ee("$ZodCheckMultipleOf", (e, t) => {
  ln.init(e, t), e._zod.onattach.push((n) => {
    var o;
    (o = n._zod.bag).multipleOf ?? (o.multipleOf = t.value);
  }), e._zod.check = (n) => {
    if (typeof n.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof n.value == "bigint" ? n.value % t.value === BigInt(0) : V2(n.value, t.value) === 0) || n.issues.push({
      origin: typeof n.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Lj = /* @__PURE__ */ ee("$ZodCheckNumberFormat", (e, t) => {
  ln.init(e, t), t.format = t.format || "float64";
  const n = t.format?.includes("int"), o = n ? "int" : "number", [i, l] = Z2[t.format];
  e._zod.onattach.push((c) => {
    const f = c._zod.bag;
    f.format = t.format, f.minimum = i, f.maximum = l, n && (f.pattern = Dj);
  }), e._zod.check = (c) => {
    const f = c.value;
    if (n) {
      if (!Number.isInteger(f)) {
        c.issues.push({
          expected: o,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: f,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(f)) {
        f > 0 ? c.issues.push({
          input: f,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: o,
          inclusive: !0,
          continue: !t.abort
        }) : c.issues.push({
          input: f,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: o,
          inclusive: !0,
          continue: !t.abort
        });
        return;
      }
    }
    f < i && c.issues.push({
      origin: "number",
      input: f,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), f > l && c.issues.push({
      origin: "number",
      input: f,
      code: "too_big",
      maximum: l,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    });
  };
}), Ij = /* @__PURE__ */ ee("$ZodCheckMaxLength", (e, t) => {
  var n;
  ln.init(e, t), (n = e._zod.def).when ?? (n.when = (o) => {
    const i = o.value;
    return !Ag(i) && i.length !== void 0;
  }), e._zod.onattach.push((o) => {
    const i = o._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < i && (o._zod.bag.maximum = t.maximum);
  }), e._zod.check = (o) => {
    const i = o.value;
    if (i.length <= t.maximum)
      return;
    const c = Mg(i);
    o.issues.push({
      origin: c,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), Vj = /* @__PURE__ */ ee("$ZodCheckMinLength", (e, t) => {
  var n;
  ln.init(e, t), (n = e._zod.def).when ?? (n.when = (o) => {
    const i = o.value;
    return !Ag(i) && i.length !== void 0;
  }), e._zod.onattach.push((o) => {
    const i = o._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > i && (o._zod.bag.minimum = t.minimum);
  }), e._zod.check = (o) => {
    const i = o.value;
    if (i.length >= t.minimum)
      return;
    const c = Mg(i);
    o.issues.push({
      origin: c,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: i,
      inst: e,
      continue: !t.abort
    });
  };
}), Uj = /* @__PURE__ */ ee("$ZodCheckLengthEquals", (e, t) => {
  var n;
  ln.init(e, t), (n = e._zod.def).when ?? (n.when = (o) => {
    const i = o.value;
    return !Ag(i) && i.length !== void 0;
  }), e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.minimum = t.length, i.maximum = t.length, i.length = t.length;
  }), e._zod.check = (o) => {
    const i = o.value, l = i.length;
    if (l === t.length)
      return;
    const c = Mg(i), f = l > t.length;
    o.issues.push({
      origin: c,
      ...f ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Nf = /* @__PURE__ */ ee("$ZodCheckStringFormat", (e, t) => {
  var n, o;
  ln.init(e, t), e._zod.onattach.push((i) => {
    const l = i._zod.bag;
    l.format = t.format, t.pattern && (l.patterns ?? (l.patterns = /* @__PURE__ */ new Set()), l.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: i.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (o = e._zod).check ?? (o.check = () => {
  });
}), Bj = /* @__PURE__ */ ee("$ZodCheckRegex", (e, t) => {
  Nf.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), $j = /* @__PURE__ */ ee("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = jj), Nf.init(e, t);
}), Hj = /* @__PURE__ */ ee("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = kj), Nf.init(e, t);
}), Zj = /* @__PURE__ */ ee("$ZodCheckIncludes", (e, t) => {
  ln.init(e, t);
  const n = Vi(t.includes), o = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = o, e._zod.onattach.push((i) => {
    const l = i._zod.bag;
    l.patterns ?? (l.patterns = /* @__PURE__ */ new Set()), l.patterns.add(o);
  }), e._zod.check = (i) => {
    i.value.includes(t.includes, t.position) || i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Fj = /* @__PURE__ */ ee("$ZodCheckStartsWith", (e, t) => {
  ln.init(e, t);
  const n = new RegExp(`^${Vi(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (o) => {
    o.value.startsWith(t.prefix) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Gj = /* @__PURE__ */ ee("$ZodCheckEndsWith", (e, t) => {
  ln.init(e, t);
  const n = new RegExp(`.*${Vi(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((o) => {
    const i = o._zod.bag;
    i.patterns ?? (i.patterns = /* @__PURE__ */ new Set()), i.patterns.add(n);
  }), e._zod.check = (o) => {
    o.value.endsWith(t.suffix) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Yj = /* @__PURE__ */ ee("$ZodCheckOverwrite", (e, t) => {
  ln.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class qj {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const o = t.split(`
`).filter((c) => c), i = Math.min(...o.map((c) => c.length - c.trimStart().length)), l = o.map((c) => c.slice(i)).map((c) => " ".repeat(this.indent * 2) + c);
    for (const c of l)
      this.content.push(c);
  }
  compile() {
    const t = Function, n = this?.args, i = [...(this?.content ?? [""]).map((l) => `  ${l}`)];
    return new t(...n, i.join(`
`));
  }
}
const Wj = {
  major: 4,
  minor: 3,
  patch: 6
}, ct = /* @__PURE__ */ ee("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Wj;
  const o = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && o.unshift(e);
  for (const i of o)
    for (const l of i._zod.onattach)
      l(e);
  if (o.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const i = (c, f, d) => {
      let h = Ti(c), m;
      for (const v of f) {
        if (v._zod.def.when) {
          if (!v._zod.def.when(c))
            continue;
        } else if (h)
          continue;
        const b = c.issues.length, x = v._zod.check(c);
        if (x instanceof Promise && d?.async === !1)
          throw new Ni();
        if (m || x instanceof Promise)
          m = (m ?? Promise.resolve()).then(async () => {
            await x, c.issues.length !== b && (h || (h = Ti(c, b)));
          });
        else {
          if (c.issues.length === b)
            continue;
          h || (h = Ti(c, b));
        }
      }
      return m ? m.then(() => c) : c;
    }, l = (c, f, d) => {
      if (Ti(c))
        return c.aborted = !0, c;
      const h = i(f, o, d);
      if (h instanceof Promise) {
        if (d.async === !1)
          throw new Ni();
        return h.then((m) => e._zod.parse(m, d));
      }
      return e._zod.parse(h, d);
    };
    e._zod.run = (c, f) => {
      if (f.skipChecks)
        return e._zod.parse(c, f);
      if (f.direction === "backward") {
        const h = e._zod.parse({ value: c.value, issues: [] }, { ...f, skipChecks: !0 });
        return h instanceof Promise ? h.then((m) => l(m, c, f)) : l(h, c, f);
      }
      const d = e._zod.parse(c, f);
      if (d instanceof Promise) {
        if (f.async === !1)
          throw new Ni();
        return d.then((h) => i(h, o, f));
      }
      return i(d, o, f);
    };
  }
  $e(e, "~standard", () => ({
    validate: (i) => {
      try {
        const l = ej(e, i);
        return l.success ? { value: l.data } : { issues: l.error?.issues };
      } catch {
        return tj(e, i).then((c) => c.success ? { value: c.data } : { issues: c.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), Ng = /* @__PURE__ */ ee("$ZodString", (e, t) => {
  ct.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? zj(e._zod.bag), e._zod.parse = (n, o) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), dt = /* @__PURE__ */ ee("$ZodStringFormat", (e, t) => {
  Nf.init(e, t), Ng.init(e, t);
}), Xj = /* @__PURE__ */ ee("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = vj), dt.init(e, t);
}), Kj = /* @__PURE__ */ ee("$ZodUUID", (e, t) => {
  if (t.version) {
    const o = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (o === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = $S(o));
  } else
    t.pattern ?? (t.pattern = $S());
  dt.init(e, t);
}), Jj = /* @__PURE__ */ ee("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = yj), dt.init(e, t);
}), Qj = /* @__PURE__ */ ee("$ZodURL", (e, t) => {
  dt.init(e, t), e._zod.check = (n) => {
    try {
      const o = n.value.trim(), i = new URL(o);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(i.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = i.href : n.value = o;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), ek = /* @__PURE__ */ ee("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = xj()), dt.init(e, t);
}), tk = /* @__PURE__ */ ee("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = mj), dt.init(e, t);
}), nk = /* @__PURE__ */ ee("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = uj), dt.init(e, t);
}), rk = /* @__PURE__ */ ee("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = fj), dt.init(e, t);
}), ok = /* @__PURE__ */ ee("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = dj), dt.init(e, t);
}), ak = /* @__PURE__ */ ee("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = hj), dt.init(e, t);
}), ik = /* @__PURE__ */ ee("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = pj), dt.init(e, t);
}), sk = /* @__PURE__ */ ee("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = Mj(t)), dt.init(e, t);
}), lk = /* @__PURE__ */ ee("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Aj), dt.init(e, t);
}), ck = /* @__PURE__ */ ee("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Rj(t)), dt.init(e, t);
}), uk = /* @__PURE__ */ ee("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = gj), dt.init(e, t);
}), fk = /* @__PURE__ */ ee("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Sj), dt.init(e, t), e._zod.bag.format = "ipv4";
}), dk = /* @__PURE__ */ ee("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = wj), dt.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), hk = /* @__PURE__ */ ee("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Ej), dt.init(e, t);
}), pk = /* @__PURE__ */ ee("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = _j), dt.init(e, t), e._zod.check = (n) => {
    const o = n.value.split("/");
    try {
      if (o.length !== 2)
        throw new Error();
      const [i, l] = o;
      if (!l)
        throw new Error();
      const c = Number(l);
      if (`${c}` !== l)
        throw new Error();
      if (c < 0 || c > 128)
        throw new Error();
      new URL(`http://[${i}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function s_(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const mk = /* @__PURE__ */ ee("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Tj), dt.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (n) => {
    s_(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function gk(e) {
  if (!e_.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (o) => o === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return s_(n);
}
const vk = /* @__PURE__ */ ee("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = e_), dt.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (n) => {
    gk(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), yk = /* @__PURE__ */ ee("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Cj), dt.init(e, t);
});
function bk(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [o] = n;
    if (!o)
      return !1;
    const i = JSON.parse(atob(o));
    return !("typ" in i && i?.typ !== "JWT" || !i.alg || t && (!("alg" in i) || i.alg !== t));
  } catch {
    return !1;
  }
}
const xk = /* @__PURE__ */ ee("$ZodJWT", (e, t) => {
  dt.init(e, t), e._zod.check = (n) => {
    bk(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), l_ = /* @__PURE__ */ ee("$ZodNumber", (e, t) => {
  ct.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? r_, e._zod.parse = (n, o) => {
    if (t.coerce)
      try {
        n.value = Number(n.value);
      } catch {
      }
    const i = n.value;
    if (typeof i == "number" && !Number.isNaN(i) && Number.isFinite(i))
      return n;
    const l = typeof i == "number" ? Number.isNaN(i) ? "NaN" : Number.isFinite(i) ? void 0 : "Infinity" : void 0;
    return n.issues.push({
      expected: "number",
      code: "invalid_type",
      input: i,
      inst: e,
      ...l ? { received: l } : {}
    }), n;
  };
}), Sk = /* @__PURE__ */ ee("$ZodNumberFormat", (e, t) => {
  Lj.init(e, t), l_.init(e, t);
}), wk = /* @__PURE__ */ ee("$ZodBoolean", (e, t) => {
  ct.init(e, t), e._zod.pattern = Nj, e._zod.parse = (n, o) => {
    if (t.coerce)
      try {
        n.value = !!n.value;
      } catch {
      }
    const i = n.value;
    return typeof i == "boolean" || n.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), Ek = /* @__PURE__ */ ee("$ZodNull", (e, t) => {
  ct.init(e, t), e._zod.pattern = Oj, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (n, o) => {
    const i = n.value;
    return i === null || n.issues.push({
      expected: "null",
      code: "invalid_type",
      input: i,
      inst: e
    }), n;
  };
}), _k = /* @__PURE__ */ ee("$ZodUnknown", (e, t) => {
  ct.init(e, t), e._zod.parse = (n) => n;
}), Tk = /* @__PURE__ */ ee("$ZodNever", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, o) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function HS(e, t, n) {
  e.issues.length && t.issues.push(...Ci(n, e.issues)), t.value[n] = e.value;
}
const Ck = /* @__PURE__ */ ee("$ZodArray", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, o) => {
    const i = n.value;
    if (!Array.isArray(i))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    n.value = Array(i.length);
    const l = [];
    for (let c = 0; c < i.length; c++) {
      const f = i[c], d = t.element._zod.run({
        value: f,
        issues: []
      }, o);
      d instanceof Promise ? l.push(d.then((h) => HS(h, n, c))) : HS(d, n, c);
    }
    return l.length ? Promise.all(l).then(() => n) : n;
  };
});
function Gu(e, t, n, o, i) {
  if (e.issues.length) {
    if (i && !(n in o))
      return;
    t.issues.push(...Ci(n, e.issues));
  }
  e.value === void 0 ? n in o && (t.value[n] = void 0) : t.value[n] = e.value;
}
function c_(e) {
  const t = Object.keys(e.shape);
  for (const o of t)
    if (!e.shape?.[o]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${o}": expected a Zod schema`);
  const n = H2(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(n)
  };
}
function u_(e, t, n, o, i, l) {
  const c = [], f = i.keySet, d = i.catchall._zod, h = d.def.type, m = d.optout === "optional";
  for (const v in t) {
    if (f.has(v))
      continue;
    if (h === "never") {
      c.push(v);
      continue;
    }
    const b = d.run({ value: t[v], issues: [] }, o);
    b instanceof Promise ? e.push(b.then((x) => Gu(x, n, v, t, m))) : Gu(b, n, v, t, m);
  }
  return c.length && n.issues.push({
    code: "unrecognized_keys",
    keys: c,
    input: t,
    inst: l
  }), e.length ? Promise.all(e).then(() => n) : n;
}
const Ak = /* @__PURE__ */ ee("$ZodObject", (e, t) => {
  if (ct.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const f = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const d = { ...f };
        return Object.defineProperty(t, "shape", {
          value: d
        }), d;
      }
    });
  }
  const o = Mf(() => c_(t));
  $e(e._zod, "propValues", () => {
    const f = t.shape, d = {};
    for (const h in f) {
      const m = f[h]._zod;
      if (m.values) {
        d[h] ?? (d[h] = /* @__PURE__ */ new Set());
        for (const v of m.values)
          d[h].add(v);
      }
    }
    return d;
  });
  const i = vl, l = t.catchall;
  let c;
  e._zod.parse = (f, d) => {
    c ?? (c = o.value);
    const h = f.value;
    if (!i(h))
      return f.issues.push({
        expected: "object",
        code: "invalid_type",
        input: h,
        inst: e
      }), f;
    f.value = {};
    const m = [], v = c.shape;
    for (const b of c.keys) {
      const x = v[b], E = x._zod.optout === "optional", w = x._zod.run({ value: h[b], issues: [] }, d);
      w instanceof Promise ? m.push(w.then((C) => Gu(C, f, b, h, E))) : Gu(w, f, b, h, E);
    }
    return l ? u_(m, h, f, d, o.value, e) : m.length ? Promise.all(m).then(() => f) : f;
  };
}), Rk = /* @__PURE__ */ ee("$ZodObjectJIT", (e, t) => {
  Ak.init(e, t);
  const n = e._zod.parse, o = Mf(() => c_(t)), i = (b) => {
    const x = new qj(["shape", "payload", "ctx"]), E = o.value, w = (T) => {
      const D = BS(T);
      return `shape[${D}]._zod.run({ value: input[${D}], issues: [] }, ctx)`;
    };
    x.write("const input = payload.value;");
    const C = /* @__PURE__ */ Object.create(null);
    let A = 0;
    for (const T of E.keys)
      C[T] = `key_${A++}`;
    x.write("const newResult = {};");
    for (const T of E.keys) {
      const D = C[T], O = BS(T), R = b[T]?._zod?.optout === "optional";
      x.write(`const ${D} = ${w(T)};`), R ? x.write(`
        if (${D}.issues.length) {
          if (${O} in input) {
            payload.issues = payload.issues.concat(${D}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${O}, ...iss.path] : [${O}]
            })));
          }
        }
        
        if (${D}.value === undefined) {
          if (${O} in input) {
            newResult[${O}] = undefined;
          }
        } else {
          newResult[${O}] = ${D}.value;
        }
        
      `) : x.write(`
        if (${D}.issues.length) {
          payload.issues = payload.issues.concat(${D}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${O}, ...iss.path] : [${O}]
          })));
        }
        
        if (${D}.value === undefined) {
          if (${O} in input) {
            newResult[${O}] = undefined;
          }
        } else {
          newResult[${O}] = ${D}.value;
        }
        
      `);
    }
    x.write("payload.value = newResult;"), x.write("return payload;");
    const M = x.compile();
    return (T, D) => M(b, T, D);
  };
  let l;
  const c = vl, f = !YE.jitless, h = f && B2.value, m = t.catchall;
  let v;
  e._zod.parse = (b, x) => {
    v ?? (v = o.value);
    const E = b.value;
    return c(E) ? f && h && x?.async === !1 && x.jitless !== !0 ? (l || (l = i(t.shape)), b = l(b, x), m ? u_([], E, b, x, v, e) : b) : n(b, x) : (b.issues.push({
      expected: "object",
      code: "invalid_type",
      input: E,
      inst: e
    }), b);
  };
});
function ZS(e, t, n, o) {
  for (const l of e)
    if (l.issues.length === 0)
      return t.value = l.value, t;
  const i = e.filter((l) => !Ti(l));
  return i.length === 1 ? (t.value = i[0].value, i[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((l) => l.issues.map((c) => jo(c, o, Oo())))
  }), t);
}
const f_ = /* @__PURE__ */ ee("$ZodUnion", (e, t) => {
  ct.init(e, t), $e(e._zod, "optin", () => t.options.some((i) => i._zod.optin === "optional") ? "optional" : void 0), $e(e._zod, "optout", () => t.options.some((i) => i._zod.optout === "optional") ? "optional" : void 0), $e(e._zod, "values", () => {
    if (t.options.every((i) => i._zod.values))
      return new Set(t.options.flatMap((i) => Array.from(i._zod.values)));
  }), $e(e._zod, "pattern", () => {
    if (t.options.every((i) => i._zod.pattern)) {
      const i = t.options.map((l) => l._zod.pattern);
      return new RegExp(`^(${i.map((l) => Rg(l.source)).join("|")})$`);
    }
  });
  const n = t.options.length === 1, o = t.options[0]._zod.run;
  e._zod.parse = (i, l) => {
    if (n)
      return o(i, l);
    let c = !1;
    const f = [];
    for (const d of t.options) {
      const h = d._zod.run({
        value: i.value,
        issues: []
      }, l);
      if (h instanceof Promise)
        f.push(h), c = !0;
      else {
        if (h.issues.length === 0)
          return h;
        f.push(h);
      }
    }
    return c ? Promise.all(f).then((d) => ZS(d, i, e, l)) : ZS(f, i, e, l);
  };
}), Mk = /* @__PURE__ */ ee("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, f_.init(e, t);
  const n = e._zod.parse;
  $e(e._zod, "propValues", () => {
    const i = {};
    for (const l of t.options) {
      const c = l._zod.propValues;
      if (!c || Object.keys(c).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(l)}"`);
      for (const [f, d] of Object.entries(c)) {
        i[f] || (i[f] = /* @__PURE__ */ new Set());
        for (const h of d)
          i[f].add(h);
      }
    }
    return i;
  });
  const o = Mf(() => {
    const i = t.options, l = /* @__PURE__ */ new Map();
    for (const c of i) {
      const f = c._zod.propValues?.[t.discriminator];
      if (!f || f.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(c)}"`);
      for (const d of f) {
        if (l.has(d))
          throw new Error(`Duplicate discriminator value "${String(d)}"`);
        l.set(d, c);
      }
    }
    return l;
  });
  e._zod.parse = (i, l) => {
    const c = i.value;
    if (!vl(c))
      return i.issues.push({
        code: "invalid_type",
        expected: "object",
        input: c,
        inst: e
      }), i;
    const f = o.value.get(c?.[t.discriminator]);
    return f ? f._zod.run(i, l) : t.unionFallback ? n(i, l) : (i.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: c,
      path: [t.discriminator],
      inst: e
    }), i);
  };
}), zk = /* @__PURE__ */ ee("$ZodIntersection", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, o) => {
    const i = n.value, l = t.left._zod.run({ value: i, issues: [] }, o), c = t.right._zod.run({ value: i, issues: [] }, o);
    return l instanceof Promise || c instanceof Promise ? Promise.all([l, c]).then(([d, h]) => FS(n, d, h)) : FS(n, l, c);
  };
});
function Mm(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (Ii(e) && Ii(t)) {
    const n = Object.keys(t), o = Object.keys(e).filter((l) => n.indexOf(l) !== -1), i = { ...e, ...t };
    for (const l of o) {
      const c = Mm(e[l], t[l]);
      if (!c.valid)
        return {
          valid: !1,
          mergeErrorPath: [l, ...c.mergeErrorPath]
        };
      i[l] = c.data;
    }
    return { valid: !0, data: i };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let o = 0; o < e.length; o++) {
      const i = e[o], l = t[o], c = Mm(i, l);
      if (!c.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...c.mergeErrorPath]
        };
      n.push(c.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function FS(e, t, n) {
  const o = /* @__PURE__ */ new Map();
  let i;
  for (const f of t.issues)
    if (f.code === "unrecognized_keys") {
      i ?? (i = f);
      for (const d of f.keys)
        o.has(d) || o.set(d, {}), o.get(d).l = !0;
    } else
      e.issues.push(f);
  for (const f of n.issues)
    if (f.code === "unrecognized_keys")
      for (const d of f.keys)
        o.has(d) || o.set(d, {}), o.get(d).r = !0;
    else
      e.issues.push(f);
  const l = [...o].filter(([, f]) => f.l && f.r).map(([f]) => f);
  if (l.length && i && e.issues.push({ ...i, keys: l }), Ti(e))
    return e;
  const c = Mm(t.value, n.value);
  if (!c.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(c.mergeErrorPath)}`);
  return e.value = c.data, e;
}
const Dk = /* @__PURE__ */ ee("$ZodRecord", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, o) => {
    const i = n.value;
    if (!Ii(i))
      return n.issues.push({
        expected: "record",
        code: "invalid_type",
        input: i,
        inst: e
      }), n;
    const l = [], c = t.keyType._zod.values;
    if (c) {
      n.value = {};
      const f = /* @__PURE__ */ new Set();
      for (const h of c)
        if (typeof h == "string" || typeof h == "number" || typeof h == "symbol") {
          f.add(typeof h == "number" ? h.toString() : h);
          const m = t.valueType._zod.run({ value: i[h], issues: [] }, o);
          m instanceof Promise ? l.push(m.then((v) => {
            v.issues.length && n.issues.push(...Ci(h, v.issues)), n.value[h] = v.value;
          })) : (m.issues.length && n.issues.push(...Ci(h, m.issues)), n.value[h] = m.value);
        }
      let d;
      for (const h in i)
        f.has(h) || (d = d ?? [], d.push(h));
      d && d.length > 0 && n.issues.push({
        code: "unrecognized_keys",
        input: i,
        inst: e,
        keys: d
      });
    } else {
      n.value = {};
      for (const f of Reflect.ownKeys(i)) {
        if (f === "__proto__")
          continue;
        let d = t.keyType._zod.run({ value: f, issues: [] }, o);
        if (d instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof f == "string" && r_.test(f) && d.issues.length) {
          const v = t.keyType._zod.run({ value: Number(f), issues: [] }, o);
          if (v instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          v.issues.length === 0 && (d = v);
        }
        if (d.issues.length) {
          t.mode === "loose" ? n.value[f] = i[f] : n.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: d.issues.map((v) => jo(v, o, Oo())),
            input: f,
            path: [f],
            inst: e
          });
          continue;
        }
        const m = t.valueType._zod.run({ value: i[f], issues: [] }, o);
        m instanceof Promise ? l.push(m.then((v) => {
          v.issues.length && n.issues.push(...Ci(f, v.issues)), n.value[d.value] = v.value;
        })) : (m.issues.length && n.issues.push(...Ci(f, m.issues)), n.value[d.value] = m.value);
      }
    }
    return l.length ? Promise.all(l).then(() => n) : n;
  };
}), Nk = /* @__PURE__ */ ee("$ZodEnum", (e, t) => {
  ct.init(e, t);
  const n = qE(t.entries), o = new Set(n);
  e._zod.values = o, e._zod.pattern = new RegExp(`^(${n.filter((i) => $2.has(typeof i)).map((i) => typeof i == "string" ? Vi(i) : i.toString()).join("|")})$`), e._zod.parse = (i, l) => {
    const c = i.value;
    return o.has(c) || i.issues.push({
      code: "invalid_value",
      values: n,
      input: c,
      inst: e
    }), i;
  };
}), Ok = /* @__PURE__ */ ee("$ZodLiteral", (e, t) => {
  if (ct.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const n = new Set(t.values);
  e._zod.values = n, e._zod.pattern = new RegExp(`^(${t.values.map((o) => typeof o == "string" ? Vi(o) : o ? Vi(o.toString()) : String(o)).join("|")})$`), e._zod.parse = (o, i) => {
    const l = o.value;
    return n.has(l) || o.issues.push({
      code: "invalid_value",
      values: t.values,
      input: l,
      inst: e
    }), o;
  };
}), jk = /* @__PURE__ */ ee("$ZodTransform", (e, t) => {
  ct.init(e, t), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      throw new GE(e.constructor.name);
    const i = t.transform(n.value, n);
    if (o.async)
      return (i instanceof Promise ? i : Promise.resolve(i)).then((c) => (n.value = c, n));
    if (i instanceof Promise)
      throw new Ni();
    return n.value = i, n;
  };
});
function GS(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const d_ = /* @__PURE__ */ ee("$ZodOptional", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", $e(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), $e(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Rg(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, o) => {
    if (t.innerType._zod.optin === "optional") {
      const i = t.innerType._zod.run(n, o);
      return i instanceof Promise ? i.then((l) => GS(l, n.value)) : GS(i, n.value);
    }
    return n.value === void 0 ? n : t.innerType._zod.run(n, o);
  };
}), kk = /* @__PURE__ */ ee("$ZodExactOptional", (e, t) => {
  d_.init(e, t), $e(e._zod, "values", () => t.innerType._zod.values), $e(e._zod, "pattern", () => t.innerType._zod.pattern), e._zod.parse = (n, o) => t.innerType._zod.run(n, o);
}), Pk = /* @__PURE__ */ ee("$ZodNullable", (e, t) => {
  ct.init(e, t), $e(e._zod, "optin", () => t.innerType._zod.optin), $e(e._zod, "optout", () => t.innerType._zod.optout), $e(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${Rg(n.source)}|null)$`) : void 0;
  }), $e(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, o) => n.value === null ? n : t.innerType._zod.run(n, o);
}), Lk = /* @__PURE__ */ ee("$ZodDefault", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", $e(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      return t.innerType._zod.run(n, o);
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const i = t.innerType._zod.run(n, o);
    return i instanceof Promise ? i.then((l) => YS(l, t)) : YS(i, t);
  };
});
function YS(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Ik = /* @__PURE__ */ ee("$ZodPrefault", (e, t) => {
  ct.init(e, t), e._zod.optin = "optional", $e(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, o) => (o.direction === "backward" || n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, o));
}), Vk = /* @__PURE__ */ ee("$ZodNonOptional", (e, t) => {
  ct.init(e, t), $e(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((o) => o !== void 0)) : void 0;
  }), e._zod.parse = (n, o) => {
    const i = t.innerType._zod.run(n, o);
    return i instanceof Promise ? i.then((l) => qS(l, e)) : qS(i, e);
  };
});
function qS(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Uk = /* @__PURE__ */ ee("$ZodCatch", (e, t) => {
  ct.init(e, t), $e(e._zod, "optin", () => t.innerType._zod.optin), $e(e._zod, "optout", () => t.innerType._zod.optout), $e(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      return t.innerType._zod.run(n, o);
    const i = t.innerType._zod.run(n, o);
    return i instanceof Promise ? i.then((l) => (n.value = l.value, l.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: l.issues.map((c) => jo(c, o, Oo()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = i.value, i.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: i.issues.map((l) => jo(l, o, Oo()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), Bk = /* @__PURE__ */ ee("$ZodPipe", (e, t) => {
  ct.init(e, t), $e(e._zod, "values", () => t.in._zod.values), $e(e._zod, "optin", () => t.in._zod.optin), $e(e._zod, "optout", () => t.out._zod.optout), $e(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, o) => {
    if (o.direction === "backward") {
      const l = t.out._zod.run(n, o);
      return l instanceof Promise ? l.then((c) => bu(c, t.in, o)) : bu(l, t.in, o);
    }
    const i = t.in._zod.run(n, o);
    return i instanceof Promise ? i.then((l) => bu(l, t.out, o)) : bu(i, t.out, o);
  };
});
function bu(e, t, n) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, n);
}
const $k = /* @__PURE__ */ ee("$ZodReadonly", (e, t) => {
  ct.init(e, t), $e(e._zod, "propValues", () => t.innerType._zod.propValues), $e(e._zod, "values", () => t.innerType._zod.values), $e(e._zod, "optin", () => t.innerType?._zod?.optin), $e(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      return t.innerType._zod.run(n, o);
    const i = t.innerType._zod.run(n, o);
    return i instanceof Promise ? i.then(WS) : WS(i);
  };
});
function WS(e) {
  return e.value = Object.freeze(e.value), e;
}
const Hk = /* @__PURE__ */ ee("$ZodLazy", (e, t) => {
  ct.init(e, t), $e(e._zod, "innerType", () => t.getter()), $e(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), $e(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), $e(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), $e(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (n, o) => e._zod.innerType._zod.run(n, o);
}), Zk = /* @__PURE__ */ ee("$ZodCustom", (e, t) => {
  ln.init(e, t), ct.init(e, t), e._zod.parse = (n, o) => n, e._zod.check = (n) => {
    const o = n.value, i = t.fn(o);
    if (i instanceof Promise)
      return i.then((l) => XS(l, n, o, e));
    XS(i, n, o, e);
  };
});
function XS(e, t, n, o) {
  if (!e) {
    const i = {
      code: "custom",
      input: n,
      inst: o,
      // incorporates params.error into issue reporting
      path: [...o._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !o._zod.def.abort
      // params: inst._zod.def.params,
    };
    o._zod.def.params && (i.params = o._zod.def.params), t.issues.push(yl(i));
  }
}
var KS;
class Fk {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const o = n[0];
    return this._map.set(t, o), o && typeof o == "object" && "id" in o && this._idmap.set(o.id, t), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const o = { ...this.get(n) ?? {} };
      delete o.id;
      const i = { ...o, ...this._map.get(t) };
      return Object.keys(i).length ? i : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function Gk() {
  return new Fk();
}
(KS = globalThis).__zod_globalRegistry ?? (KS.__zod_globalRegistry = Gk());
const el = globalThis.__zod_globalRegistry;
// @__NO_SIDE_EFFECTS__
function Yk(e, t) {
  return new e({
    type: "string",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function qk(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function JS(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Wk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Xk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Kk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Jk(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function Qk(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function eP(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function tP(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function nP(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function rP(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function oP(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function aP(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function iP(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function sP(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function lP(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function cP(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function uP(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function fP(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function dP(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function hP(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function pP(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function mP(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function gP(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function vP(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function yP(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function bP(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function xP(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function SP(e, t) {
  return new e({
    type: "boolean",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function wP(e, t) {
  return new e({
    type: "null",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function EP(e) {
  return new e({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _P(e, t) {
  return new e({
    type: "never",
    ...we(t)
  });
}
// @__NO_SIDE_EFFECTS__
function QS(e, t) {
  return new a_({
    check: "less_than",
    ...we(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function Op(e, t) {
  return new a_({
    check: "less_than",
    ...we(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function ew(e, t) {
  return new i_({
    check: "greater_than",
    ...we(t),
    value: e,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function jp(e, t) {
  return new i_({
    check: "greater_than",
    ...we(t),
    value: e,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function tw(e, t) {
  return new Pj({
    check: "multiple_of",
    ...we(t),
    value: e
  });
}
// @__NO_SIDE_EFFECTS__
function h_(e, t) {
  return new Ij({
    check: "max_length",
    ...we(t),
    maximum: e
  });
}
// @__NO_SIDE_EFFECTS__
function Yu(e, t) {
  return new Vj({
    check: "min_length",
    ...we(t),
    minimum: e
  });
}
// @__NO_SIDE_EFFECTS__
function p_(e, t) {
  return new Uj({
    check: "length_equals",
    ...we(t),
    length: e
  });
}
// @__NO_SIDE_EFFECTS__
function TP(e, t) {
  return new Bj({
    check: "string_format",
    format: "regex",
    ...we(t),
    pattern: e
  });
}
// @__NO_SIDE_EFFECTS__
function CP(e) {
  return new $j({
    check: "string_format",
    format: "lowercase",
    ...we(e)
  });
}
// @__NO_SIDE_EFFECTS__
function AP(e) {
  return new Hj({
    check: "string_format",
    format: "uppercase",
    ...we(e)
  });
}
// @__NO_SIDE_EFFECTS__
function RP(e, t) {
  return new Zj({
    check: "string_format",
    format: "includes",
    ...we(t),
    includes: e
  });
}
// @__NO_SIDE_EFFECTS__
function MP(e, t) {
  return new Fj({
    check: "string_format",
    format: "starts_with",
    ...we(t),
    prefix: e
  });
}
// @__NO_SIDE_EFFECTS__
function zP(e, t) {
  return new Gj({
    check: "string_format",
    format: "ends_with",
    ...we(t),
    suffix: e
  });
}
// @__NO_SIDE_EFFECTS__
function Zi(e) {
  return new Yj({
    check: "overwrite",
    tx: e
  });
}
// @__NO_SIDE_EFFECTS__
function DP(e) {
  return /* @__PURE__ */ Zi((t) => t.normalize(e));
}
// @__NO_SIDE_EFFECTS__
function NP() {
  return /* @__PURE__ */ Zi((e) => e.trim());
}
// @__NO_SIDE_EFFECTS__
function OP() {
  return /* @__PURE__ */ Zi((e) => e.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function jP() {
  return /* @__PURE__ */ Zi((e) => e.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function kP() {
  return /* @__PURE__ */ Zi((e) => U2(e));
}
// @__NO_SIDE_EFFECTS__
function PP(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...we(n)
  });
}
// @__NO_SIDE_EFFECTS__
function LP(e, t, n) {
  const o = we(n);
  return o.abort ?? (o.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...o
  });
}
// @__NO_SIDE_EFFECTS__
function IP(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...we(n)
  });
}
// @__NO_SIDE_EFFECTS__
function VP(e) {
  const t = /* @__PURE__ */ UP((n) => (n.addIssue = (o) => {
    if (typeof o == "string")
      n.issues.push(yl(o, n.value, t._zod.def));
    else {
      const i = o;
      i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = t), i.continue ?? (i.continue = !t._zod.def.abort), n.issues.push(yl(i));
    }
  }, e(n.value, n)));
  return t;
}
// @__NO_SIDE_EFFECTS__
function UP(e, t) {
  const n = new ln({
    check: "custom",
    ...we(t)
  });
  return n._zod.check = e, n;
}
function qu(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? el,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function rt(e, t, n = { path: [], schemaPath: [] }) {
  var o;
  const i = e._zod.def, l = t.seen.get(e);
  if (l)
    return l.count++, n.schemaPath.includes(e) && (l.cycle = n.path), l.schema;
  const c = { schema: {}, count: 1, cycle: void 0, path: n.path };
  t.seen.set(e, c);
  const f = e._zod.toJSONSchema?.();
  if (f)
    c.schema = f;
  else {
    const m = {
      ...n,
      schemaPath: [...n.schemaPath, e],
      path: n.path
    };
    if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, c.schema, m);
    else {
      const b = c.schema, x = t.processors[i.type];
      if (!x)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${i.type}`);
      x(e, t, b, m);
    }
    const v = e._zod.parent;
    v && (c.ref || (c.ref = v), rt(v, t, m), t.seen.get(v).isParent = !0);
  }
  const d = t.metadataRegistry.get(e);
  return d && Object.assign(c.schema, d), t.io === "input" && qt(e) && (delete c.schema.examples, delete c.schema.default), t.io === "input" && c.schema._prefault && ((o = c.schema).default ?? (o.default = c.schema._prefault)), delete c.schema._prefault, t.seen.get(e).schema;
}
function Wu(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const o = /* @__PURE__ */ new Map();
  for (const c of e.seen.entries()) {
    const f = e.metadataRegistry.get(c[0])?.id;
    if (f) {
      const d = o.get(f);
      if (d && d !== c[0])
        throw new Error(`Duplicate schema id "${f}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      o.set(f, c[0]);
    }
  }
  const i = (c) => {
    const f = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const v = e.external.registry.get(c[0])?.id, b = e.external.uri ?? ((E) => E);
      if (v)
        return { ref: b(v) };
      const x = c[1].defId ?? c[1].schema.id ?? `schema${e.counter++}`;
      return c[1].defId = x, { defId: x, ref: `${b("__shared")}#/${f}/${x}` };
    }
    if (c[1] === n)
      return { ref: "#" };
    const h = `#/${f}/`, m = c[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: m, ref: h + m };
  }, l = (c) => {
    if (c[1].schema.$ref)
      return;
    const f = c[1], { ref: d, defId: h } = i(c);
    f.def = { ...f.schema }, h && (f.defId = h);
    const m = f.schema;
    for (const v in m)
      delete m[v];
    m.$ref = d;
  };
  if (e.cycles === "throw")
    for (const c of e.seen.entries()) {
      const f = c[1];
      if (f.cycle)
        throw new Error(`Cycle detected: #/${f.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const c of e.seen.entries()) {
    const f = c[1];
    if (t === c[0]) {
      l(c);
      continue;
    }
    if (e.external) {
      const h = e.external.registry.get(c[0])?.id;
      if (t !== c[0] && h) {
        l(c);
        continue;
      }
    }
    if (e.metadataRegistry.get(c[0])?.id) {
      l(c);
      continue;
    }
    if (f.cycle) {
      l(c);
      continue;
    }
    if (f.count > 1 && e.reused === "ref") {
      l(c);
      continue;
    }
  }
}
function Xu(e, t) {
  const n = e.seen.get(t);
  if (!n)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const o = (c) => {
    const f = e.seen.get(c);
    if (f.ref === null)
      return;
    const d = f.def ?? f.schema, h = { ...d }, m = f.ref;
    if (f.ref = null, m) {
      o(m);
      const b = e.seen.get(m), x = b.schema;
      if (x.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (d.allOf = d.allOf ?? [], d.allOf.push(x)) : Object.assign(d, x), Object.assign(d, h), c._zod.parent === m)
        for (const w in d)
          w === "$ref" || w === "allOf" || w in h || delete d[w];
      if (x.$ref && b.def)
        for (const w in d)
          w === "$ref" || w === "allOf" || w in b.def && JSON.stringify(d[w]) === JSON.stringify(b.def[w]) && delete d[w];
    }
    const v = c._zod.parent;
    if (v && v !== m) {
      o(v);
      const b = e.seen.get(v);
      if (b?.schema.$ref && (d.$ref = b.schema.$ref, b.def))
        for (const x in d)
          x === "$ref" || x === "allOf" || x in b.def && JSON.stringify(d[x]) === JSON.stringify(b.def[x]) && delete d[x];
    }
    e.override({
      zodSchema: c,
      jsonSchema: d,
      path: f.path ?? []
    });
  };
  for (const c of [...e.seen.entries()].reverse())
    o(c[0]);
  const i = {};
  if (e.target === "draft-2020-12" ? i.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? i.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? i.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const c = e.external.registry.get(t)?.id;
    if (!c)
      throw new Error("Schema is missing an `id` property");
    i.$id = e.external.uri(c);
  }
  Object.assign(i, n.def ?? n.schema);
  const l = e.external?.defs ?? {};
  for (const c of e.seen.entries()) {
    const f = c[1];
    f.def && f.defId && (l[f.defId] = f.def);
  }
  e.external || Object.keys(l).length > 0 && (e.target === "draft-2020-12" ? i.$defs = l : i.definitions = l);
  try {
    const c = JSON.parse(JSON.stringify(i));
    return Object.defineProperty(c, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: Ku(t, "input", e.processors),
          output: Ku(t, "output", e.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), c;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function qt(e, t) {
  const n = t ?? { seen: /* @__PURE__ */ new Set() };
  if (n.seen.has(e))
    return !1;
  n.seen.add(e);
  const o = e._zod.def;
  if (o.type === "transform")
    return !0;
  if (o.type === "array")
    return qt(o.element, n);
  if (o.type === "set")
    return qt(o.valueType, n);
  if (o.type === "lazy")
    return qt(o.getter(), n);
  if (o.type === "promise" || o.type === "optional" || o.type === "nonoptional" || o.type === "nullable" || o.type === "readonly" || o.type === "default" || o.type === "prefault")
    return qt(o.innerType, n);
  if (o.type === "intersection")
    return qt(o.left, n) || qt(o.right, n);
  if (o.type === "record" || o.type === "map")
    return qt(o.keyType, n) || qt(o.valueType, n);
  if (o.type === "pipe")
    return qt(o.in, n) || qt(o.out, n);
  if (o.type === "object") {
    for (const i in o.shape)
      if (qt(o.shape[i], n))
        return !0;
    return !1;
  }
  if (o.type === "union") {
    for (const i of o.options)
      if (qt(i, n))
        return !0;
    return !1;
  }
  if (o.type === "tuple") {
    for (const i of o.items)
      if (qt(i, n))
        return !0;
    return !!(o.rest && qt(o.rest, n));
  }
  return !1;
}
const BP = (e, t = {}) => (n) => {
  const o = qu({ ...n, processors: t });
  return rt(e, o), Wu(o, e), Xu(o, e);
}, Ku = (e, t, n = {}) => (o) => {
  const { libraryOptions: i, target: l } = o ?? {}, c = qu({ ...i ?? {}, target: l, io: t, processors: n });
  return rt(e, c), Wu(c, e), Xu(c, e);
}, $P = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, m_ = (e, t, n, o) => {
  const i = n;
  i.type = "string";
  const { minimum: l, maximum: c, format: f, patterns: d, contentEncoding: h } = e._zod.bag;
  if (typeof l == "number" && (i.minLength = l), typeof c == "number" && (i.maxLength = c), f && (i.format = $P[f] ?? f, i.format === "" && delete i.format, f === "time" && delete i.format), h && (i.contentEncoding = h), d && d.size > 0) {
    const m = [...d];
    m.length === 1 ? i.pattern = m[0].source : m.length > 1 && (i.allOf = [
      ...m.map((v) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: v.source
      }))
    ]);
  }
}, g_ = (e, t, n, o) => {
  const i = n, { minimum: l, maximum: c, format: f, multipleOf: d, exclusiveMaximum: h, exclusiveMinimum: m } = e._zod.bag;
  typeof f == "string" && f.includes("int") ? i.type = "integer" : i.type = "number", typeof m == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.minimum = m, i.exclusiveMinimum = !0) : i.exclusiveMinimum = m), typeof l == "number" && (i.minimum = l, typeof m == "number" && t.target !== "draft-04" && (m >= l ? delete i.minimum : delete i.exclusiveMinimum)), typeof h == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (i.maximum = h, i.exclusiveMaximum = !0) : i.exclusiveMaximum = h), typeof c == "number" && (i.maximum = c, typeof h == "number" && t.target !== "draft-04" && (h <= c ? delete i.maximum : delete i.exclusiveMaximum)), typeof d == "number" && (i.multipleOf = d);
}, v_ = (e, t, n, o) => {
  n.type = "boolean";
}, HP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, ZP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, y_ = (e, t, n, o) => {
  t.target === "openapi-3.0" ? (n.type = "string", n.nullable = !0, n.enum = [null]) : n.type = "null";
}, FP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, GP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, b_ = (e, t, n, o) => {
  n.not = {};
}, YP = (e, t, n, o) => {
}, x_ = (e, t, n, o) => {
}, qP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, S_ = (e, t, n, o) => {
  const i = e._zod.def, l = qE(i.entries);
  l.every((c) => typeof c == "number") && (n.type = "number"), l.every((c) => typeof c == "string") && (n.type = "string"), n.enum = l;
}, w_ = (e, t, n, o) => {
  const i = e._zod.def, l = [];
  for (const c of i.values)
    if (c === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof c == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      l.push(Number(c));
    } else
      l.push(c);
  if (l.length !== 0) if (l.length === 1) {
    const c = l[0];
    n.type = c === null ? "null" : typeof c, t.target === "draft-04" || t.target === "openapi-3.0" ? n.enum = [c] : n.const = c;
  } else
    l.every((c) => typeof c == "number") && (n.type = "number"), l.every((c) => typeof c == "string") && (n.type = "string"), l.every((c) => typeof c == "boolean") && (n.type = "boolean"), l.every((c) => c === null) && (n.type = "null"), n.enum = l;
}, WP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, XP = (e, t, n, o) => {
  const i = n, l = e._zod.pattern;
  if (!l)
    throw new Error("Pattern not found in template literal");
  i.type = "string", i.pattern = l.source;
}, KP = (e, t, n, o) => {
  const i = n, l = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: c, maximum: f, mime: d } = e._zod.bag;
  c !== void 0 && (l.minLength = c), f !== void 0 && (l.maxLength = f), d ? d.length === 1 ? (l.contentMediaType = d[0], Object.assign(i, l)) : (Object.assign(i, l), i.anyOf = d.map((h) => ({ contentMediaType: h }))) : Object.assign(i, l);
}, JP = (e, t, n, o) => {
  n.type = "boolean";
}, E_ = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, QP = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, __ = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, e4 = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, t4 = (e, t, n, o) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, T_ = (e, t, n, o) => {
  const i = n, l = e._zod.def, { minimum: c, maximum: f } = e._zod.bag;
  typeof c == "number" && (i.minItems = c), typeof f == "number" && (i.maxItems = f), i.type = "array", i.items = rt(l.element, t, { ...o, path: [...o.path, "items"] });
}, C_ = (e, t, n, o) => {
  const i = n, l = e._zod.def;
  i.type = "object", i.properties = {};
  const c = l.shape;
  for (const h in c)
    i.properties[h] = rt(c[h], t, {
      ...o,
      path: [...o.path, "properties", h]
    });
  const f = new Set(Object.keys(c)), d = new Set([...f].filter((h) => {
    const m = l.shape[h]._zod;
    return t.io === "input" ? m.optin === void 0 : m.optout === void 0;
  }));
  d.size > 0 && (i.required = Array.from(d)), l.catchall?._zod.def.type === "never" ? i.additionalProperties = !1 : l.catchall ? l.catchall && (i.additionalProperties = rt(l.catchall, t, {
    ...o,
    path: [...o.path, "additionalProperties"]
  })) : t.io === "output" && (i.additionalProperties = !1);
}, A_ = (e, t, n, o) => {
  const i = e._zod.def, l = i.inclusive === !1, c = i.options.map((f, d) => rt(f, t, {
    ...o,
    path: [...o.path, l ? "oneOf" : "anyOf", d]
  }));
  l ? n.oneOf = c : n.anyOf = c;
}, R_ = (e, t, n, o) => {
  const i = e._zod.def, l = rt(i.left, t, {
    ...o,
    path: [...o.path, "allOf", 0]
  }), c = rt(i.right, t, {
    ...o,
    path: [...o.path, "allOf", 1]
  }), f = (h) => "allOf" in h && Object.keys(h).length === 1, d = [
    ...f(l) ? l.allOf : [l],
    ...f(c) ? c.allOf : [c]
  ];
  n.allOf = d;
}, n4 = (e, t, n, o) => {
  const i = n, l = e._zod.def;
  i.type = "array";
  const c = t.target === "draft-2020-12" ? "prefixItems" : "items", f = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", d = l.items.map((b, x) => rt(b, t, {
    ...o,
    path: [...o.path, c, x]
  })), h = l.rest ? rt(l.rest, t, {
    ...o,
    path: [...o.path, f, ...t.target === "openapi-3.0" ? [l.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (i.prefixItems = d, h && (i.items = h)) : t.target === "openapi-3.0" ? (i.items = {
    anyOf: d
  }, h && i.items.anyOf.push(h), i.minItems = d.length, h || (i.maxItems = d.length)) : (i.items = d, h && (i.additionalItems = h));
  const { minimum: m, maximum: v } = e._zod.bag;
  typeof m == "number" && (i.minItems = m), typeof v == "number" && (i.maxItems = v);
}, M_ = (e, t, n, o) => {
  const i = n, l = e._zod.def;
  i.type = "object";
  const c = l.keyType, d = c._zod.bag?.patterns;
  if (l.mode === "loose" && d && d.size > 0) {
    const m = rt(l.valueType, t, {
      ...o,
      path: [...o.path, "patternProperties", "*"]
    });
    i.patternProperties = {};
    for (const v of d)
      i.patternProperties[v.source] = m;
  } else
    (t.target === "draft-07" || t.target === "draft-2020-12") && (i.propertyNames = rt(l.keyType, t, {
      ...o,
      path: [...o.path, "propertyNames"]
    })), i.additionalProperties = rt(l.valueType, t, {
      ...o,
      path: [...o.path, "additionalProperties"]
    });
  const h = c._zod.values;
  if (h) {
    const m = [...h].filter((v) => typeof v == "string" || typeof v == "number");
    m.length > 0 && (i.required = m);
  }
}, z_ = (e, t, n, o) => {
  const i = e._zod.def, l = rt(i.innerType, t, o), c = t.seen.get(e);
  t.target === "openapi-3.0" ? (c.ref = i.innerType, n.nullable = !0) : n.anyOf = [l, { type: "null" }];
}, D_ = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType;
}, N_ = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType, n.default = JSON.parse(JSON.stringify(i.defaultValue));
}, O_ = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType, t.io === "input" && (n._prefault = JSON.parse(JSON.stringify(i.defaultValue)));
}, j_ = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType;
  let c;
  try {
    c = i.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  n.default = c;
}, k_ = (e, t, n, o) => {
  const i = e._zod.def, l = t.io === "input" ? i.in._zod.def.type === "transform" ? i.out : i.in : i.out;
  rt(l, t, o);
  const c = t.seen.get(e);
  c.ref = l;
}, P_ = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType, n.readOnly = !0;
}, r4 = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType;
}, Og = (e, t, n, o) => {
  const i = e._zod.def;
  rt(i.innerType, t, o);
  const l = t.seen.get(e);
  l.ref = i.innerType;
}, L_ = (e, t, n, o) => {
  const i = e._zod.innerType;
  rt(i, t, o);
  const l = t.seen.get(e);
  l.ref = i;
}, nw = {
  string: m_,
  number: g_,
  boolean: v_,
  bigint: HP,
  symbol: ZP,
  null: y_,
  undefined: FP,
  void: GP,
  never: b_,
  any: YP,
  unknown: x_,
  date: qP,
  enum: S_,
  literal: w_,
  nan: WP,
  template_literal: XP,
  file: KP,
  success: JP,
  custom: E_,
  function: QP,
  transform: __,
  map: e4,
  set: t4,
  array: T_,
  object: C_,
  union: A_,
  intersection: R_,
  tuple: n4,
  record: M_,
  nullable: z_,
  nonoptional: D_,
  default: N_,
  prefault: O_,
  catch: j_,
  pipe: k_,
  readonly: P_,
  promise: r4,
  optional: Og,
  lazy: L_
};
function o4(e, t) {
  if ("_idmap" in e) {
    const o = e, i = qu({ ...t, processors: nw }), l = {};
    for (const d of o._idmap.entries()) {
      const [h, m] = d;
      rt(m, i);
    }
    const c = {}, f = {
      registry: o,
      uri: t?.uri,
      defs: l
    };
    i.external = f;
    for (const d of o._idmap.entries()) {
      const [h, m] = d;
      Wu(i, m), c[h] = Xu(i, m);
    }
    if (Object.keys(l).length > 0) {
      const d = i.target === "draft-2020-12" ? "$defs" : "definitions";
      c.__shared = {
        [d]: l
      };
    }
    return { schemas: c };
  }
  const n = qu({ ...t, processors: nw });
  return rt(e, n), Wu(n, e), Xu(n, e);
}
const a4 = /* @__PURE__ */ ee("ZodISODateTime", (e, t) => {
  sk.init(e, t), pt.init(e, t);
});
function i4(e) {
  return /* @__PURE__ */ mP(a4, e);
}
const s4 = /* @__PURE__ */ ee("ZodISODate", (e, t) => {
  lk.init(e, t), pt.init(e, t);
});
function l4(e) {
  return /* @__PURE__ */ gP(s4, e);
}
const c4 = /* @__PURE__ */ ee("ZodISOTime", (e, t) => {
  ck.init(e, t), pt.init(e, t);
});
function u4(e) {
  return /* @__PURE__ */ vP(c4, e);
}
const f4 = /* @__PURE__ */ ee("ZodISODuration", (e, t) => {
  uk.init(e, t), pt.init(e, t);
});
function d4(e) {
  return /* @__PURE__ */ yP(f4, e);
}
const h4 = (e, t) => {
  JE.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => Q2(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => J2(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, Rm, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, Rm, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, $n = ee("ZodError", h4, {
  Parent: Error
}), p4 = /* @__PURE__ */ zg($n), m4 = /* @__PURE__ */ Dg($n), g4 = /* @__PURE__ */ zf($n), I_ = /* @__PURE__ */ Df($n), v4 = /* @__PURE__ */ nj($n), y4 = /* @__PURE__ */ rj($n), b4 = /* @__PURE__ */ oj($n), x4 = /* @__PURE__ */ aj($n), S4 = /* @__PURE__ */ ij($n), w4 = /* @__PURE__ */ sj($n), E4 = /* @__PURE__ */ lj($n), _4 = /* @__PURE__ */ cj($n), ut = /* @__PURE__ */ ee("ZodType", (e, t) => (ct.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: Ku(e, "input"),
    output: Ku(e, "output")
  }
}), e.toJSONSchema = BP(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(Uo(t, {
  checks: [
    ...t.checks ?? [],
    ...n.map((o) => typeof o == "function" ? { _zod: { check: o, def: { check: "custom" }, onattach: [] } } : o)
  ]
}), {
  parent: !0
}), e.with = e.check, e.clone = (n, o) => Bo(e, n, o), e.brand = () => e, e.register = ((n, o) => (n.add(e, o), e)), e.parse = (n, o) => p4(e, n, o, { callee: e.parse }), e.safeParse = (n, o) => g4(e, n, o), e.parseAsync = async (n, o) => m4(e, n, o, { callee: e.parseAsync }), e.safeParseAsync = async (n, o) => I_(e, n, o), e.spa = e.safeParseAsync, e.encode = (n, o) => v4(e, n, o), e.decode = (n, o) => y4(e, n, o), e.encodeAsync = async (n, o) => b4(e, n, o), e.decodeAsync = async (n, o) => x4(e, n, o), e.safeEncode = (n, o) => S4(e, n, o), e.safeDecode = (n, o) => w4(e, n, o), e.safeEncodeAsync = async (n, o) => E4(e, n, o), e.safeDecodeAsync = async (n, o) => _4(e, n, o), e.refine = (n, o) => e.check(xL(n, o)), e.superRefine = (n) => e.check(SL(n)), e.overwrite = (n) => e.check(/* @__PURE__ */ Zi(n)), e.optional = () => aw(e), e.exactOptional = () => iL(e), e.nullable = () => iw(e), e.nullish = () => aw(iw(e)), e.nonoptional = (n) => dL(e, n), e.array = () => Fi(e), e.or = (n) => Jt([e, n]), e.and = (n) => eL(e, n), e.transform = (n) => sw(e, oL(n)), e.default = (n) => cL(e, n), e.prefault = (n) => fL(e, n), e.catch = (n) => pL(e, n), e.pipe = (n) => sw(e, n), e.readonly = () => vL(e), e.describe = (n) => {
  const o = e.clone();
  return el.add(o, { description: n }), o;
}, Object.defineProperty(e, "description", {
  get() {
    return el.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return el.get(e);
  const o = e.clone();
  return el.add(o, n[0]), o;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e.apply = (n) => n(e), e)), V_ = /* @__PURE__ */ ee("_ZodString", (e, t) => {
  Ng.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (o, i, l) => m_(e, o, i);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...o) => e.check(/* @__PURE__ */ TP(...o)), e.includes = (...o) => e.check(/* @__PURE__ */ RP(...o)), e.startsWith = (...o) => e.check(/* @__PURE__ */ MP(...o)), e.endsWith = (...o) => e.check(/* @__PURE__ */ zP(...o)), e.min = (...o) => e.check(/* @__PURE__ */ Yu(...o)), e.max = (...o) => e.check(/* @__PURE__ */ h_(...o)), e.length = (...o) => e.check(/* @__PURE__ */ p_(...o)), e.nonempty = (...o) => e.check(/* @__PURE__ */ Yu(1, ...o)), e.lowercase = (o) => e.check(/* @__PURE__ */ CP(o)), e.uppercase = (o) => e.check(/* @__PURE__ */ AP(o)), e.trim = () => e.check(/* @__PURE__ */ NP()), e.normalize = (...o) => e.check(/* @__PURE__ */ DP(...o)), e.toLowerCase = () => e.check(/* @__PURE__ */ OP()), e.toUpperCase = () => e.check(/* @__PURE__ */ jP()), e.slugify = () => e.check(/* @__PURE__ */ kP());
}), T4 = /* @__PURE__ */ ee("ZodString", (e, t) => {
  Ng.init(e, t), V_.init(e, t), e.email = (n) => e.check(/* @__PURE__ */ qk(C4, n)), e.url = (n) => e.check(/* @__PURE__ */ Qk(A4, n)), e.jwt = (n) => e.check(/* @__PURE__ */ pP($4, n)), e.emoji = (n) => e.check(/* @__PURE__ */ eP(R4, n)), e.guid = (n) => e.check(/* @__PURE__ */ JS(rw, n)), e.uuid = (n) => e.check(/* @__PURE__ */ Wk(xu, n)), e.uuidv4 = (n) => e.check(/* @__PURE__ */ Xk(xu, n)), e.uuidv6 = (n) => e.check(/* @__PURE__ */ Kk(xu, n)), e.uuidv7 = (n) => e.check(/* @__PURE__ */ Jk(xu, n)), e.nanoid = (n) => e.check(/* @__PURE__ */ tP(M4, n)), e.guid = (n) => e.check(/* @__PURE__ */ JS(rw, n)), e.cuid = (n) => e.check(/* @__PURE__ */ nP(z4, n)), e.cuid2 = (n) => e.check(/* @__PURE__ */ rP(D4, n)), e.ulid = (n) => e.check(/* @__PURE__ */ oP(N4, n)), e.base64 = (n) => e.check(/* @__PURE__ */ fP(V4, n)), e.base64url = (n) => e.check(/* @__PURE__ */ dP(U4, n)), e.xid = (n) => e.check(/* @__PURE__ */ aP(O4, n)), e.ksuid = (n) => e.check(/* @__PURE__ */ iP(j4, n)), e.ipv4 = (n) => e.check(/* @__PURE__ */ sP(k4, n)), e.ipv6 = (n) => e.check(/* @__PURE__ */ lP(P4, n)), e.cidrv4 = (n) => e.check(/* @__PURE__ */ cP(L4, n)), e.cidrv6 = (n) => e.check(/* @__PURE__ */ uP(I4, n)), e.e164 = (n) => e.check(/* @__PURE__ */ hP(B4, n)), e.datetime = (n) => e.check(i4(n)), e.date = (n) => e.check(l4(n)), e.time = (n) => e.check(u4(n)), e.duration = (n) => e.check(d4(n));
});
function pe(e) {
  return /* @__PURE__ */ Yk(T4, e);
}
const pt = /* @__PURE__ */ ee("ZodStringFormat", (e, t) => {
  dt.init(e, t), V_.init(e, t);
}), C4 = /* @__PURE__ */ ee("ZodEmail", (e, t) => {
  Jj.init(e, t), pt.init(e, t);
}), rw = /* @__PURE__ */ ee("ZodGUID", (e, t) => {
  Xj.init(e, t), pt.init(e, t);
}), xu = /* @__PURE__ */ ee("ZodUUID", (e, t) => {
  Kj.init(e, t), pt.init(e, t);
}), A4 = /* @__PURE__ */ ee("ZodURL", (e, t) => {
  Qj.init(e, t), pt.init(e, t);
}), R4 = /* @__PURE__ */ ee("ZodEmoji", (e, t) => {
  ek.init(e, t), pt.init(e, t);
}), M4 = /* @__PURE__ */ ee("ZodNanoID", (e, t) => {
  tk.init(e, t), pt.init(e, t);
}), z4 = /* @__PURE__ */ ee("ZodCUID", (e, t) => {
  nk.init(e, t), pt.init(e, t);
}), D4 = /* @__PURE__ */ ee("ZodCUID2", (e, t) => {
  rk.init(e, t), pt.init(e, t);
}), N4 = /* @__PURE__ */ ee("ZodULID", (e, t) => {
  ok.init(e, t), pt.init(e, t);
}), O4 = /* @__PURE__ */ ee("ZodXID", (e, t) => {
  ak.init(e, t), pt.init(e, t);
}), j4 = /* @__PURE__ */ ee("ZodKSUID", (e, t) => {
  ik.init(e, t), pt.init(e, t);
}), k4 = /* @__PURE__ */ ee("ZodIPv4", (e, t) => {
  fk.init(e, t), pt.init(e, t);
}), P4 = /* @__PURE__ */ ee("ZodIPv6", (e, t) => {
  dk.init(e, t), pt.init(e, t);
}), L4 = /* @__PURE__ */ ee("ZodCIDRv4", (e, t) => {
  hk.init(e, t), pt.init(e, t);
}), I4 = /* @__PURE__ */ ee("ZodCIDRv6", (e, t) => {
  pk.init(e, t), pt.init(e, t);
}), V4 = /* @__PURE__ */ ee("ZodBase64", (e, t) => {
  mk.init(e, t), pt.init(e, t);
}), U4 = /* @__PURE__ */ ee("ZodBase64URL", (e, t) => {
  vk.init(e, t), pt.init(e, t);
}), B4 = /* @__PURE__ */ ee("ZodE164", (e, t) => {
  yk.init(e, t), pt.init(e, t);
}), $4 = /* @__PURE__ */ ee("ZodJWT", (e, t) => {
  xk.init(e, t), pt.init(e, t);
}), U_ = /* @__PURE__ */ ee("ZodNumber", (e, t) => {
  l_.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (o, i, l) => g_(e, o, i), e.gt = (o, i) => e.check(/* @__PURE__ */ ew(o, i)), e.gte = (o, i) => e.check(/* @__PURE__ */ jp(o, i)), e.min = (o, i) => e.check(/* @__PURE__ */ jp(o, i)), e.lt = (o, i) => e.check(/* @__PURE__ */ QS(o, i)), e.lte = (o, i) => e.check(/* @__PURE__ */ Op(o, i)), e.max = (o, i) => e.check(/* @__PURE__ */ Op(o, i)), e.int = (o) => e.check(ow(o)), e.safe = (o) => e.check(ow(o)), e.positive = (o) => e.check(/* @__PURE__ */ ew(0, o)), e.nonnegative = (o) => e.check(/* @__PURE__ */ jp(0, o)), e.negative = (o) => e.check(/* @__PURE__ */ QS(0, o)), e.nonpositive = (o) => e.check(/* @__PURE__ */ Op(0, o)), e.multipleOf = (o, i) => e.check(/* @__PURE__ */ tw(o, i)), e.step = (o, i) => e.check(/* @__PURE__ */ tw(o, i)), e.finite = () => e;
  const n = e._zod.bag;
  e.minValue = Math.max(n.minimum ?? Number.NEGATIVE_INFINITY, n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(n.maximum ?? Number.POSITIVE_INFINITY, n.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (n.format ?? "").includes("int") || Number.isSafeInteger(n.multipleOf ?? 0.5), e.isFinite = !0, e.format = n.format ?? null;
});
function H4(e) {
  return /* @__PURE__ */ bP(U_, e);
}
const Z4 = /* @__PURE__ */ ee("ZodNumberFormat", (e, t) => {
  Sk.init(e, t), U_.init(e, t);
});
function ow(e) {
  return /* @__PURE__ */ xP(Z4, e);
}
const F4 = /* @__PURE__ */ ee("ZodBoolean", (e, t) => {
  wk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => v_(e, n, o);
});
function Wt(e) {
  return /* @__PURE__ */ SP(F4, e);
}
const G4 = /* @__PURE__ */ ee("ZodNull", (e, t) => {
  Ek.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => y_(e, n, o);
});
function Y4(e) {
  return /* @__PURE__ */ wP(G4, e);
}
const q4 = /* @__PURE__ */ ee("ZodUnknown", (e, t) => {
  _k.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => x_();
});
function ur() {
  return /* @__PURE__ */ EP(q4);
}
const W4 = /* @__PURE__ */ ee("ZodNever", (e, t) => {
  Tk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => b_(e, n, o);
});
function B_(e) {
  return /* @__PURE__ */ _P(W4, e);
}
const X4 = /* @__PURE__ */ ee("ZodArray", (e, t) => {
  Ck.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => T_(e, n, o, i), e.element = t.element, e.min = (n, o) => e.check(/* @__PURE__ */ Yu(n, o)), e.nonempty = (n) => e.check(/* @__PURE__ */ Yu(1, n)), e.max = (n, o) => e.check(/* @__PURE__ */ h_(n, o)), e.length = (n, o) => e.check(/* @__PURE__ */ p_(n, o)), e.unwrap = () => e.element;
});
function Fi(e, t) {
  return /* @__PURE__ */ PP(X4, e, t);
}
const $_ = /* @__PURE__ */ ee("ZodObject", (e, t) => {
  Rk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => C_(e, n, o, i), $e(e, "shape", () => t.shape), e.keyof = () => Z_(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: ur() }), e.loose = () => e.clone({ ...e._zod.def, catchall: ur() }), e.strict = () => e.clone({ ...e._zod.def, catchall: B_() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => Y2(e, n), e.safeExtend = (n) => q2(e, n), e.merge = (n) => W2(e, n), e.pick = (n) => F2(e, n), e.omit = (n) => G2(e, n), e.partial = (...n) => X2(F_, e, n[0]), e.required = (...n) => K2(G_, e, n[0]);
});
function tt(e, t) {
  const n = {
    type: "object",
    shape: e ?? {},
    ...we(t)
  };
  return new $_(n);
}
function st(e, t) {
  return new $_({
    type: "object",
    shape: e,
    catchall: B_(),
    ...we(t)
  });
}
const H_ = /* @__PURE__ */ ee("ZodUnion", (e, t) => {
  f_.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => A_(e, n, o, i), e.options = t.options;
});
function Jt(e, t) {
  return new H_({
    type: "union",
    options: e,
    ...we(t)
  });
}
const K4 = /* @__PURE__ */ ee("ZodDiscriminatedUnion", (e, t) => {
  H_.init(e, t), Mk.init(e, t);
});
function J4(e, t, n) {
  return new K4({
    type: "union",
    options: t,
    discriminator: e,
    ...we(n)
  });
}
const Q4 = /* @__PURE__ */ ee("ZodIntersection", (e, t) => {
  zk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => R_(e, n, o, i);
});
function eL(e, t) {
  return new Q4({
    type: "intersection",
    left: e,
    right: t
  });
}
const tL = /* @__PURE__ */ ee("ZodRecord", (e, t) => {
  Dk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => M_(e, n, o, i), e.keyType = t.keyType, e.valueType = t.valueType;
});
function bl(e, t, n) {
  return new tL({
    type: "record",
    keyType: e,
    valueType: t,
    ...we(n)
  });
}
const zm = /* @__PURE__ */ ee("ZodEnum", (e, t) => {
  Nk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (o, i, l) => S_(e, o, i), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (o, i) => {
    const l = {};
    for (const c of o)
      if (n.has(c))
        l[c] = t.entries[c];
      else
        throw new Error(`Key ${c} not found in enum`);
    return new zm({
      ...t,
      checks: [],
      ...we(i),
      entries: l
    });
  }, e.exclude = (o, i) => {
    const l = { ...t.entries };
    for (const c of o)
      if (n.has(c))
        delete l[c];
      else
        throw new Error(`Key ${c} not found in enum`);
    return new zm({
      ...t,
      checks: [],
      ...we(i),
      entries: l
    });
  };
});
function Z_(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((o) => [o, o])) : e;
  return new zm({
    type: "enum",
    entries: n,
    ...we(t)
  });
}
const nL = /* @__PURE__ */ ee("ZodLiteral", (e, t) => {
  Ok.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => w_(e, n, o), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function Te(e, t) {
  return new nL({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...we(t)
  });
}
const rL = /* @__PURE__ */ ee("ZodTransform", (e, t) => {
  jk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => __(e, n), e._zod.parse = (n, o) => {
    if (o.direction === "backward")
      throw new GE(e.constructor.name);
    n.addIssue = (l) => {
      if (typeof l == "string")
        n.issues.push(yl(l, n.value, t));
      else {
        const c = l;
        c.fatal && (c.continue = !1), c.code ?? (c.code = "custom"), c.input ?? (c.input = n.value), c.inst ?? (c.inst = e), n.issues.push(yl(c));
      }
    };
    const i = t.transform(n.value, n);
    return i instanceof Promise ? i.then((l) => (n.value = l, n)) : (n.value = i, n);
  };
});
function oL(e) {
  return new rL({
    type: "transform",
    transform: e
  });
}
const F_ = /* @__PURE__ */ ee("ZodOptional", (e, t) => {
  d_.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => Og(e, n, o, i), e.unwrap = () => e._zod.def.innerType;
});
function aw(e) {
  return new F_({
    type: "optional",
    innerType: e
  });
}
const aL = /* @__PURE__ */ ee("ZodExactOptional", (e, t) => {
  kk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => Og(e, n, o, i), e.unwrap = () => e._zod.def.innerType;
});
function iL(e) {
  return new aL({
    type: "optional",
    innerType: e
  });
}
const sL = /* @__PURE__ */ ee("ZodNullable", (e, t) => {
  Pk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => z_(e, n, o, i), e.unwrap = () => e._zod.def.innerType;
});
function iw(e) {
  return new sL({
    type: "nullable",
    innerType: e
  });
}
const lL = /* @__PURE__ */ ee("ZodDefault", (e, t) => {
  Lk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => N_(e, n, o, i), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function cL(e, t) {
  return new lL({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : XE(t);
    }
  });
}
const uL = /* @__PURE__ */ ee("ZodPrefault", (e, t) => {
  Ik.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => O_(e, n, o, i), e.unwrap = () => e._zod.def.innerType;
});
function fL(e, t) {
  return new uL({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : XE(t);
    }
  });
}
const G_ = /* @__PURE__ */ ee("ZodNonOptional", (e, t) => {
  Vk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => D_(e, n, o, i), e.unwrap = () => e._zod.def.innerType;
});
function dL(e, t) {
  return new G_({
    type: "nonoptional",
    innerType: e,
    ...we(t)
  });
}
const hL = /* @__PURE__ */ ee("ZodCatch", (e, t) => {
  Uk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => j_(e, n, o, i), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function pL(e, t) {
  return new hL({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const mL = /* @__PURE__ */ ee("ZodPipe", (e, t) => {
  Bk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => k_(e, n, o, i), e.in = t.in, e.out = t.out;
});
function sw(e, t) {
  return new mL({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const gL = /* @__PURE__ */ ee("ZodReadonly", (e, t) => {
  $k.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => P_(e, n, o, i), e.unwrap = () => e._zod.def.innerType;
});
function vL(e) {
  return new gL({
    type: "readonly",
    innerType: e
  });
}
const yL = /* @__PURE__ */ ee("ZodLazy", (e, t) => {
  Hk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => L_(e, n, o, i), e.unwrap = () => e._zod.def.getter();
});
function bL(e) {
  return new yL({
    type: "lazy",
    getter: e
  });
}
const jg = /* @__PURE__ */ ee("ZodCustom", (e, t) => {
  Zk.init(e, t), ut.init(e, t), e._zod.processJSONSchema = (n, o, i) => E_(e, n);
});
function Y_(e, t) {
  return /* @__PURE__ */ LP(jg, e ?? (() => !0), t);
}
function xL(e, t = {}) {
  return /* @__PURE__ */ IP(jg, e, t);
}
function SL(e) {
  return /* @__PURE__ */ VP(e);
}
function Ju(e, t = {}) {
  const n = new jg({
    type: "custom",
    check: "custom",
    fn: (o) => o instanceof e,
    abort: !0,
    ...we(t)
  });
  return n._zod.bag.Class = e, n._zod.check = (o) => {
    o.value instanceof e || o.issues.push({
      code: "invalid_type",
      expected: e.name,
      input: o.value,
      inst: n,
      path: [...n._zod.def.path ?? []]
    });
  }, n;
}
var xl;
(function(e) {
  e.assertEqual = (i) => {
  };
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const l = {};
    for (const c of i)
      l[c] = c;
    return l;
  }, e.getValidEnumValues = (i) => {
    const l = e.objectKeys(i).filter((f) => typeof i[i[f]] != "number"), c = {};
    for (const f of l)
      c[f] = i[f];
    return e.objectValues(c);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(l) {
    return i[l];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const l = [];
    for (const c in i)
      Object.prototype.hasOwnProperty.call(i, c) && l.push(c);
    return l;
  }, e.find = (i, l) => {
    for (const c of i)
      if (l(c))
        return c;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && Number.isFinite(i) && Math.floor(i) === i;
  function o(i, l = " | ") {
    return i.map((c) => typeof c == "string" ? `'${c}'` : c).join(l);
  }
  e.joinValues = o, e.jsonStringifyReplacer = (i, l) => typeof l == "bigint" ? l.toString() : l;
})(xl || (xl = {}));
var lw;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(lw || (lw = {}));
xl.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
xl.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class Qu extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (o) => {
      this.issues = [...this.issues, o];
    }, this.addIssues = (o = []) => {
      this.issues = [...this.issues, ...o];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(l) {
      return l.message;
    }, o = { _errors: [] }, i = (l) => {
      for (const c of l.issues)
        if (c.code === "invalid_union")
          c.unionErrors.map(i);
        else if (c.code === "invalid_return_type")
          i(c.returnTypeError);
        else if (c.code === "invalid_arguments")
          i(c.argumentsError);
        else if (c.path.length === 0)
          o._errors.push(n(c));
        else {
          let f = o, d = 0;
          for (; d < c.path.length; ) {
            const h = c.path[d];
            d === c.path.length - 1 ? (f[h] = f[h] || { _errors: [] }, f[h]._errors.push(n(c))) : f[h] = f[h] || { _errors: [] }, f = f[h], d++;
          }
        }
    };
    return i(this), o;
  }
  static assert(t) {
    if (!(t instanceof Qu))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, xl.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = /* @__PURE__ */ Object.create(null), o = [];
    for (const i of this.issues)
      if (i.path.length > 0) {
        const l = i.path[0];
        n[l] = n[l] || [], n[l].push(t(i));
      } else
        o.push(t(i));
    return { formErrors: o, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Qu.create = (e) => new Qu(e);
var cw;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
})(cw || (cw = {}));
var Ae;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Ae || (Ae = {}));
class uw extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
}
function kp(e) {
}
function wL(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = kp, onError: n = kp, onRetry: o = kp, onComment: i } = e;
  let l = "", c = !0, f, d = "", h = "";
  function m(w) {
    const C = c ? w.replace(/^\xEF\xBB\xBF/, "") : w, [A, M] = EL(`${l}${C}`);
    for (const T of A)
      v(T);
    l = M, c = !1;
  }
  function v(w) {
    if (w === "") {
      x();
      return;
    }
    if (w.startsWith(":")) {
      i && i(w.slice(w.startsWith(": ") ? 2 : 1));
      return;
    }
    const C = w.indexOf(":");
    if (C !== -1) {
      const A = w.slice(0, C), M = w[C + 1] === " " ? 2 : 1, T = w.slice(C + M);
      b(A, T, w);
      return;
    }
    b(w, "", w);
  }
  function b(w, C, A) {
    switch (w) {
      case "event":
        h = C;
        break;
      case "data":
        d = `${d}${C}
`;
        break;
      case "id":
        f = C.includes("\0") ? void 0 : C;
        break;
      case "retry":
        /^\d+$/.test(C) ? o(parseInt(C, 10)) : n(
          new uw(`Invalid \`retry\` value: "${C}"`, {
            type: "invalid-retry",
            value: C,
            line: A
          })
        );
        break;
      default:
        n(
          new uw(
            `Unknown field "${w.length > 20 ? `${w.slice(0, 20)}` : w}"`,
            { type: "unknown-field", field: w, value: C, line: A }
          )
        );
        break;
    }
  }
  function x() {
    d.length > 0 && t({
      id: f,
      event: h || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: d.endsWith(`
`) ? d.slice(0, -1) : d
    }), f = void 0, d = "", h = "";
  }
  function E(w = {}) {
    l && w.consume && v(l), c = !0, f = void 0, d = "", h = "", l = "";
  }
  return { feed: m, reset: E };
}
function EL(e) {
  const t = [];
  let n = "", o = 0;
  for (; o < e.length; ) {
    const i = e.indexOf("\r", o), l = e.indexOf(`
`, o);
    let c = -1;
    if (i !== -1 && l !== -1 ? c = Math.min(i, l) : i !== -1 ? i === e.length - 1 ? c = -1 : c = i : l !== -1 && (c = l), c === -1) {
      n = e.slice(o);
      break;
    } else {
      const f = e.slice(o, c);
      t.push(f), o = c + 1, e[o - 1] === "\r" && e[o] === `
` && o++;
    }
  }
  return [t, n];
}
class _L extends TransformStream {
  constructor({ onError: t, onRetry: n, onComment: o } = {}) {
    let i;
    super({
      start(l) {
        i = wL({
          onEvent: (c) => {
            l.enqueue(c);
          },
          onError(c) {
            t === "terminate" ? l.error(c) : typeof t == "function" && t(c);
          },
          onRetry: n,
          onComment: o
        });
      },
      transform(l) {
        i.feed(l);
      }
    });
  }
}
var Pl = ({
  prefix: e,
  size: t = 16,
  alphabet: n = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator: o = "-"
} = {}) => {
  const i = () => {
    const l = n.length, c = new Array(t);
    for (let f = 0; f < t; f++)
      c[f] = n[Math.random() * l | 0];
    return c.join("");
  };
  if (e == null)
    return i;
  if (n.includes(o))
    throw new P2({
      argument: "separator",
      message: `The separator "${o}" must not be part of the alphabet "${n}".`
    });
  return () => `${e}${o}${i()}`;
}, TL = Pl();
function fw(e = globalThis) {
  var t, n, o;
  return e.window ? "runtime/browser" : (t = e.navigator) != null && t.userAgent ? `runtime/${e.navigator.userAgent.toLowerCase()}` : (o = (n = e.process) == null ? void 0 : n.versions) != null && o.node ? `runtime/node.js/${e.process.version.substring(0)}` : e.EdgeRuntime ? "runtime/vercel-edge" : "runtime/unknown";
}
function ha(e) {
  if (e == null)
    return {};
  const t = {};
  if (e instanceof Headers)
    e.forEach((n, o) => {
      t[o.toLowerCase()] = n;
    });
  else {
    Array.isArray(e) || (e = Object.entries(e));
    for (const [n, o] of e)
      o != null && (t[n.toLowerCase()] = o);
  }
  return t;
}
function dw(e, ...t) {
  const n = new Headers(ha(e)), o = n.get("user-agent") || "";
  return n.set(
    "user-agent",
    [o, ...t].filter(Boolean).join(" ")
  ), Object.fromEntries(n.entries());
}
function CL(e) {
  return e != null;
}
var AL = /"__proto__"\s*:/, RL = /"constructor"\s*:/;
function hw(e) {
  const t = JSON.parse(e);
  return t === null || typeof t != "object" || AL.test(e) === !1 && RL.test(e) === !1 ? t : ML(t);
}
function ML(e) {
  let t = [e];
  for (; t.length; ) {
    const n = t;
    t = [];
    for (const o of n) {
      if (Object.prototype.hasOwnProperty.call(o, "__proto__"))
        throw new SyntaxError("Object contains forbidden prototype property");
      if (Object.prototype.hasOwnProperty.call(o, "constructor") && Object.prototype.hasOwnProperty.call(o.constructor, "prototype"))
        throw new SyntaxError("Object contains forbidden prototype property");
      for (const i in o) {
        const l = o[i];
        l && typeof l == "object" && t.push(l);
      }
    }
  }
  return e;
}
function zL(e) {
  const { stackTraceLimit: t } = Error;
  try {
    Error.stackTraceLimit = 0;
  } catch {
    return hw(e);
  }
  try {
    return hw(e);
  } finally {
    Error.stackTraceLimit = t;
  }
}
function kg(e) {
  if (e.type === "object" || Array.isArray(e.type) && e.type.includes("object")) {
    e.additionalProperties = !1;
    const { properties: n } = e;
    if (n != null)
      for (const o of Object.keys(n))
        n[o] = ca(n[o]);
  }
  e.items != null && (e.items = Array.isArray(e.items) ? e.items.map(ca) : ca(e.items)), e.anyOf != null && (e.anyOf = e.anyOf.map(ca)), e.allOf != null && (e.allOf = e.allOf.map(ca)), e.oneOf != null && (e.oneOf = e.oneOf.map(ca));
  const { definitions: t } = e;
  if (t != null)
    for (const n of Object.keys(t))
      t[n] = ca(t[n]);
  return e;
}
function ca(e) {
  return typeof e == "boolean" ? e : kg(e);
}
var DL = /* @__PURE__ */ Symbol(
  "Let zodToJsonSchema decide on which parser to use"
), pw = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: !0,
  rejectedAdditionalProperties: !1,
  definitionPath: "definitions",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  patternStrategy: "escape",
  applyRegexFlags: !1,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
}, NL = (e) => typeof e == "string" ? {
  ...pw,
  name: e
} : {
  ...pw,
  ...e
};
function _n() {
  return {};
}
function OL(e, t) {
  var n, o, i;
  const l = {
    type: "array"
  };
  return (n = e.type) != null && n._def && ((i = (o = e.type) == null ? void 0 : o._def) == null ? void 0 : i.typeName) !== Ae.ZodAny && (l.items = We(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && (l.minItems = e.minLength.value), e.maxLength && (l.maxItems = e.maxLength.value), e.exactLength && (l.minItems = e.exactLength.value, l.maxItems = e.exactLength.value), l;
}
function jL(e) {
  const t = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function kL() {
  return { type: "boolean" };
}
function q_(e, t) {
  return We(e.type._def, t);
}
var PL = (e, t) => We(e.innerType._def, t);
function W_(e, t, n) {
  const o = n ?? t.dateStrategy;
  if (Array.isArray(o))
    return {
      anyOf: o.map((i, l) => W_(e, t, i))
    };
  switch (o) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return LL(e);
  }
}
var LL = (e) => {
  const t = {
    type: "integer",
    format: "unix-time"
  };
  for (const n of e.checks)
    switch (n.kind) {
      case "min":
        t.minimum = n.value;
        break;
      case "max":
        t.maximum = n.value;
        break;
    }
  return t;
};
function IL(e, t) {
  return {
    ...We(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function VL(e, t) {
  return t.effectStrategy === "input" ? We(e.schema._def, t) : _n();
}
function UL(e) {
  return {
    type: "string",
    enum: Array.from(e.values)
  };
}
var BL = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function $L(e, t) {
  const n = [
    We(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    We(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((i) => !!i), o = [];
  return n.forEach((i) => {
    if (BL(i))
      o.push(...i.allOf);
    else {
      let l = i;
      if ("additionalProperties" in i && i.additionalProperties === !1) {
        const { additionalProperties: c, ...f } = i;
        l = f;
      }
      o.push(l);
    }
  }), o.length ? { allOf: o } : void 0;
}
function HL(e) {
  const t = typeof e.value;
  return t !== "bigint" && t !== "number" && t !== "boolean" && t !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : {
    type: t === "bigint" ? "integer" : t,
    const: e.value
  };
}
var Pp = void 0, Yn = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => (Pp === void 0 && (Pp = RegExp(
    "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
    "u"
  )), Pp),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function X_(e, t) {
  const n = {
    type: "string"
  };
  if (e.checks)
    for (const o of e.checks)
      switch (o.kind) {
        case "min":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, o.value) : o.value;
          break;
        case "max":
          n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, o.value) : o.value;
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              qn(n, "email", o.message, t);
              break;
            case "format:idn-email":
              qn(n, "idn-email", o.message, t);
              break;
            case "pattern:zod":
              Yt(n, Yn.email, o.message, t);
              break;
          }
          break;
        case "url":
          qn(n, "uri", o.message, t);
          break;
        case "uuid":
          qn(n, "uuid", o.message, t);
          break;
        case "regex":
          Yt(n, o.regex, o.message, t);
          break;
        case "cuid":
          Yt(n, Yn.cuid, o.message, t);
          break;
        case "cuid2":
          Yt(n, Yn.cuid2, o.message, t);
          break;
        case "startsWith":
          Yt(
            n,
            RegExp(`^${Lp(o.value, t)}`),
            o.message,
            t
          );
          break;
        case "endsWith":
          Yt(
            n,
            RegExp(`${Lp(o.value, t)}$`),
            o.message,
            t
          );
          break;
        case "datetime":
          qn(n, "date-time", o.message, t);
          break;
        case "date":
          qn(n, "date", o.message, t);
          break;
        case "time":
          qn(n, "time", o.message, t);
          break;
        case "duration":
          qn(n, "duration", o.message, t);
          break;
        case "length":
          n.minLength = typeof n.minLength == "number" ? Math.max(n.minLength, o.value) : o.value, n.maxLength = typeof n.maxLength == "number" ? Math.min(n.maxLength, o.value) : o.value;
          break;
        case "includes": {
          Yt(
            n,
            RegExp(Lp(o.value, t)),
            o.message,
            t
          );
          break;
        }
        case "ip": {
          o.version !== "v6" && qn(n, "ipv4", o.message, t), o.version !== "v4" && qn(n, "ipv6", o.message, t);
          break;
        }
        case "base64url":
          Yt(n, Yn.base64url, o.message, t);
          break;
        case "jwt":
          Yt(n, Yn.jwt, o.message, t);
          break;
        case "cidr": {
          o.version !== "v6" && Yt(n, Yn.ipv4Cidr, o.message, t), o.version !== "v4" && Yt(n, Yn.ipv6Cidr, o.message, t);
          break;
        }
        case "emoji":
          Yt(n, Yn.emoji(), o.message, t);
          break;
        case "ulid": {
          Yt(n, Yn.ulid, o.message, t);
          break;
        }
        case "base64": {
          switch (t.base64Strategy) {
            case "format:binary": {
              qn(n, "binary", o.message, t);
              break;
            }
            case "contentEncoding:base64": {
              n.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              Yt(n, Yn.base64, o.message, t);
              break;
            }
          }
          break;
        }
        case "nanoid":
          Yt(n, Yn.nanoid, o.message, t);
      }
  return n;
}
function Lp(e, t) {
  return t.patternStrategy === "escape" ? FL(e) : e;
}
var ZL = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function FL(e) {
  let t = "";
  for (let n = 0; n < e.length; n++)
    ZL.has(e[n]) || (t += "\\"), t += e[n];
  return t;
}
function qn(e, t, n, o) {
  var i;
  e.format || (i = e.anyOf) != null && i.some((l) => l.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format
  }), delete e.format), e.anyOf.push({
    format: t,
    ...n && o.errorMessages && { errorMessage: { format: n } }
  })) : e.format = t;
}
function Yt(e, t, n, o) {
  var i;
  e.pattern || (i = e.allOf) != null && i.some((l) => l.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern
  }), delete e.pattern), e.allOf.push({
    pattern: mw(t, o),
    ...n && o.errorMessages && { errorMessage: { pattern: n } }
  })) : e.pattern = mw(t, o);
}
function mw(e, t) {
  var n;
  if (!t.applyRegexFlags || !e.flags)
    return e.source;
  const o = {
    i: e.flags.includes("i"),
    // Case-insensitive
    m: e.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: e.flags.includes("s")
    // `.` matches newlines
  }, i = o.i ? e.source.toLowerCase() : e.source;
  let l = "", c = !1, f = !1, d = !1;
  for (let h = 0; h < i.length; h++) {
    if (c) {
      l += i[h], c = !1;
      continue;
    }
    if (o.i) {
      if (f) {
        if (i[h].match(/[a-z]/)) {
          d ? (l += i[h], l += `${i[h - 2]}-${i[h]}`.toUpperCase(), d = !1) : i[h + 1] === "-" && ((n = i[h + 2]) != null && n.match(/[a-z]/)) ? (l += i[h], d = !0) : l += `${i[h]}${i[h].toUpperCase()}`;
          continue;
        }
      } else if (i[h].match(/[a-z]/)) {
        l += `[${i[h]}${i[h].toUpperCase()}]`;
        continue;
      }
    }
    if (o.m) {
      if (i[h] === "^") {
        l += `(^|(?<=[\r
]))`;
        continue;
      } else if (i[h] === "$") {
        l += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (o.s && i[h] === ".") {
      l += f ? `${i[h]}\r
` : `[${i[h]}\r
]`;
      continue;
    }
    l += i[h], i[h] === "\\" ? c = !0 : f && i[h] === "]" ? f = !1 : !f && i[h] === "[" && (f = !0);
  }
  try {
    new RegExp(l);
  } catch {
    return console.warn(
      `Could not convert regex pattern at ${t.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    ), e.source;
  }
  return l;
}
function K_(e, t) {
  var n, o, i, l, c, f;
  const d = {
    type: "object",
    additionalProperties: (n = We(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    })) != null ? n : t.allowedAdditionalProperties
  };
  if (((o = e.keyType) == null ? void 0 : o._def.typeName) === Ae.ZodString && ((i = e.keyType._def.checks) != null && i.length)) {
    const { type: h, ...m } = X_(e.keyType._def, t);
    return {
      ...d,
      propertyNames: m
    };
  } else {
    if (((l = e.keyType) == null ? void 0 : l._def.typeName) === Ae.ZodEnum)
      return {
        ...d,
        propertyNames: {
          enum: e.keyType._def.values
        }
      };
    if (((c = e.keyType) == null ? void 0 : c._def.typeName) === Ae.ZodBranded && e.keyType._def.type._def.typeName === Ae.ZodString && ((f = e.keyType._def.type._def.checks) != null && f.length)) {
      const { type: h, ...m } = q_(
        e.keyType._def,
        t
      );
      return {
        ...d,
        propertyNames: m
      };
    }
  }
  return d;
}
function GL(e, t) {
  if (t.mapStrategy === "record")
    return K_(e, t);
  const n = We(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || _n(), o = We(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || _n();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, o],
      minItems: 2,
      maxItems: 2
    }
  };
}
function YL(e) {
  const t = e.values, o = Object.keys(e.values).filter((l) => typeof t[t[l]] != "number").map((l) => t[l]), i = Array.from(
    new Set(o.map((l) => typeof l))
  );
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: o
  };
}
function qL() {
  return { not: _n() };
}
function WL() {
  return {
    type: "null"
  };
}
var Dm = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function XL(e, t) {
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every(
    (o) => o._def.typeName in Dm && (!o._def.checks || !o._def.checks.length)
  )) {
    const o = n.reduce((i, l) => {
      const c = Dm[l._def.typeName];
      return c && !i.includes(c) ? [...i, c] : i;
    }, []);
    return {
      type: o.length > 1 ? o : o[0]
    };
  } else if (n.every((o) => o._def.typeName === "ZodLiteral" && !o.description)) {
    const o = n.reduce(
      (i, l) => {
        const c = typeof l._def.value;
        switch (c) {
          case "string":
          case "number":
          case "boolean":
            return [...i, c];
          case "bigint":
            return [...i, "integer"];
          case "object":
            if (l._def.value === null) return [...i, "null"];
          default:
            return i;
        }
      },
      []
    );
    if (o.length === n.length) {
      const i = o.filter((l, c, f) => f.indexOf(l) === c);
      return {
        type: i.length > 1 ? i : i[0],
        enum: n.reduce(
          (l, c) => l.includes(c._def.value) ? l : [...l, c._def.value],
          []
        )
      };
    }
  } else if (n.every((o) => o._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (o, i) => [
          ...o,
          ...i._def.values.filter((l) => !o.includes(l))
        ],
        []
      )
    };
  return KL(e, t);
}
var KL = (e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (o, i) => We(o._def, {
      ...t,
      currentPath: [...t.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (o) => !!o && (!t.strictUnions || typeof o == "object" && Object.keys(o).length > 0)
  );
  return n.length ? { anyOf: n } : void 0;
};
function JL(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    e.innerType._def.typeName
  ) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return {
      type: [
        Dm[e.innerType._def.typeName],
        "null"
      ]
    };
  const n = We(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return n && { anyOf: [n, { type: "null" }] };
}
function QL(e) {
  const t = {
    type: "number"
  };
  if (!e.checks) return t;
  for (const n of e.checks)
    switch (n.kind) {
      case "int":
        t.type = "integer";
        break;
      case "min":
        n.inclusive ? t.minimum = n.value : t.exclusiveMinimum = n.value;
        break;
      case "max":
        n.inclusive ? t.maximum = n.value : t.exclusiveMaximum = n.value;
        break;
      case "multipleOf":
        t.multipleOf = n.value;
        break;
    }
  return t;
}
function eI(e, t) {
  const n = {
    type: "object",
    properties: {}
  }, o = [], i = e.shape();
  for (const c in i) {
    let f = i[c];
    if (f === void 0 || f._def === void 0)
      continue;
    const d = nI(f), h = We(f._def, {
      ...t,
      currentPath: [...t.currentPath, "properties", c],
      propertyPath: [...t.currentPath, "properties", c]
    });
    h !== void 0 && (n.properties[c] = h, d || o.push(c));
  }
  o.length && (n.required = o);
  const l = tI(e, t);
  return l !== void 0 && (n.additionalProperties = l), n;
}
function tI(e, t) {
  if (e.catchall._def.typeName !== "ZodNever")
    return We(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    });
  switch (e.unknownKeys) {
    case "passthrough":
      return t.allowedAdditionalProperties;
    case "strict":
      return t.rejectedAdditionalProperties;
    case "strip":
      return t.removeAdditionalStrategy === "strict" ? t.allowedAdditionalProperties : t.rejectedAdditionalProperties;
  }
}
function nI(e) {
  try {
    return e.isOptional();
  } catch {
    return !0;
  }
}
var rI = (e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return We(e.innerType._def, t);
  const o = We(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return o ? { anyOf: [{ not: _n() }, o] } : _n();
}, oI = (e, t) => {
  if (t.pipeStrategy === "input")
    return We(e.in._def, t);
  if (t.pipeStrategy === "output")
    return We(e.out._def, t);
  const n = We(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), o = We(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  });
  return {
    allOf: [n, o].filter((i) => i !== void 0)
  };
};
function aI(e, t) {
  return We(e.type._def, t);
}
function iI(e, t) {
  const o = {
    type: "array",
    uniqueItems: !0,
    items: We(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && (o.minItems = e.minSize.value), e.maxSize && (o.maxItems = e.maxSize.value), o;
}
function sI(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, o) => We(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${o}`]
      })
    ).reduce(
      (n, o) => o === void 0 ? n : [...n, o],
      []
    ),
    additionalItems: We(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, o) => We(n._def, {
        ...t,
        currentPath: [...t.currentPath, "items", `${o}`]
      })
    ).reduce(
      (n, o) => o === void 0 ? n : [...n, o],
      []
    )
  };
}
function lI() {
  return {
    not: _n()
  };
}
function cI() {
  return _n();
}
var uI = (e, t) => We(e.innerType._def, t), fI = (e, t, n) => {
  switch (t) {
    case Ae.ZodString:
      return X_(e, n);
    case Ae.ZodNumber:
      return QL(e);
    case Ae.ZodObject:
      return eI(e, n);
    case Ae.ZodBigInt:
      return jL(e);
    case Ae.ZodBoolean:
      return kL();
    case Ae.ZodDate:
      return W_(e, n);
    case Ae.ZodUndefined:
      return lI();
    case Ae.ZodNull:
      return WL();
    case Ae.ZodArray:
      return OL(e, n);
    case Ae.ZodUnion:
    case Ae.ZodDiscriminatedUnion:
      return XL(e, n);
    case Ae.ZodIntersection:
      return $L(e, n);
    case Ae.ZodTuple:
      return sI(e, n);
    case Ae.ZodRecord:
      return K_(e, n);
    case Ae.ZodLiteral:
      return HL(e);
    case Ae.ZodEnum:
      return UL(e);
    case Ae.ZodNativeEnum:
      return YL(e);
    case Ae.ZodNullable:
      return JL(e, n);
    case Ae.ZodOptional:
      return rI(e, n);
    case Ae.ZodMap:
      return GL(e, n);
    case Ae.ZodSet:
      return iI(e, n);
    case Ae.ZodLazy:
      return () => e.getter()._def;
    case Ae.ZodPromise:
      return aI(e, n);
    case Ae.ZodNaN:
    case Ae.ZodNever:
      return qL();
    case Ae.ZodEffects:
      return VL(e, n);
    case Ae.ZodAny:
      return _n();
    case Ae.ZodUnknown:
      return cI();
    case Ae.ZodDefault:
      return IL(e, n);
    case Ae.ZodBranded:
      return q_(e, n);
    case Ae.ZodReadonly:
      return uI(e, n);
    case Ae.ZodCatch:
      return PL(e, n);
    case Ae.ZodPipeline:
      return oI(e, n);
    case Ae.ZodFunction:
    case Ae.ZodVoid:
    case Ae.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((o) => {
      })();
  }
}, dI = (e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
};
function We(e, t, n = !1) {
  var o;
  const i = t.seen.get(e);
  if (t.override) {
    const d = (o = t.override) == null ? void 0 : o.call(
      t,
      e,
      t,
      i,
      n
    );
    if (d !== DL)
      return d;
  }
  if (i && !n) {
    const d = hI(i, t);
    if (d !== void 0)
      return d;
  }
  const l = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, l);
  const c = fI(e, e.typeName, t), f = typeof c == "function" ? We(c(), t) : c;
  if (f && pI(e, t, f), t.postProcess) {
    const d = t.postProcess(f, e, t);
    return l.jsonSchema = f, d;
  }
  return l.jsonSchema = f, f;
}
var hI = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: dI(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, o) => t.currentPath[o] === n) ? (console.warn(
        `Recursive reference detected at ${t.currentPath.join(
          "/"
        )}! Defaulting to any`
      ), _n()) : t.$refStrategy === "seen" ? _n() : void 0;
  }
}, pI = (e, t, n) => (e.description && (n.description = e.description), n), mI = (e) => {
  const t = NL(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([o, i]) => [
        i._def,
        {
          def: i._def,
          path: [...t.basePath, t.definitionPath, o],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
}, gI = (e, t) => {
  var n;
  const o = mI(t);
  let i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (h, [m, v]) => {
      var b;
      return {
        ...h,
        [m]: (b = We(
          v._def,
          {
            ...o,
            currentPath: [...o.basePath, o.definitionPath, m]
          },
          !0
        )) != null ? b : _n()
      };
    },
    {}
  ) : void 0;
  const l = typeof t == "string" ? t : t?.nameStrategy === "title" ? void 0 : t?.name, c = (n = We(
    e._def,
    l === void 0 ? o : {
      ...o,
      currentPath: [...o.basePath, o.definitionPath, l]
    },
    !1
  )) != null ? n : _n(), f = typeof t == "object" && t.name !== void 0 && t.nameStrategy === "title" ? t.name : void 0;
  f !== void 0 && (c.title = f);
  const d = l === void 0 ? i ? {
    ...c,
    [o.definitionPath]: i
  } : c : {
    $ref: [
      ...o.$refStrategy === "relative" ? [] : o.basePath,
      o.definitionPath,
      l
    ].join("/"),
    [o.definitionPath]: {
      ...i,
      [l]: c
    }
  };
  return d.$schema = "http://json-schema.org/draft-07/schema#", d;
}, Nm = /* @__PURE__ */ Symbol.for("vercel.ai.schema");
function vI(e) {
  let t;
  return () => (t == null && (t = e()), t);
}
function Of(e, {
  validate: t
} = {}) {
  return {
    [Nm]: !0,
    _type: void 0,
    // should never be used directly
    get jsonSchema() {
      return typeof e == "function" && (e = e()), e;
    },
    validate: t
  };
}
function yI(e) {
  return typeof e == "object" && e !== null && Nm in e && e[Nm] === !0 && "jsonSchema" in e && "validate" in e;
}
function Pg(e) {
  return e == null ? Of({ properties: {}, additionalProperties: !1 }) : yI(e) ? e : "~standard" in e ? e["~standard"].vendor === "zod" ? J_(e) : bI(e) : e();
}
function bI(e) {
  return Of(
    () => kg(
      e["~standard"].jsonSchema.input({
        target: "draft-07"
      })
    ),
    {
      validate: async (t) => {
        const n = await e["~standard"].validate(t);
        return "value" in n ? { success: !0, value: n.value } : {
          success: !1,
          error: new Li({
            value: t,
            cause: n.issues
          })
        };
      }
    }
  );
}
function xI(e, t) {
  var n;
  const o = (n = void 0) != null ? n : !1;
  return Of(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => gI(e, {
      $refStrategy: o ? "root" : "none"
    }),
    {
      validate: async (i) => {
        const l = await e.safeParseAsync(i);
        return l.success ? { success: !0, value: l.data } : { success: !1, error: l.error };
      }
    }
  );
}
function SI(e, t) {
  var n;
  const o = (n = void 0) != null ? n : !1;
  return Of(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => kg(
      o4(e, {
        target: "draft-7",
        io: "input",
        reused: o ? "ref" : "inline"
      })
    ),
    {
      validate: async (i) => {
        const l = await I_(e, i);
        return l.success ? { success: !0, value: l.data } : { success: !1, error: l.error };
      }
    }
  );
}
function wI(e) {
  return "_zod" in e;
}
function J_(e, t) {
  return wI(e) ? SI(e) : xI(e);
}
async function gw({
  value: e,
  schema: t,
  context: n
}) {
  const o = await Sl({ value: e, schema: t, context: n });
  if (!o.success)
    throw Li.wrap({ value: e, cause: o.error, context: n });
  return o.value;
}
async function Sl({
  value: e,
  schema: t,
  context: n
}) {
  const o = Pg(t);
  try {
    if (o.validate == null)
      return { success: !0, value: e, rawValue: e };
    const i = await o.validate(e);
    return i.success ? { success: !0, value: i.value, rawValue: e } : {
      success: !1,
      error: Li.wrap({ value: e, cause: i.error, context: n }),
      rawValue: e
    };
  } catch (i) {
    return {
      success: !1,
      error: Li.wrap({ value: e, cause: i, context: n }),
      rawValue: e
    };
  }
}
async function xa({
  text: e,
  schema: t
}) {
  try {
    const n = zL(e);
    return t == null ? { success: !0, value: n, rawValue: n } : await Sl({ value: n, schema: t });
  } catch (n) {
    return {
      success: !1,
      error: LS.isInstance(n) ? n : new LS({ text: e, cause: n }),
      rawValue: void 0
    };
  }
}
function EI({
  stream: e,
  schema: t
}) {
  return e.pipeThrough(new TextDecoderStream()).pipeThrough(new _L()).pipeThrough(
    new TransformStream({
      async transform({ data: n }, o) {
        n !== "[DONE]" && o.enqueue(await xa({ text: n, schema: t }));
      }
    })
  );
}
async function Ao(e) {
  return typeof e == "function" && (e = e()), Promise.resolve(e);
}
var _I = Object.defineProperty, TI = (e, t) => {
  for (var n in t)
    _I(e, n, { get: t[n], enumerable: !0 });
}, Q_ = "AI_NoObjectGeneratedError", eT = `vercel.ai.error.${Q_}`, CI = Symbol.for(eT), tT, No = class extends Bn {
  constructor({
    message: e = "No object generated.",
    cause: t,
    text: n,
    response: o,
    usage: i,
    finishReason: l
  }) {
    super({ name: Q_, message: e, cause: t }), this[tT] = !0, this.text = n, this.response = o, this.usage = i, this.finishReason = l;
  }
  static isInstance(e) {
    return Bn.hasMarker(e, eT);
  }
};
tT = CI;
var nT = "AI_UIMessageStreamError", rT = `vercel.ai.error.${nT}`, AI = Symbol.for(rT), oT, gi = class extends Bn {
  constructor({
    chunkType: e,
    chunkId: t,
    message: n
  }) {
    super({ name: nT, message: n }), this[oT] = !0, this.chunkType = e, this.chunkId = t;
  }
  static isInstance(e) {
    return Bn.hasMarker(e, rT);
  }
};
oT = AI;
var aT = "AI_MessageConversionError", iT = `vercel.ai.error.${aT}`, RI = Symbol.for(iT), sT, MI = class extends Bn {
  constructor({
    originalMessage: e,
    message: t
  }) {
    super({ name: aT, message: t }), this[sT] = !0, this.originalMessage = e;
  }
  static isInstance(e) {
    return Bn.hasMarker(e, iT);
  }
};
sT = RI;
var vw = "6.0.69", lT = Jt([
  pe(),
  Ju(Uint8Array),
  Ju(ArrayBuffer),
  Y_(
    // Buffer might not be available in some environments such as CloudFlare:
    (e) => {
      var t, n;
      return (n = (t = globalThis.Buffer) == null ? void 0 : t.isBuffer(e)) != null ? n : !1;
    },
    { message: "Must be a Buffer" }
  )
]);
async function yw({
  toolCallId: e,
  input: t,
  output: n,
  tool: o,
  errorMode: i
}) {
  return i === "text" ? { type: "error-text", value: Cg(n) } : i === "json" ? { type: "error-json", value: bw(n) } : o?.toModelOutput ? await o.toModelOutput({ toolCallId: e, input: t, output: n }) : typeof n == "string" ? { type: "text", value: n } : { type: "json", value: bw(n) };
}
function bw(e) {
  return e === void 0 ? null : e;
}
var wl = bL(
  () => Jt([
    Y4(),
    pe(),
    H4(),
    Wt(),
    bl(pe(), wl.optional()),
    Fi(wl)
  ])
), Be = bl(
  pe(),
  bl(pe(), wl.optional())
), cT = tt({
  type: Te("text"),
  text: pe(),
  providerOptions: Be.optional()
}), zI = tt({
  type: Te("image"),
  image: Jt([lT, Ju(URL)]),
  mediaType: pe().optional(),
  providerOptions: Be.optional()
}), uT = tt({
  type: Te("file"),
  data: Jt([lT, Ju(URL)]),
  filename: pe().optional(),
  mediaType: pe(),
  providerOptions: Be.optional()
}), DI = tt({
  type: Te("reasoning"),
  text: pe(),
  providerOptions: Be.optional()
}), NI = tt({
  type: Te("tool-call"),
  toolCallId: pe(),
  toolName: pe(),
  input: ur(),
  providerOptions: Be.optional(),
  providerExecuted: Wt().optional()
}), OI = J4(
  "type",
  [
    tt({
      type: Te("text"),
      value: pe(),
      providerOptions: Be.optional()
    }),
    tt({
      type: Te("json"),
      value: wl,
      providerOptions: Be.optional()
    }),
    tt({
      type: Te("execution-denied"),
      reason: pe().optional(),
      providerOptions: Be.optional()
    }),
    tt({
      type: Te("error-text"),
      value: pe(),
      providerOptions: Be.optional()
    }),
    tt({
      type: Te("error-json"),
      value: wl,
      providerOptions: Be.optional()
    }),
    tt({
      type: Te("content"),
      value: Fi(
        Jt([
          tt({
            type: Te("text"),
            text: pe(),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("media"),
            data: pe(),
            mediaType: pe()
          }),
          tt({
            type: Te("file-data"),
            data: pe(),
            mediaType: pe(),
            filename: pe().optional(),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("file-url"),
            url: pe(),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("file-id"),
            fileId: Jt([pe(), bl(pe(), pe())]),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("image-data"),
            data: pe(),
            mediaType: pe(),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("image-url"),
            url: pe(),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("image-file-id"),
            fileId: Jt([pe(), bl(pe(), pe())]),
            providerOptions: Be.optional()
          }),
          tt({
            type: Te("custom"),
            providerOptions: Be.optional()
          })
        ])
      )
    })
  ]
), fT = tt({
  type: Te("tool-result"),
  toolCallId: pe(),
  toolName: pe(),
  output: OI,
  providerOptions: Be.optional()
}), jI = tt({
  type: Te("tool-approval-request"),
  approvalId: pe(),
  toolCallId: pe()
}), kI = tt({
  type: Te("tool-approval-response"),
  approvalId: pe(),
  approved: Wt(),
  reason: pe().optional()
}), PI = tt(
  {
    role: Te("system"),
    content: pe(),
    providerOptions: Be.optional()
  }
), LI = tt({
  role: Te("user"),
  content: Jt([
    pe(),
    Fi(Jt([cT, zI, uT]))
  ]),
  providerOptions: Be.optional()
}), II = tt({
  role: Te("assistant"),
  content: Jt([
    pe(),
    Fi(
      Jt([
        cT,
        uT,
        DI,
        NI,
        fT,
        jI
      ])
    )
  ]),
  providerOptions: Be.optional()
}), VI = tt({
  role: Te("tool"),
  content: Fi(Jt([fT, kI])),
  providerOptions: Be.optional()
});
Jt([
  PI,
  LI,
  II,
  VI
]);
function dT(e, t) {
  if (e === void 0 && t === void 0)
    return;
  if (e === void 0)
    return t;
  if (t === void 0)
    return e;
  const n = { ...e };
  for (const o in t)
    if (Object.prototype.hasOwnProperty.call(t, o)) {
      const i = t[o];
      if (i === void 0)
        continue;
      const l = o in e ? e[o] : void 0, c = i !== null && typeof i == "object" && !Array.isArray(i) && !(i instanceof Date) && !(i instanceof RegExp), f = l != null && typeof l == "object" && !Array.isArray(l) && !(l instanceof Date) && !(l instanceof RegExp);
      c && f ? n[o] = dT(
        l,
        i
      ) : n[o] = i;
    }
  return n;
}
var UI = {};
TI(UI, {
  array: () => ZI,
  choice: () => FI,
  json: () => GI,
  object: () => HI,
  text: () => $I
});
function BI(e) {
  const t = ["ROOT"];
  let n = -1, o = null;
  function i(d, h, m) {
    switch (d) {
      case '"': {
        n = h, t.pop(), t.push(m), t.push("INSIDE_STRING");
        break;
      }
      case "f":
      case "t":
      case "n": {
        n = h, o = h, t.pop(), t.push(m), t.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        t.pop(), t.push(m), t.push("INSIDE_NUMBER");
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        n = h, t.pop(), t.push(m), t.push("INSIDE_NUMBER");
        break;
      }
      case "{": {
        n = h, t.pop(), t.push(m), t.push("INSIDE_OBJECT_START");
        break;
      }
      case "[": {
        n = h, t.pop(), t.push(m), t.push("INSIDE_ARRAY_START");
        break;
      }
    }
  }
  function l(d, h) {
    switch (d) {
      case ",": {
        t.pop(), t.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        n = h, t.pop();
        break;
      }
    }
  }
  function c(d, h) {
    switch (d) {
      case ",": {
        t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
        break;
      }
      case "]": {
        n = h, t.pop();
        break;
      }
    }
  }
  for (let d = 0; d < e.length; d++) {
    const h = e[d];
    switch (t[t.length - 1]) {
      case "ROOT":
        i(h, d, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (h) {
          case '"': {
            t.pop(), t.push("INSIDE_OBJECT_KEY");
            break;
          }
          case "}": {
            n = d, t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        h === '"' && (t.pop(), t.push("INSIDE_OBJECT_KEY"));
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        h === '"' && (t.pop(), t.push("INSIDE_OBJECT_AFTER_KEY"));
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        h === ":" && (t.pop(), t.push("INSIDE_OBJECT_BEFORE_VALUE"));
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        i(h, d, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        l(h, d);
        break;
      }
      case "INSIDE_STRING": {
        switch (h) {
          case '"': {
            t.pop(), n = d;
            break;
          }
          case "\\": {
            t.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default:
            n = d;
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        h === "]" ? (n = d, t.pop()) : (n = d, i(h, d, "INSIDE_ARRAY_AFTER_VALUE"));
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (h) {
          case ",": {
            t.pop(), t.push("INSIDE_ARRAY_AFTER_COMMA");
            break;
          }
          case "]": {
            n = d, t.pop();
            break;
          }
          default: {
            n = d;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        i(h, d, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        t.pop(), n = d;
        break;
      }
      case "INSIDE_NUMBER": {
        switch (h) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            n = d;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".":
            break;
          case ",": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && c(h, d), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && l(h, d);
            break;
          }
          case "}": {
            t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" && l(h, d);
            break;
          }
          case "]": {
            t.pop(), t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && c(h, d);
            break;
          }
          default: {
            t.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const v = e.substring(o, d + 1);
        !"false".startsWith(v) && !"true".startsWith(v) && !"null".startsWith(v) ? (t.pop(), t[t.length - 1] === "INSIDE_OBJECT_AFTER_VALUE" ? l(h, d) : t[t.length - 1] === "INSIDE_ARRAY_AFTER_VALUE" && c(h, d)) : n = d;
        break;
      }
    }
  }
  let f = e.slice(0, n + 1);
  for (let d = t.length - 1; d >= 0; d--)
    switch (t[d]) {
      case "INSIDE_STRING": {
        f += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        f += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        f += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const m = e.substring(o, e.length);
        "true".startsWith(m) ? f += "true".slice(m.length) : "false".startsWith(m) ? f += "false".slice(m.length) : "null".startsWith(m) && (f += "null".slice(m.length));
      }
    }
  return f;
}
async function Ll(e) {
  if (e === void 0)
    return { value: void 0, state: "undefined-input" };
  let t = await xa({ text: e });
  return t.success ? { value: t.value, state: "successful-parse" } : (t = await xa({ text: BI(e) }), t.success ? { value: t.value, state: "repaired-parse" } : { value: void 0, state: "failed-parse" });
}
var $I = () => ({
  name: "text",
  responseFormat: Promise.resolve({ type: "text" }),
  async parseCompleteOutput({ text: e }) {
    return e;
  },
  async parsePartialOutput({ text: e }) {
    return { partial: e };
  },
  createElementStreamTransform() {
  }
}), HI = ({
  schema: e,
  name: t,
  description: n
}) => {
  const o = Pg(e);
  return {
    name: "object",
    responseFormat: Ao(o.jsonSchema).then((i) => ({
      type: "json",
      schema: i,
      ...t != null && { name: t },
      ...n != null && { description: n }
    })),
    async parseCompleteOutput({ text: i }, l) {
      const c = await xa({ text: i });
      if (!c.success)
        throw new No({
          message: "No object generated: could not parse the response.",
          cause: c.error,
          text: i,
          response: l.response,
          usage: l.usage,
          finishReason: l.finishReason
        });
      const f = await Sl({
        value: c.value,
        schema: o
      });
      if (!f.success)
        throw new No({
          message: "No object generated: response did not match schema.",
          cause: f.error,
          text: i,
          response: l.response,
          usage: l.usage,
          finishReason: l.finishReason
        });
      return f.value;
    },
    async parsePartialOutput({ text: i }) {
      const l = await Ll(i);
      switch (l.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse":
          return {
            // Note: currently no validation of partial results:
            partial: l.value
          };
      }
    },
    createElementStreamTransform() {
    }
  };
}, ZI = ({
  element: e,
  name: t,
  description: n
}) => {
  const o = Pg(e);
  return {
    name: "array",
    // JSON schema that describes an array of elements:
    responseFormat: Ao(o.jsonSchema).then((i) => {
      const { $schema: l, ...c } = i;
      return {
        type: "json",
        schema: {
          $schema: "http://json-schema.org/draft-07/schema#",
          type: "object",
          properties: {
            elements: { type: "array", items: c }
          },
          required: ["elements"],
          additionalProperties: !1
        },
        ...t != null && { name: t },
        ...n != null && { description: n }
      };
    }),
    async parseCompleteOutput({ text: i }, l) {
      const c = await xa({ text: i });
      if (!c.success)
        throw new No({
          message: "No object generated: could not parse the response.",
          cause: c.error,
          text: i,
          response: l.response,
          usage: l.usage,
          finishReason: l.finishReason
        });
      const f = c.value;
      if (f == null || typeof f != "object" || !("elements" in f) || !Array.isArray(f.elements))
        throw new No({
          message: "No object generated: response did not match schema.",
          cause: new Li({
            value: f,
            cause: "response must be an object with an elements array"
          }),
          text: i,
          response: l.response,
          usage: l.usage,
          finishReason: l.finishReason
        });
      for (const d of f.elements) {
        const h = await Sl({
          value: d,
          schema: o
        });
        if (!h.success)
          throw new No({
            message: "No object generated: response did not match schema.",
            cause: h.error,
            text: i,
            response: l.response,
            usage: l.usage,
            finishReason: l.finishReason
          });
      }
      return f.elements;
    },
    async parsePartialOutput({ text: i }) {
      const l = await Ll(i);
      switch (l.state) {
        case "failed-parse":
        case "undefined-input":
          return;
        case "repaired-parse":
        case "successful-parse": {
          const c = l.value;
          if (c == null || typeof c != "object" || !("elements" in c) || !Array.isArray(c.elements))
            return;
          const f = l.state === "repaired-parse" && c.elements.length > 0 ? c.elements.slice(0, -1) : c.elements, d = [];
          for (const h of f) {
            const m = await Sl({
              value: h,
              schema: o
            });
            m.success && d.push(m.value);
          }
          return { partial: d };
        }
      }
    },
    createElementStreamTransform() {
      let i = 0;
      return new TransformStream({
        transform({ partialOutput: l }, c) {
          if (l != null)
            for (; i < l.length; i++)
              c.enqueue(l[i]);
        }
      });
    }
  };
}, FI = ({
  options: e,
  name: t,
  description: n
}) => ({
  name: "choice",
  // JSON schema that describes an enumeration:
  responseFormat: Promise.resolve({
    type: "json",
    schema: {
      $schema: "http://json-schema.org/draft-07/schema#",
      type: "object",
      properties: {
        result: { type: "string", enum: e }
      },
      required: ["result"],
      additionalProperties: !1
    },
    ...t != null && { name: t },
    ...n != null && { description: n }
  }),
  async parseCompleteOutput({ text: o }, i) {
    const l = await xa({ text: o });
    if (!l.success)
      throw new No({
        message: "No object generated: could not parse the response.",
        cause: l.error,
        text: o,
        response: i.response,
        usage: i.usage,
        finishReason: i.finishReason
      });
    const c = l.value;
    if (c == null || typeof c != "object" || !("result" in c) || typeof c.result != "string" || !e.includes(c.result))
      throw new No({
        message: "No object generated: response did not match schema.",
        cause: new Li({
          value: c,
          cause: "response must be an object that contains a choice value."
        }),
        text: o,
        response: i.response,
        usage: i.usage,
        finishReason: i.finishReason
      });
    return c.result;
  },
  async parsePartialOutput({ text: o }) {
    const i = await Ll(o);
    switch (i.state) {
      case "failed-parse":
      case "undefined-input":
        return;
      case "repaired-parse":
      case "successful-parse": {
        const l = i.value;
        if (l == null || typeof l != "object" || !("result" in l) || typeof l.result != "string")
          return;
        const c = e.filter(
          (f) => f.startsWith(l.result)
        );
        return i.state === "successful-parse" ? c.includes(l.result) ? { partial: l.result } : void 0 : c.length === 1 ? { partial: c[0] } : void 0;
      }
    }
  },
  createElementStreamTransform() {
  }
}), GI = ({
  name: e,
  description: t
} = {}) => ({
  name: "json",
  responseFormat: Promise.resolve({
    type: "json",
    ...e != null && { name: e },
    ...t != null && { description: t }
  }),
  async parseCompleteOutput({ text: n }, o) {
    const i = await xa({ text: n });
    if (!i.success)
      throw new No({
        message: "No object generated: could not parse the response.",
        cause: i.error,
        text: n,
        response: o.response,
        usage: o.usage,
        finishReason: o.finishReason
      });
    return i.value;
  },
  async parsePartialOutput({ text: n }) {
    const o = await Ll(n);
    switch (o.state) {
      case "failed-parse":
      case "undefined-input":
        return;
      case "repaired-parse":
      case "successful-parse":
        return o.value === void 0 ? void 0 : { partial: o.value };
    }
  },
  createElementStreamTransform() {
  }
});
Pl({
  prefix: "aitxt",
  size: 24
});
(class extends TransformStream {
  constructor() {
    super({
      transform(e, t) {
        t.enqueue(`data: ${JSON.stringify(e)}

`);
      },
      flush(e) {
        e.enqueue(`data: [DONE]

`);
      }
    });
  }
});
var YI = vI(
  () => J_(
    Jt([
      st({
        type: Te("text-start"),
        id: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("text-delta"),
        id: pe(),
        delta: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("text-end"),
        id: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("error"),
        errorText: pe()
      }),
      st({
        type: Te("tool-input-start"),
        toolCallId: pe(),
        toolName: pe(),
        providerExecuted: Wt().optional(),
        providerMetadata: Be.optional(),
        dynamic: Wt().optional(),
        title: pe().optional()
      }),
      st({
        type: Te("tool-input-delta"),
        toolCallId: pe(),
        inputTextDelta: pe()
      }),
      st({
        type: Te("tool-input-available"),
        toolCallId: pe(),
        toolName: pe(),
        input: ur(),
        providerExecuted: Wt().optional(),
        providerMetadata: Be.optional(),
        dynamic: Wt().optional(),
        title: pe().optional()
      }),
      st({
        type: Te("tool-input-error"),
        toolCallId: pe(),
        toolName: pe(),
        input: ur(),
        providerExecuted: Wt().optional(),
        providerMetadata: Be.optional(),
        dynamic: Wt().optional(),
        errorText: pe(),
        title: pe().optional()
      }),
      st({
        type: Te("tool-approval-request"),
        approvalId: pe(),
        toolCallId: pe()
      }),
      st({
        type: Te("tool-output-available"),
        toolCallId: pe(),
        output: ur(),
        providerExecuted: Wt().optional(),
        dynamic: Wt().optional(),
        preliminary: Wt().optional()
      }),
      st({
        type: Te("tool-output-error"),
        toolCallId: pe(),
        errorText: pe(),
        providerExecuted: Wt().optional(),
        dynamic: Wt().optional()
      }),
      st({
        type: Te("tool-output-denied"),
        toolCallId: pe()
      }),
      st({
        type: Te("reasoning-start"),
        id: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("reasoning-delta"),
        id: pe(),
        delta: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("reasoning-end"),
        id: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("source-url"),
        sourceId: pe(),
        url: pe(),
        title: pe().optional(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("source-document"),
        sourceId: pe(),
        mediaType: pe(),
        title: pe(),
        filename: pe().optional(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Te("file"),
        url: pe(),
        mediaType: pe(),
        providerMetadata: Be.optional()
      }),
      st({
        type: Y_(
          (e) => typeof e == "string" && e.startsWith("data-"),
          { message: 'Type must start with "data-"' }
        ),
        id: pe().optional(),
        data: ur(),
        transient: Wt().optional()
      }),
      st({
        type: Te("start-step")
      }),
      st({
        type: Te("finish-step")
      }),
      st({
        type: Te("start"),
        messageId: pe().optional(),
        messageMetadata: ur().optional()
      }),
      st({
        type: Te("finish"),
        finishReason: Z_([
          "stop",
          "length",
          "content-filter",
          "tool-calls",
          "error",
          "other"
        ]).optional(),
        messageMetadata: ur().optional()
      }),
      st({
        type: Te("abort"),
        reason: pe().optional()
      }),
      st({
        type: Te("message-metadata"),
        messageMetadata: ur()
      })
    ])
  )
);
function qI(e) {
  return e.type.startsWith("data-");
}
function Ip(e) {
  return e.type.startsWith("data-");
}
function Vp(e) {
  return e.type === "text";
}
function Up(e) {
  return e.type === "file";
}
function xw(e) {
  return e.type === "reasoning";
}
function Om(e) {
  return e.type.startsWith("tool-");
}
function hT(e) {
  return e.type === "dynamic-tool";
}
function zo(e) {
  return Om(e) || hT(e);
}
function jm(e) {
  return e.type.split("-").slice(1).join("-");
}
function Bp(e) {
  return hT(e) ? e.toolName : jm(e);
}
function WI({
  lastMessage: e,
  messageId: t
}) {
  return {
    message: e?.role === "assistant" ? e : {
      id: t,
      metadata: void 0,
      role: "assistant",
      parts: []
    },
    activeTextParts: {},
    activeReasoningParts: {},
    partialToolCalls: {}
  };
}
function XI({
  stream: e,
  messageMetadataSchema: t,
  dataPartSchemas: n,
  runUpdateMessageJob: o,
  onError: i,
  onToolCall: l,
  onData: c
}) {
  return e.pipeThrough(
    new TransformStream({
      async transform(f, d) {
        await o(async ({ state: h, write: m }) => {
          var v, b, x, E;
          function w(T) {
            const O = h.message.parts.filter(zo).find(
              (k) => k.toolCallId === T
            );
            if (O == null)
              throw new gi({
                chunkType: "tool-invocation",
                chunkId: T,
                message: `No tool invocation found for tool call ID "${T}".`
              });
            return O;
          }
          function C(T) {
            var D;
            const O = h.message.parts.find(
              (N) => Om(N) && N.toolCallId === T.toolCallId
            ), k = T, R = O;
            O != null ? (O.state = T.state, R.input = k.input, R.output = k.output, R.errorText = k.errorText, R.rawInput = k.rawInput, R.preliminary = k.preliminary, T.title !== void 0 && (R.title = T.title), R.providerExecuted = (D = k.providerExecuted) != null ? D : O.providerExecuted, k.providerMetadata != null && (O.callProviderMetadata = k.providerMetadata)) : h.message.parts.push({
              type: `tool-${T.toolName}`,
              toolCallId: T.toolCallId,
              state: T.state,
              title: T.title,
              input: k.input,
              output: k.output,
              rawInput: k.rawInput,
              errorText: k.errorText,
              providerExecuted: k.providerExecuted,
              preliminary: k.preliminary,
              ...k.providerMetadata != null ? { callProviderMetadata: k.providerMetadata } : {}
            });
          }
          function A(T) {
            var D, O;
            const k = h.message.parts.find(
              (P) => P.type === "dynamic-tool" && P.toolCallId === T.toolCallId
            ), R = T, N = k;
            k != null ? (k.state = T.state, N.toolName = T.toolName, N.input = R.input, N.output = R.output, N.errorText = R.errorText, N.rawInput = (D = R.rawInput) != null ? D : N.rawInput, N.preliminary = R.preliminary, T.title !== void 0 && (N.title = T.title), N.providerExecuted = (O = R.providerExecuted) != null ? O : k.providerExecuted, R.providerMetadata != null && (k.callProviderMetadata = R.providerMetadata)) : h.message.parts.push({
              type: "dynamic-tool",
              toolName: T.toolName,
              toolCallId: T.toolCallId,
              state: T.state,
              input: R.input,
              output: R.output,
              errorText: R.errorText,
              preliminary: R.preliminary,
              providerExecuted: R.providerExecuted,
              title: T.title,
              ...R.providerMetadata != null ? { callProviderMetadata: R.providerMetadata } : {}
            });
          }
          async function M(T) {
            if (T != null) {
              const D = h.message.metadata != null ? dT(h.message.metadata, T) : T;
              t != null && await gw({
                value: D,
                schema: t,
                context: {
                  field: "message.metadata",
                  entityId: h.message.id
                }
              }), h.message.metadata = D;
            }
          }
          switch (f.type) {
            case "text-start": {
              const T = {
                type: "text",
                text: "",
                providerMetadata: f.providerMetadata,
                state: "streaming"
              };
              h.activeTextParts[f.id] = T, h.message.parts.push(T), m();
              break;
            }
            case "text-delta": {
              const T = h.activeTextParts[f.id];
              if (T == null)
                throw new gi({
                  chunkType: "text-delta",
                  chunkId: f.id,
                  message: `Received text-delta for missing text part with ID "${f.id}". Ensure a "text-start" chunk is sent before any "text-delta" chunks.`
                });
              T.text += f.delta, T.providerMetadata = (v = f.providerMetadata) != null ? v : T.providerMetadata, m();
              break;
            }
            case "text-end": {
              const T = h.activeTextParts[f.id];
              if (T == null)
                throw new gi({
                  chunkType: "text-end",
                  chunkId: f.id,
                  message: `Received text-end for missing text part with ID "${f.id}". Ensure a "text-start" chunk is sent before any "text-end" chunks.`
                });
              T.state = "done", T.providerMetadata = (b = f.providerMetadata) != null ? b : T.providerMetadata, delete h.activeTextParts[f.id], m();
              break;
            }
            case "reasoning-start": {
              const T = {
                type: "reasoning",
                text: "",
                providerMetadata: f.providerMetadata,
                state: "streaming"
              };
              h.activeReasoningParts[f.id] = T, h.message.parts.push(T), m();
              break;
            }
            case "reasoning-delta": {
              const T = h.activeReasoningParts[f.id];
              if (T == null)
                throw new gi({
                  chunkType: "reasoning-delta",
                  chunkId: f.id,
                  message: `Received reasoning-delta for missing reasoning part with ID "${f.id}". Ensure a "reasoning-start" chunk is sent before any "reasoning-delta" chunks.`
                });
              T.text += f.delta, T.providerMetadata = (x = f.providerMetadata) != null ? x : T.providerMetadata, m();
              break;
            }
            case "reasoning-end": {
              const T = h.activeReasoningParts[f.id];
              if (T == null)
                throw new gi({
                  chunkType: "reasoning-end",
                  chunkId: f.id,
                  message: `Received reasoning-end for missing reasoning part with ID "${f.id}". Ensure a "reasoning-start" chunk is sent before any "reasoning-end" chunks.`
                });
              T.providerMetadata = (E = f.providerMetadata) != null ? E : T.providerMetadata, T.state = "done", delete h.activeReasoningParts[f.id], m();
              break;
            }
            case "file": {
              h.message.parts.push({
                type: "file",
                mediaType: f.mediaType,
                url: f.url
              }), m();
              break;
            }
            case "source-url": {
              h.message.parts.push({
                type: "source-url",
                sourceId: f.sourceId,
                url: f.url,
                title: f.title,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "source-document": {
              h.message.parts.push({
                type: "source-document",
                sourceId: f.sourceId,
                mediaType: f.mediaType,
                title: f.title,
                filename: f.filename,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "tool-input-start": {
              const T = h.message.parts.filter(Om);
              h.partialToolCalls[f.toolCallId] = {
                text: "",
                toolName: f.toolName,
                index: T.length,
                dynamic: f.dynamic,
                title: f.title
              }, f.dynamic ? A({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: f.providerExecuted,
                title: f.title,
                providerMetadata: f.providerMetadata
              }) : C({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-streaming",
                input: void 0,
                providerExecuted: f.providerExecuted,
                title: f.title,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "tool-input-delta": {
              const T = h.partialToolCalls[f.toolCallId];
              if (T == null)
                throw new gi({
                  chunkType: "tool-input-delta",
                  chunkId: f.toolCallId,
                  message: `Received tool-input-delta for missing tool call with ID "${f.toolCallId}". Ensure a "tool-input-start" chunk is sent before any "tool-input-delta" chunks.`
                });
              T.text += f.inputTextDelta;
              const { value: D } = await Ll(
                T.text
              );
              T.dynamic ? A({
                toolCallId: f.toolCallId,
                toolName: T.toolName,
                state: "input-streaming",
                input: D,
                title: T.title
              }) : C({
                toolCallId: f.toolCallId,
                toolName: T.toolName,
                state: "input-streaming",
                input: D,
                title: T.title
              }), m();
              break;
            }
            case "tool-input-available": {
              f.dynamic ? A({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-available",
                input: f.input,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata,
                title: f.title
              }) : C({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "input-available",
                input: f.input,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata,
                title: f.title
              }), m(), l && !f.providerExecuted && await l({
                toolCall: f
              });
              break;
            }
            case "tool-input-error": {
              f.dynamic ? A({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "output-error",
                input: f.input,
                errorText: f.errorText,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata
              }) : C({
                toolCallId: f.toolCallId,
                toolName: f.toolName,
                state: "output-error",
                input: void 0,
                rawInput: f.input,
                errorText: f.errorText,
                providerExecuted: f.providerExecuted,
                providerMetadata: f.providerMetadata
              }), m();
              break;
            }
            case "tool-approval-request": {
              const T = w(f.toolCallId);
              T.state = "approval-requested", T.approval = { id: f.approvalId }, m();
              break;
            }
            case "tool-output-denied": {
              const T = w(f.toolCallId);
              T.state = "output-denied", m();
              break;
            }
            case "tool-output-available": {
              const T = w(f.toolCallId);
              T.type === "dynamic-tool" ? A({
                toolCallId: f.toolCallId,
                toolName: T.toolName,
                state: "output-available",
                input: T.input,
                output: f.output,
                preliminary: f.preliminary,
                providerExecuted: f.providerExecuted,
                title: T.title
              }) : C({
                toolCallId: f.toolCallId,
                toolName: jm(T),
                state: "output-available",
                input: T.input,
                output: f.output,
                providerExecuted: f.providerExecuted,
                preliminary: f.preliminary,
                title: T.title
              }), m();
              break;
            }
            case "tool-output-error": {
              const T = w(f.toolCallId);
              T.type === "dynamic-tool" ? A({
                toolCallId: f.toolCallId,
                toolName: T.toolName,
                state: "output-error",
                input: T.input,
                errorText: f.errorText,
                providerExecuted: f.providerExecuted,
                title: T.title
              }) : C({
                toolCallId: f.toolCallId,
                toolName: jm(T),
                state: "output-error",
                input: T.input,
                rawInput: T.rawInput,
                errorText: f.errorText,
                providerExecuted: f.providerExecuted,
                title: T.title
              }), m();
              break;
            }
            case "start-step": {
              h.message.parts.push({ type: "step-start" });
              break;
            }
            case "finish-step": {
              h.activeTextParts = {}, h.activeReasoningParts = {};
              break;
            }
            case "start": {
              f.messageId != null && (h.message.id = f.messageId), await M(f.messageMetadata), (f.messageId != null || f.messageMetadata != null) && m();
              break;
            }
            case "finish": {
              f.finishReason != null && (h.finishReason = f.finishReason), await M(f.messageMetadata), f.messageMetadata != null && m();
              break;
            }
            case "message-metadata": {
              await M(f.messageMetadata), f.messageMetadata != null && m();
              break;
            }
            case "error": {
              i?.(new Error(f.errorText));
              break;
            }
            default:
              if (qI(f)) {
                if (n?.[f.type] != null) {
                  const O = h.message.parts.findIndex(
                    (R) => "id" in R && "data" in R && R.id === f.id && R.type === f.type
                  ), k = O >= 0 ? O : h.message.parts.length;
                  await gw({
                    value: f.data,
                    schema: n[f.type],
                    context: {
                      field: `message.parts[${k}].data`,
                      entityName: f.type,
                      entityId: f.id
                    }
                  });
                }
                const T = f;
                if (T.transient) {
                  c?.(T);
                  break;
                }
                const D = T.id != null ? h.message.parts.find(
                  (O) => T.type === O.type && T.id === O.id
                ) : void 0;
                D != null ? D.data = T.data : h.message.parts.push(T), c?.(T), m();
              }
          }
          d.enqueue(f);
        });
      }
    })
  );
}
async function KI({
  stream: e,
  onError: t
}) {
  const n = e.getReader();
  try {
    for (; ; ) {
      const { done: o } = await n.read();
      if (o)
        break;
    }
  } catch (o) {
    t?.(o);
  } finally {
    n.releaseLock();
  }
}
Pl({
  prefix: "aitxt",
  size: 24
});
async function JI(e, t) {
  const n = [];
  t?.ignoreIncompleteToolCalls && (e = e.map((o) => ({
    ...o,
    parts: o.parts.filter(
      (i) => !zo(i) || i.state !== "input-streaming" && i.state !== "input-available"
    )
  })));
  for (const o of e)
    switch (o.role) {
      case "system": {
        const i = o.parts.filter(
          (c) => c.type === "text"
        ), l = i.reduce((c, f) => f.providerMetadata != null ? { ...c, ...f.providerMetadata } : c, {});
        n.push({
          role: "system",
          content: i.map((c) => c.text).join(""),
          ...Object.keys(l).length > 0 ? { providerOptions: l } : {}
        });
        break;
      }
      case "user": {
        n.push({
          role: "user",
          content: o.parts.map((i) => {
            var l;
            if (Vp(i))
              return {
                type: "text",
                text: i.text,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (Up(i))
              return {
                type: "file",
                mediaType: i.mediaType,
                filename: i.filename,
                data: i.url,
                ...i.providerMetadata != null ? { providerOptions: i.providerMetadata } : {}
              };
            if (Ip(i))
              return (l = t?.convertDataPart) == null ? void 0 : l.call(
                t,
                i
              );
          }).filter(CL)
        });
        break;
      }
      case "assistant": {
        if (o.parts != null) {
          let i = [];
          async function l() {
            var c, f, d, h, m, v;
            if (i.length === 0)
              return;
            const b = [];
            for (const E of i)
              if (Vp(E))
                b.push({
                  type: "text",
                  text: E.text,
                  ...E.providerMetadata != null ? { providerOptions: E.providerMetadata } : {}
                });
              else if (Up(E))
                b.push({
                  type: "file",
                  mediaType: E.mediaType,
                  filename: E.filename,
                  data: E.url
                });
              else if (xw(E))
                b.push({
                  type: "reasoning",
                  text: E.text,
                  providerOptions: E.providerMetadata
                });
              else if (zo(E)) {
                const w = Bp(E);
                E.state !== "input-streaming" && (b.push({
                  type: "tool-call",
                  toolCallId: E.toolCallId,
                  toolName: w,
                  input: E.state === "output-error" ? (c = E.input) != null ? c : "rawInput" in E ? E.rawInput : void 0 : E.input,
                  providerExecuted: E.providerExecuted,
                  ...E.callProviderMetadata != null ? { providerOptions: E.callProviderMetadata } : {}
                }), E.approval != null && b.push({
                  type: "tool-approval-request",
                  approvalId: E.approval.id,
                  toolCallId: E.toolCallId
                }), E.providerExecuted === !0 && E.state !== "approval-responded" && (E.state === "output-available" || E.state === "output-error") && b.push({
                  type: "tool-result",
                  toolCallId: E.toolCallId,
                  toolName: w,
                  output: await yw({
                    toolCallId: E.toolCallId,
                    input: E.input,
                    output: E.state === "output-error" ? E.errorText : E.output,
                    tool: (f = t?.tools) == null ? void 0 : f[w],
                    errorMode: E.state === "output-error" ? "json" : "none"
                  }),
                  ...E.callProviderMetadata != null ? { providerOptions: E.callProviderMetadata } : {}
                }));
              } else if (Ip(E)) {
                const w = (d = t?.convertDataPart) == null ? void 0 : d.call(
                  t,
                  E
                );
                w != null && b.push(w);
              } else {
                const w = E;
                throw new Error(`Unsupported part: ${w}`);
              }
            n.push({
              role: "assistant",
              content: b
            });
            const x = i.filter(
              (E) => {
                var w;
                return zo(E) && (E.providerExecuted !== !0 || ((w = E.approval) == null ? void 0 : w.approved) != null);
              }
            );
            if (x.length > 0) {
              const E = [];
              for (const w of x)
                if (((h = w.approval) == null ? void 0 : h.approved) != null && E.push({
                  type: "tool-approval-response",
                  approvalId: w.approval.id,
                  approved: w.approval.approved,
                  reason: w.approval.reason,
                  providerExecuted: w.providerExecuted
                }), w.providerExecuted !== !0)
                  switch (w.state) {
                    case "output-denied": {
                      E.push({
                        type: "tool-result",
                        toolCallId: w.toolCallId,
                        toolName: Bp(w),
                        output: {
                          type: "error-text",
                          value: (m = w.approval.reason) != null ? m : "Tool execution denied."
                        },
                        ...w.callProviderMetadata != null ? { providerOptions: w.callProviderMetadata } : {}
                      });
                      break;
                    }
                    case "output-error":
                    case "output-available": {
                      const C = Bp(w);
                      E.push({
                        type: "tool-result",
                        toolCallId: w.toolCallId,
                        toolName: C,
                        output: await yw({
                          toolCallId: w.toolCallId,
                          input: w.input,
                          output: w.state === "output-error" ? w.errorText : w.output,
                          tool: (v = t?.tools) == null ? void 0 : v[C],
                          errorMode: w.state === "output-error" ? "text" : "none"
                        }),
                        ...w.callProviderMetadata != null ? { providerOptions: w.callProviderMetadata } : {}
                      });
                      break;
                    }
                  }
              E.length > 0 && n.push({
                role: "tool",
                content: E
              });
            }
            i = [];
          }
          for (const c of o.parts)
            Vp(c) || xw(c) || Up(c) || zo(c) || Ip(c) ? i.push(c) : c.type === "step-start" && await l();
          await l();
          break;
        }
        break;
      }
      default: {
        const i = o.role;
        throw new MI({
          originalMessage: o,
          message: `Unsupported role: ${i}`
        });
      }
    }
  return n;
}
Pl({ prefix: "aiobj", size: 24 });
var QI = class {
  constructor() {
    this.queue = [], this.isProcessing = !1;
  }
  async processQueue() {
    if (!this.isProcessing) {
      for (this.isProcessing = !0; this.queue.length > 0; )
        await this.queue[0](), this.queue.shift();
      this.isProcessing = !1;
    }
  }
  async run(e) {
    return new Promise((t, n) => {
      this.queue.push(async () => {
        try {
          await e(), t();
        } catch (o) {
          n(o);
        }
      }), this.processQueue();
    });
  }
};
Pl({ prefix: "aiobj", size: 24 });
async function e3(e) {
  if (e == null)
    return [];
  if (!globalThis.FileList || !(e instanceof globalThis.FileList))
    throw new Error("FileList is not supported in the current environment");
  return Promise.all(
    Array.from(e).map(async (t) => {
      const { name: n, type: o } = t, i = await new Promise((l, c) => {
        const f = new FileReader();
        f.onload = (d) => {
          var h;
          l((h = d.target) == null ? void 0 : h.result);
        }, f.onerror = (d) => c(d), f.readAsDataURL(t);
      });
      return {
        type: "file",
        mediaType: o,
        filename: n,
        url: i
      };
    })
  );
}
var t3 = class {
  constructor({
    api: e = "/api/chat",
    credentials: t,
    headers: n,
    body: o,
    fetch: i,
    prepareSendMessagesRequest: l,
    prepareReconnectToStreamRequest: c
  }) {
    this.api = e, this.credentials = t, this.headers = n, this.body = o, this.fetch = i, this.prepareSendMessagesRequest = l, this.prepareReconnectToStreamRequest = c;
  }
  async sendMessages({
    abortSignal: e,
    ...t
  }) {
    var n, o, i, l, c;
    const f = await Ao(this.body), d = await Ao(this.headers), h = await Ao(this.credentials), m = {
      ...ha(d),
      ...ha(t.headers)
    }, v = await ((n = this.prepareSendMessagesRequest) == null ? void 0 : n.call(this, {
      api: this.api,
      id: t.chatId,
      messages: t.messages,
      body: { ...f, ...t.body },
      headers: m,
      credentials: h,
      requestMetadata: t.metadata,
      trigger: t.trigger,
      messageId: t.messageId
    })), b = (o = v?.api) != null ? o : this.api, x = v?.headers !== void 0 ? ha(v.headers) : m, E = v?.body !== void 0 ? v.body : {
      ...f,
      ...t.body,
      id: t.chatId,
      messages: t.messages,
      trigger: t.trigger,
      messageId: t.messageId
    }, w = (i = v?.credentials) != null ? i : h, A = await ((l = this.fetch) != null ? l : globalThis.fetch)(b, {
      method: "POST",
      headers: dw(
        {
          "Content-Type": "application/json",
          ...x
        },
        `ai-sdk/${vw}`,
        fw()
      ),
      body: JSON.stringify(E),
      credentials: w,
      signal: e
    });
    if (!A.ok)
      throw new Error(
        (c = await A.text()) != null ? c : "Failed to fetch the chat response."
      );
    if (!A.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(A.body);
  }
  async reconnectToStream(e) {
    var t, n, o, i, l;
    const c = await Ao(this.body), f = await Ao(this.headers), d = await Ao(this.credentials), h = {
      ...ha(f),
      ...ha(e.headers)
    }, m = await ((t = this.prepareReconnectToStreamRequest) == null ? void 0 : t.call(this, {
      api: this.api,
      id: e.chatId,
      body: { ...c, ...e.body },
      headers: h,
      credentials: d,
      requestMetadata: e.metadata
    })), v = (n = m?.api) != null ? n : `${this.api}/${e.chatId}/stream`, b = m?.headers !== void 0 ? ha(m.headers) : h, x = (o = m?.credentials) != null ? o : d, w = await ((i = this.fetch) != null ? i : globalThis.fetch)(v, {
      method: "GET",
      headers: dw(
        b,
        `ai-sdk/${vw}`,
        fw()
      ),
      credentials: x
    });
    if (w.status === 204)
      return null;
    if (!w.ok)
      throw new Error(
        (l = await w.text()) != null ? l : "Failed to fetch the chat response."
      );
    if (!w.body)
      throw new Error("The response body is empty.");
    return this.processResponseStream(w.body);
  }
}, pT = class extends t3 {
  constructor(e = {}) {
    super(e);
  }
  processResponseStream(e) {
    return EI({
      stream: e,
      schema: YI
    }).pipeThrough(
      new TransformStream({
        async transform(t, n) {
          if (!t.success)
            throw t.error;
          n.enqueue(t.value);
        }
      })
    );
  }
}, n3 = class {
  constructor({
    generateId: e = TL,
    id: t = e(),
    transport: n = new pT(),
    messageMetadataSchema: o,
    dataPartSchemas: i,
    state: l,
    onError: c,
    onToolCall: f,
    onFinish: d,
    onData: h,
    sendAutomaticallyWhen: m
  }) {
    this.activeResponse = void 0, this.jobExecutor = new QI(), this.sendMessage = async (v, b) => {
      var x, E, w, C;
      if (v == null) {
        await this.makeRequest({
          trigger: "submit-message",
          messageId: (x = this.lastMessage) == null ? void 0 : x.id,
          ...b
        });
        return;
      }
      let A;
      if ("text" in v || "files" in v ? A = {
        parts: [
          ...Array.isArray(v.files) ? v.files : await e3(v.files),
          ..."text" in v && v.text != null ? [{ type: "text", text: v.text }] : []
        ]
      } : A = v, v.messageId != null) {
        const M = this.state.messages.findIndex(
          (T) => T.id === v.messageId
        );
        if (M === -1)
          throw new Error(`message with id ${v.messageId} not found`);
        if (this.state.messages[M].role !== "user")
          throw new Error(
            `message with id ${v.messageId} is not a user message`
          );
        this.state.messages = this.state.messages.slice(0, M + 1), this.state.replaceMessage(M, {
          ...A,
          id: v.messageId,
          role: (E = A.role) != null ? E : "user",
          metadata: v.metadata
        });
      } else
        this.state.pushMessage({
          ...A,
          id: (w = A.id) != null ? w : this.generateId(),
          role: (C = A.role) != null ? C : "user",
          metadata: v.metadata
        });
      await this.makeRequest({
        trigger: "submit-message",
        messageId: v.messageId,
        ...b
      });
    }, this.regenerate = async ({
      messageId: v,
      ...b
    } = {}) => {
      const x = v == null ? this.state.messages.length - 1 : this.state.messages.findIndex((E) => E.id === v);
      if (x === -1)
        throw new Error(`message ${v} not found`);
      this.state.messages = this.state.messages.slice(
        0,
        // if the message is a user message, we need to include it in the request:
        this.messages[x].role === "assistant" ? x : x + 1
      ), await this.makeRequest({
        trigger: "regenerate-message",
        messageId: v,
        ...b
      });
    }, this.resumeStream = async (v = {}) => {
      await this.makeRequest({ trigger: "resume-stream", ...v });
    }, this.clearError = () => {
      this.status === "error" && (this.state.error = void 0, this.setStatus({ status: "ready" }));
    }, this.addToolApprovalResponse = async ({
      id: v,
      approved: b,
      reason: x
    }) => this.jobExecutor.run(async () => {
      const E = this.state.messages, w = E[E.length - 1], C = (A) => zo(A) && A.state === "approval-requested" && A.approval.id === v ? {
        ...A,
        state: "approval-responded",
        approval: { id: v, approved: b, reason: x }
      } : A;
      this.state.replaceMessage(E.length - 1, {
        ...w,
        parts: w.parts.map(C)
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(C)), this.status !== "streaming" && this.status !== "submitted" && this.sendAutomaticallyWhen && this.shouldSendAutomatically().then((A) => {
        var M;
        A && this.makeRequest({
          trigger: "submit-message",
          messageId: (M = this.lastMessage) == null ? void 0 : M.id
        });
      });
    }), this.addToolOutput = async ({
      state: v = "output-available",
      tool: b,
      toolCallId: x,
      output: E,
      errorText: w
    }) => this.jobExecutor.run(async () => {
      const C = this.state.messages, A = C[C.length - 1], M = (T) => zo(T) && T.toolCallId === x ? { ...T, state: v, output: E, errorText: w } : T;
      this.state.replaceMessage(C.length - 1, {
        ...A,
        parts: A.parts.map(M)
      }), this.activeResponse && (this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(M)), this.status !== "streaming" && this.status !== "submitted" && this.sendAutomaticallyWhen && this.shouldSendAutomatically().then((T) => {
        var D;
        T && this.makeRequest({
          trigger: "submit-message",
          messageId: (D = this.lastMessage) == null ? void 0 : D.id
        });
      });
    }), this.addToolResult = this.addToolOutput, this.stop = async () => {
      var v;
      this.status !== "streaming" && this.status !== "submitted" || (v = this.activeResponse) != null && v.abortController && this.activeResponse.abortController.abort();
    }, this.id = t, this.transport = n, this.generateId = e, this.messageMetadataSchema = o, this.dataPartSchemas = i, this.state = l, this.onError = c, this.onToolCall = f, this.onFinish = d, this.onData = h, this.sendAutomaticallyWhen = m;
  }
  /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */
  get status() {
    return this.state.status;
  }
  setStatus({
    status: e,
    error: t
  }) {
    this.status !== e && (this.state.status = e, this.state.error = t);
  }
  get error() {
    return this.state.error;
  }
  get messages() {
    return this.state.messages;
  }
  get lastMessage() {
    return this.state.messages[this.state.messages.length - 1];
  }
  set messages(e) {
    this.state.messages = e;
  }
  async shouldSendAutomatically() {
    if (!this.sendAutomaticallyWhen)
      return !1;
    const e = this.sendAutomaticallyWhen({
      messages: this.state.messages
    });
    return e && typeof e == "object" && "then" in e ? await e : e;
  }
  async makeRequest({
    trigger: e,
    metadata: t,
    headers: n,
    body: o,
    messageId: i
  }) {
    var l, c, f;
    this.setStatus({ status: "submitted", error: void 0 });
    const d = this.lastMessage;
    let h = !1, m = !1, v = !1;
    try {
      const b = {
        state: WI({
          lastMessage: this.state.snapshot(d),
          messageId: this.generateId()
        }),
        abortController: new AbortController()
      };
      b.abortController.signal.addEventListener("abort", () => {
        h = !0;
      }), this.activeResponse = b;
      let x;
      if (e === "resume-stream") {
        const w = await this.transport.reconnectToStream({
          chatId: this.id,
          metadata: t,
          headers: n,
          body: o
        });
        if (w == null) {
          this.setStatus({ status: "ready" });
          return;
        }
        x = w;
      } else
        x = await this.transport.sendMessages({
          chatId: this.id,
          messages: this.state.messages,
          abortSignal: b.abortController.signal,
          metadata: t,
          headers: n,
          body: o,
          trigger: e,
          messageId: i
        });
      const E = (w) => (
        // serialize the job execution to avoid race conditions:
        this.jobExecutor.run(
          () => w({
            state: b.state,
            write: () => {
              var C;
              this.setStatus({ status: "streaming" }), b.state.message.id === ((C = this.lastMessage) == null ? void 0 : C.id) ? this.state.replaceMessage(
                this.state.messages.length - 1,
                b.state.message
              ) : this.state.pushMessage(b.state.message);
            }
          })
        )
      );
      await KI({
        stream: XI({
          stream: x,
          onToolCall: this.onToolCall,
          onData: this.onData,
          messageMetadataSchema: this.messageMetadataSchema,
          dataPartSchemas: this.dataPartSchemas,
          runUpdateMessageJob: E,
          onError: (w) => {
            throw w;
          }
        }),
        onError: (w) => {
          throw w;
        }
      }), this.setStatus({ status: "ready" });
    } catch (b) {
      if (h || b.name === "AbortError")
        return h = !0, this.setStatus({ status: "ready" }), null;
      v = !0, b instanceof TypeError && (b.message.toLowerCase().includes("fetch") || b.message.toLowerCase().includes("network")) && (m = !0), this.onError && b instanceof Error && this.onError(b), this.setStatus({ status: "error", error: b });
    } finally {
      try {
        (c = this.onFinish) == null || c.call(this, {
          message: this.activeResponse.state.message,
          messages: this.state.messages,
          isAbort: h,
          isDisconnect: m,
          isError: v,
          finishReason: (l = this.activeResponse) == null ? void 0 : l.state.finishReason
        });
      } catch (b) {
        console.error(b);
      }
      this.activeResponse = void 0;
    }
    !v && await this.shouldSendAutomatically() && await this.makeRequest({
      trigger: "submit-message",
      messageId: (f = this.lastMessage) == null ? void 0 : f.id,
      metadata: t,
      headers: n,
      body: o
    });
  }
};
function r3({
  messages: e
}) {
  const t = e[e.length - 1];
  if (!t || t.role !== "assistant")
    return !1;
  const n = t.parts.reduce((i, l, c) => l.type === "step-start" ? c : i, -1), o = t.parts.slice(n + 1).filter(zo).filter((i) => !i.providerExecuted);
  return o.length > 0 && o.every(
    (i) => i.state === "output-available" || i.state === "output-error"
  );
}
var $p, Sw;
function o3() {
  if (Sw) return $p;
  Sw = 1;
  function e(t, n) {
    if (typeof t != "function")
      throw new TypeError(`Expected the first argument to be a \`function\`, got \`${typeof t}\`.`);
    let o, i = 0;
    return function(...c) {
      clearTimeout(o);
      const f = Date.now(), d = f - i, h = n - d;
      h <= 0 ? (i = f, t.apply(this, c)) : o = setTimeout(() => {
        i = Date.now(), t.apply(this, c);
      }, h);
    };
  }
  return $p = e, $p;
}
var a3 = /* @__PURE__ */ o3();
const i3 = /* @__PURE__ */ jl(a3);
var mT = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
}, lt = (e, t, n) => (mT(e, t, "read from private field"), n ? n.call(e) : t.get(e)), lr = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, _o = (e, t, n, o) => (mT(e, t, "write to private field"), t.set(e, n), n);
function s3(e, t) {
  return t != null ? i3(e, t) : e;
}
var Pn, ju, ku, tl, nl, rl, wi, km, Pm, l3 = class {
  constructor(e = []) {
    lr(this, Pn, void 0), lr(this, ju, "ready"), lr(this, ku, void 0), lr(this, tl, /* @__PURE__ */ new Set()), lr(this, nl, /* @__PURE__ */ new Set()), lr(this, rl, /* @__PURE__ */ new Set()), this.pushMessage = (t) => {
      _o(this, Pn, lt(this, Pn).concat(t)), lt(this, wi).call(this);
    }, this.popMessage = () => {
      _o(this, Pn, lt(this, Pn).slice(0, -1)), lt(this, wi).call(this);
    }, this.replaceMessage = (t, n) => {
      _o(this, Pn, [
        ...lt(this, Pn).slice(0, t),
        // We deep clone the message here to ensure the new React Compiler (currently in RC) detects deeply nested parts/metadata changes:
        this.snapshot(n),
        ...lt(this, Pn).slice(t + 1)
      ]), lt(this, wi).call(this);
    }, this.snapshot = (t) => structuredClone(t), this["~registerMessagesCallback"] = (t, n) => {
      const o = n ? s3(t, n) : t;
      return lt(this, tl).add(o), () => {
        lt(this, tl).delete(o);
      };
    }, this["~registerStatusCallback"] = (t) => (lt(this, nl).add(t), () => {
      lt(this, nl).delete(t);
    }), this["~registerErrorCallback"] = (t) => (lt(this, rl).add(t), () => {
      lt(this, rl).delete(t);
    }), lr(this, wi, () => {
      lt(this, tl).forEach((t) => t());
    }), lr(this, km, () => {
      lt(this, nl).forEach((t) => t());
    }), lr(this, Pm, () => {
      lt(this, rl).forEach((t) => t());
    }), _o(this, Pn, e);
  }
  get status() {
    return lt(this, ju);
  }
  set status(e) {
    _o(this, ju, e), lt(this, km).call(this);
  }
  get error() {
    return lt(this, ku);
  }
  set error(e) {
    _o(this, ku, e), lt(this, Pm).call(this);
  }
  get messages() {
    return lt(this, Pn);
  }
  set messages(e) {
    _o(this, Pn, [...e]), lt(this, wi).call(this);
  }
};
Pn = /* @__PURE__ */ new WeakMap();
ju = /* @__PURE__ */ new WeakMap();
ku = /* @__PURE__ */ new WeakMap();
tl = /* @__PURE__ */ new WeakMap();
nl = /* @__PURE__ */ new WeakMap();
rl = /* @__PURE__ */ new WeakMap();
wi = /* @__PURE__ */ new WeakMap();
km = /* @__PURE__ */ new WeakMap();
Pm = /* @__PURE__ */ new WeakMap();
var Ei, ww = class extends n3 {
  constructor({ messages: e, ...t }) {
    const n = new l3(e);
    super({ ...t, state: n }), lr(this, Ei, void 0), this["~registerMessagesCallback"] = (o, i) => lt(this, Ei)["~registerMessagesCallback"](o, i), this["~registerStatusCallback"] = (o) => lt(this, Ei)["~registerStatusCallback"](o), this["~registerErrorCallback"] = (o) => lt(this, Ei)["~registerErrorCallback"](o), _o(this, Ei, n);
  }
};
Ei = /* @__PURE__ */ new WeakMap();
function c3({
  experimental_throttle: e,
  resume: t = !1,
  ...n
} = {}) {
  const o = y.useRef(
    "chat" in n ? {} : {
      onToolCall: n.onToolCall,
      onData: n.onData,
      onFinish: n.onFinish,
      onError: n.onError,
      sendAutomaticallyWhen: n.sendAutomaticallyWhen
    }
  );
  "chat" in n || (o.current = {
    onToolCall: n.onToolCall,
    onData: n.onData,
    onFinish: n.onFinish,
    onError: n.onError,
    sendAutomaticallyWhen: n.sendAutomaticallyWhen
  });
  const i = {
    ...n,
    onToolCall: (b) => {
      var x, E;
      return (E = (x = o.current).onToolCall) == null ? void 0 : E.call(x, b);
    },
    onData: (b) => {
      var x, E;
      return (E = (x = o.current).onData) == null ? void 0 : E.call(x, b);
    },
    onFinish: (b) => {
      var x, E;
      return (E = (x = o.current).onFinish) == null ? void 0 : E.call(x, b);
    },
    onError: (b) => {
      var x, E;
      return (E = (x = o.current).onError) == null ? void 0 : E.call(x, b);
    },
    sendAutomaticallyWhen: (b) => {
      var x, E, w;
      return (w = (E = (x = o.current).sendAutomaticallyWhen) == null ? void 0 : E.call(x, b)) != null ? w : !1;
    }
  }, l = y.useRef(
    "chat" in n ? n.chat : new ww(i)
  );
  ("chat" in n && n.chat !== l.current || "id" in n && l.current.id !== n.id) && (l.current = "chat" in n ? n.chat : new ww(i));
  const f = y.useCallback(
    (b) => l.current["~registerMessagesCallback"](b, e),
    // `chatRef.current.id` is required to trigger re-subscription when the chat ID changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [e, l.current.id]
  ), d = y.useSyncExternalStore(
    f,
    () => l.current.messages,
    () => l.current.messages
  ), h = y.useSyncExternalStore(
    l.current["~registerStatusCallback"],
    () => l.current.status,
    () => l.current.status
  ), m = y.useSyncExternalStore(
    l.current["~registerErrorCallback"],
    () => l.current.error,
    () => l.current.error
  ), v = y.useCallback(
    (b) => {
      typeof b == "function" && (b = b(l.current.messages)), l.current.messages = b;
    },
    [l]
  );
  return y.useEffect(() => {
    t && l.current.resumeStream();
  }, [t, l]), {
    id: l.current.id,
    messages: d,
    setMessages: v,
    sendMessage: l.current.sendMessage,
    regenerate: l.current.regenerate,
    clearError: l.current.clearError,
    stop: l.current.stop,
    error: m,
    resumeStream: l.current.resumeStream,
    status: h,
    /**
     * @deprecated Use `addToolOutput` instead.
     */
    addToolResult: l.current.addToolOutput,
    addToolOutput: l.current.addToolOutput,
    addToolApprovalResponse: l.current.addToolApprovalResponse
  };
}
const Lg = y.createContext({});
function Ig(e) {
  const t = y.useRef(null);
  return t.current === null && (t.current = e()), t.current;
}
const gT = typeof window < "u", vT = gT ? y.useLayoutEffect : y.useEffect, jf = /* @__PURE__ */ y.createContext(null);
function Vg(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function Ug(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
const gr = (e, t, n) => n > t ? t : n < e ? e : n;
let Bg = () => {
};
const Fr = {}, yT = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
function bT(e) {
  return typeof e == "object" && e !== null;
}
const xT = (e) => /^0[^.\s]+$/u.test(e);
// @__NO_SIDE_EFFECTS__
function $g(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const Vn = /* @__NO_SIDE_EFFECTS__ */ (e) => e, u3 = (e, t) => (n) => t(e(n)), Il = (...e) => e.reduce(u3), El = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const o = t - e;
  return o === 0 ? 1 : (n - e) / o;
};
class Hg {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return Vg(this.subscriptions, t), () => Ug(this.subscriptions, t);
  }
  notify(t, n, o) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](t, n, o);
      else
        for (let l = 0; l < i; l++) {
          const c = this.subscriptions[l];
          c && c(t, n, o);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const Zr = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, In = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function ST(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const wT = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, f3 = 1e-7, d3 = 12;
function h3(e, t, n, o, i) {
  let l, c, f = 0;
  do
    c = t + (n - t) / 2, l = wT(c, o, i) - e, l > 0 ? n = c : t = c;
  while (Math.abs(l) > f3 && ++f < d3);
  return c;
}
function Vl(e, t, n, o) {
  if (e === t && n === o)
    return Vn;
  const i = (l) => h3(l, 0, 1, e, n);
  return (l) => l === 0 || l === 1 ? l : wT(i(l), t, o);
}
const ET = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, _T = (e) => (t) => 1 - e(1 - t), TT = /* @__PURE__ */ Vl(0.33, 1.53, 0.69, 0.99), Zg = /* @__PURE__ */ _T(TT), CT = /* @__PURE__ */ ET(Zg), AT = (e) => (e *= 2) < 1 ? 0.5 * Zg(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), Fg = (e) => 1 - Math.sin(Math.acos(e)), RT = _T(Fg), MT = ET(Fg), p3 = /* @__PURE__ */ Vl(0.42, 0, 1, 1), m3 = /* @__PURE__ */ Vl(0, 0, 0.58, 1), zT = /* @__PURE__ */ Vl(0.42, 0, 0.58, 1), g3 = (e) => Array.isArray(e) && typeof e[0] != "number", DT = (e) => Array.isArray(e) && typeof e[0] == "number", v3 = {
  linear: Vn,
  easeIn: p3,
  easeInOut: zT,
  easeOut: m3,
  circIn: Fg,
  circInOut: MT,
  circOut: RT,
  backIn: Zg,
  backInOut: CT,
  backOut: TT,
  anticipate: AT
}, y3 = (e) => typeof e == "string", Ew = (e) => {
  if (DT(e)) {
    Bg(e.length === 4);
    const [t, n, o, i] = e;
    return Vl(t, n, o, i);
  } else if (y3(e))
    return v3[e];
  return e;
}, Su = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function b3(e, t) {
  let n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), i = !1, l = !1;
  const c = /* @__PURE__ */ new WeakSet();
  let f = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function d(m) {
    c.has(m) && (h.schedule(m), e()), m(f);
  }
  const h = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (m, v = !1, b = !1) => {
      const E = b && i ? n : o;
      return v && c.add(m), E.has(m) || E.add(m), m;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (m) => {
      o.delete(m), c.delete(m);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (m) => {
      if (f = m, i) {
        l = !0;
        return;
      }
      i = !0, [n, o] = [o, n], n.forEach(d), n.clear(), i = !1, l && (l = !1, h.process(m));
    }
  };
  return h;
}
const x3 = 40;
function NT(e, t) {
  let n = !1, o = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, l = () => n = !0, c = Su.reduce((T, D) => (T[D] = b3(l), T), {}), { setup: f, read: d, resolveKeyframes: h, preUpdate: m, update: v, preRender: b, render: x, postRender: E } = c, w = () => {
    const T = Fr.useManualTiming ? i.timestamp : performance.now();
    n = !1, Fr.useManualTiming || (i.delta = o ? 1e3 / 60 : Math.max(Math.min(T - i.timestamp, x3), 1)), i.timestamp = T, i.isProcessing = !0, f.process(i), d.process(i), h.process(i), m.process(i), v.process(i), b.process(i), x.process(i), E.process(i), i.isProcessing = !1, n && t && (o = !1, e(w));
  }, C = () => {
    n = !0, o = !0, i.isProcessing || e(w);
  };
  return { schedule: Su.reduce((T, D) => {
    const O = c[D];
    return T[D] = (k, R = !1, N = !1) => (n || C(), O.schedule(k, R, N)), T;
  }, {}), cancel: (T) => {
    for (let D = 0; D < Su.length; D++)
      c[Su[D]].cancel(T);
  }, state: i, steps: c };
}
const { schedule: nt, cancel: ko, state: Bt, steps: Hp } = /* @__PURE__ */ NT(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Vn, !0);
let Pu;
function S3() {
  Pu = void 0;
}
const Xt = {
  now: () => (Pu === void 0 && Xt.set(Bt.isProcessing || Fr.useManualTiming ? Bt.timestamp : performance.now()), Pu),
  set: (e) => {
    Pu = e, queueMicrotask(S3);
  }
}, OT = (e) => (t) => typeof t == "string" && t.startsWith(e), jT = /* @__PURE__ */ OT("--"), w3 = /* @__PURE__ */ OT("var(--"), Gg = (e) => w3(e) ? E3.test(e.split("/*")[0].trim()) : !1, E3 = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function _w(e) {
  return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--");
}
const Gi = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, _l = {
  ...Gi,
  transform: (e) => gr(0, 1, e)
}, wu = {
  ...Gi,
  default: 1
}, hl = (e) => Math.round(e * 1e5) / 1e5, Yg = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function _3(e) {
  return e == null;
}
const T3 = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, qg = (e, t) => (n) => !!(typeof n == "string" && T3.test(n) && n.startsWith(e) || t && !_3(n) && Object.prototype.hasOwnProperty.call(n, t)), kT = (e, t, n) => (o) => {
  if (typeof o != "string")
    return o;
  const [i, l, c, f] = o.match(Yg);
  return {
    [e]: parseFloat(i),
    [t]: parseFloat(l),
    [n]: parseFloat(c),
    alpha: f !== void 0 ? parseFloat(f) : 1
  };
}, C3 = (e) => gr(0, 255, e), Zp = {
  ...Gi,
  transform: (e) => Math.round(C3(e))
}, ma = {
  test: /* @__PURE__ */ qg("rgb", "red"),
  parse: /* @__PURE__ */ kT("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: o = 1 }) => "rgba(" + Zp.transform(e) + ", " + Zp.transform(t) + ", " + Zp.transform(n) + ", " + hl(_l.transform(o)) + ")"
};
function A3(e) {
  let t = "", n = "", o = "", i = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), o = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), o = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, o += o, i += i), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(o, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Lm = {
  test: /* @__PURE__ */ qg("#"),
  parse: A3,
  transform: ma.transform
}, Ul = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), To = /* @__PURE__ */ Ul("deg"), hr = /* @__PURE__ */ Ul("%"), xe = /* @__PURE__ */ Ul("px"), R3 = /* @__PURE__ */ Ul("vh"), M3 = /* @__PURE__ */ Ul("vw"), Tw = {
  ...hr,
  parse: (e) => hr.parse(e) / 100,
  transform: (e) => hr.transform(e * 100)
}, Ai = {
  test: /* @__PURE__ */ qg("hsl", "hue"),
  parse: /* @__PURE__ */ kT("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: o = 1 }) => "hsla(" + Math.round(e) + ", " + hr.transform(hl(t)) + ", " + hr.transform(hl(n)) + ", " + hl(_l.transform(o)) + ")"
}, At = {
  test: (e) => ma.test(e) || Lm.test(e) || Ai.test(e),
  parse: (e) => ma.test(e) ? ma.parse(e) : Ai.test(e) ? Ai.parse(e) : Lm.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? ma.transform(e) : Ai.transform(e),
  getAnimatableNone: (e) => {
    const t = At.parse(e);
    return t.alpha = 0, At.transform(t);
  }
}, z3 = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function D3(e) {
  return isNaN(e) && typeof e == "string" && (e.match(Yg)?.length || 0) + (e.match(z3)?.length || 0) > 0;
}
const PT = "number", LT = "color", N3 = "var", O3 = "var(", Cw = "${}", j3 = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Tl(e) {
  const t = e.toString(), n = [], o = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let l = 0;
  const f = t.replace(j3, (d) => (At.test(d) ? (o.color.push(l), i.push(LT), n.push(At.parse(d))) : d.startsWith(O3) ? (o.var.push(l), i.push(N3), n.push(d)) : (o.number.push(l), i.push(PT), n.push(parseFloat(d))), ++l, Cw)).split(Cw);
  return { values: n, split: f, indexes: o, types: i };
}
function IT(e) {
  return Tl(e).values;
}
function VT(e) {
  const { split: t, types: n } = Tl(e), o = t.length;
  return (i) => {
    let l = "";
    for (let c = 0; c < o; c++)
      if (l += t[c], i[c] !== void 0) {
        const f = n[c];
        f === PT ? l += hl(i[c]) : f === LT ? l += At.transform(i[c]) : l += i[c];
      }
    return l;
  };
}
const k3 = (e) => typeof e == "number" ? 0 : At.test(e) ? At.getAnimatableNone(e) : e;
function P3(e) {
  const t = IT(e);
  return VT(e)(t.map(k3));
}
const Po = {
  test: D3,
  parse: IT,
  createTransformer: VT,
  getAnimatableNone: P3
};
function Fp(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function L3({ hue: e, saturation: t, lightness: n, alpha: o }) {
  e /= 360, t /= 100, n /= 100;
  let i = 0, l = 0, c = 0;
  if (!t)
    i = l = c = n;
  else {
    const f = n < 0.5 ? n * (1 + t) : n + t - n * t, d = 2 * n - f;
    i = Fp(d, f, e + 1 / 3), l = Fp(d, f, e), c = Fp(d, f, e - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(l * 255),
    blue: Math.round(c * 255),
    alpha: o
  };
}
function ef(e, t) {
  return (n) => n > 0 ? t : e;
}
const ht = (e, t, n) => e + (t - e) * n, Gp = (e, t, n) => {
  const o = e * e, i = n * (t * t - o) + o;
  return i < 0 ? 0 : Math.sqrt(i);
}, I3 = [Lm, ma, Ai], V3 = (e) => I3.find((t) => t.test(e));
function Aw(e) {
  const t = V3(e);
  if (!t)
    return !1;
  let n = t.parse(e);
  return t === Ai && (n = L3(n)), n;
}
const Rw = (e, t) => {
  const n = Aw(e), o = Aw(t);
  if (!n || !o)
    return ef(e, t);
  const i = { ...n };
  return (l) => (i.red = Gp(n.red, o.red, l), i.green = Gp(n.green, o.green, l), i.blue = Gp(n.blue, o.blue, l), i.alpha = ht(n.alpha, o.alpha, l), ma.transform(i));
}, Im = /* @__PURE__ */ new Set(["none", "hidden"]);
function U3(e, t) {
  return Im.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
function B3(e, t) {
  return (n) => ht(e, t, n);
}
function Wg(e) {
  return typeof e == "number" ? B3 : typeof e == "string" ? Gg(e) ? ef : At.test(e) ? Rw : Z3 : Array.isArray(e) ? UT : typeof e == "object" ? At.test(e) ? Rw : $3 : ef;
}
function UT(e, t) {
  const n = [...e], o = n.length, i = e.map((l, c) => Wg(l)(l, t[c]));
  return (l) => {
    for (let c = 0; c < o; c++)
      n[c] = i[c](l);
    return n;
  };
}
function $3(e, t) {
  const n = { ...e, ...t }, o = {};
  for (const i in n)
    e[i] !== void 0 && t[i] !== void 0 && (o[i] = Wg(e[i])(e[i], t[i]));
  return (i) => {
    for (const l in o)
      n[l] = o[l](i);
    return n;
  };
}
function H3(e, t) {
  const n = [], o = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < t.values.length; i++) {
    const l = t.types[i], c = e.indexes[l][o[l]], f = e.values[c] ?? 0;
    n[i] = f, o[l]++;
  }
  return n;
}
const Z3 = (e, t) => {
  const n = Po.createTransformer(t), o = Tl(e), i = Tl(t);
  return o.indexes.var.length === i.indexes.var.length && o.indexes.color.length === i.indexes.color.length && o.indexes.number.length >= i.indexes.number.length ? Im.has(e) && !i.values.length || Im.has(t) && !o.values.length ? U3(e, t) : Il(UT(H3(o, i), i.values), n) : ef(e, t);
};
function BT(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? ht(e, t, n) : Wg(e)(e, t);
}
const F3 = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => nt.update(t, n),
    stop: () => ko(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Bt.isProcessing ? Bt.timestamp : Xt.now()
  };
}, $T = (e, t, n = 10) => {
  let o = "";
  const i = Math.max(Math.round(t / n), 2);
  for (let l = 0; l < i; l++)
    o += Math.round(e(l / (i - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${o.substring(0, o.length - 2)})`;
}, tf = 2e4;
function Xg(e) {
  let t = 0;
  const n = 50;
  let o = e.next(t);
  for (; !o.done && t < tf; )
    t += n, o = e.next(t);
  return t >= tf ? 1 / 0 : t;
}
function G3(e, t = 100, n) {
  const o = n({ ...e, keyframes: [0, t] }), i = Math.min(Xg(o), tf);
  return {
    type: "keyframes",
    ease: (l) => o.next(i * l).value / t,
    duration: /* @__PURE__ */ In(i)
  };
}
const Y3 = 5;
function HT(e, t, n) {
  const o = Math.max(t - Y3, 0);
  return ST(n - e(o), t - o);
}
const vt = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, Yp = 1e-3;
function q3({ duration: e = vt.duration, bounce: t = vt.bounce, velocity: n = vt.velocity, mass: o = vt.mass }) {
  let i, l, c = 1 - t;
  c = gr(vt.minDamping, vt.maxDamping, c), e = gr(vt.minDuration, vt.maxDuration, /* @__PURE__ */ In(e)), c < 1 ? (i = (h) => {
    const m = h * c, v = m * e, b = m - n, x = Vm(h, c), E = Math.exp(-v);
    return Yp - b / x * E;
  }, l = (h) => {
    const v = h * c * e, b = v * n + n, x = Math.pow(c, 2) * Math.pow(h, 2) * e, E = Math.exp(-v), w = Vm(Math.pow(h, 2), c);
    return (-i(h) + Yp > 0 ? -1 : 1) * ((b - x) * E) / w;
  }) : (i = (h) => {
    const m = Math.exp(-h * e), v = (h - n) * e + 1;
    return -Yp + m * v;
  }, l = (h) => {
    const m = Math.exp(-h * e), v = (n - h) * (e * e);
    return m * v;
  });
  const f = 5 / e, d = X3(i, l, f);
  if (e = /* @__PURE__ */ Zr(e), isNaN(d))
    return {
      stiffness: vt.stiffness,
      damping: vt.damping,
      duration: e
    };
  {
    const h = Math.pow(d, 2) * o;
    return {
      stiffness: h,
      damping: c * 2 * Math.sqrt(o * h),
      duration: e
    };
  }
}
const W3 = 12;
function X3(e, t, n) {
  let o = n;
  for (let i = 1; i < W3; i++)
    o = o - e(o) / t(o);
  return o;
}
function Vm(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const K3 = ["duration", "bounce"], J3 = ["stiffness", "damping", "mass"];
function Mw(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function Q3(e) {
  let t = {
    velocity: vt.velocity,
    stiffness: vt.stiffness,
    damping: vt.damping,
    mass: vt.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!Mw(e, J3) && Mw(e, K3))
    if (e.visualDuration) {
      const n = e.visualDuration, o = 2 * Math.PI / (n * 1.2), i = o * o, l = 2 * gr(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i);
      t = {
        ...t,
        mass: vt.mass,
        stiffness: i,
        damping: l
      };
    } else {
      const n = q3(e);
      t = {
        ...t,
        ...n,
        mass: vt.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function nf(e = vt.visualDuration, t = vt.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: o, restDelta: i } = n;
  const l = n.keyframes[0], c = n.keyframes[n.keyframes.length - 1], f = { done: !1, value: l }, { stiffness: d, damping: h, mass: m, duration: v, velocity: b, isResolvedFromDuration: x } = Q3({
    ...n,
    velocity: -/* @__PURE__ */ In(n.velocity || 0)
  }), E = b || 0, w = h / (2 * Math.sqrt(d * m)), C = c - l, A = /* @__PURE__ */ In(Math.sqrt(d / m)), M = Math.abs(C) < 5;
  o || (o = M ? vt.restSpeed.granular : vt.restSpeed.default), i || (i = M ? vt.restDelta.granular : vt.restDelta.default);
  let T;
  if (w < 1) {
    const O = Vm(A, w);
    T = (k) => {
      const R = Math.exp(-w * A * k);
      return c - R * ((E + w * A * C) / O * Math.sin(O * k) + C * Math.cos(O * k));
    };
  } else if (w === 1)
    T = (O) => c - Math.exp(-A * O) * (C + (E + A * C) * O);
  else {
    const O = A * Math.sqrt(w * w - 1);
    T = (k) => {
      const R = Math.exp(-w * A * k), N = Math.min(O * k, 300);
      return c - R * ((E + w * A * C) * Math.sinh(N) + O * C * Math.cosh(N)) / O;
    };
  }
  const D = {
    calculatedDuration: x && v || null,
    next: (O) => {
      const k = T(O);
      if (x)
        f.done = O >= v;
      else {
        let R = O === 0 ? E : 0;
        w < 1 && (R = O === 0 ? /* @__PURE__ */ Zr(E) : HT(T, O, k));
        const N = Math.abs(R) <= o, P = Math.abs(c - k) <= i;
        f.done = N && P;
      }
      return f.value = f.done ? c : k, f;
    },
    toString: () => {
      const O = Math.min(Xg(D), tf), k = $T((R) => D.next(O * R).value, O, 30);
      return O + "ms " + k;
    },
    toTransition: () => {
    }
  };
  return D;
}
nf.applyToOptions = (e) => {
  const t = G3(e, 100, nf);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ Zr(t.duration), e.type = "keyframes", e;
};
function Um({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: o = 325, bounceDamping: i = 10, bounceStiffness: l = 500, modifyTarget: c, min: f, max: d, restDelta: h = 0.5, restSpeed: m }) {
  const v = e[0], b = {
    done: !1,
    value: v
  }, x = (N) => f !== void 0 && N < f || d !== void 0 && N > d, E = (N) => f === void 0 ? d : d === void 0 || Math.abs(f - N) < Math.abs(d - N) ? f : d;
  let w = n * t;
  const C = v + w, A = c === void 0 ? C : c(C);
  A !== C && (w = A - v);
  const M = (N) => -w * Math.exp(-N / o), T = (N) => A + M(N), D = (N) => {
    const P = M(N), Y = T(N);
    b.done = Math.abs(P) <= h, b.value = b.done ? A : Y;
  };
  let O, k;
  const R = (N) => {
    x(b.value) && (O = N, k = nf({
      keyframes: [b.value, E(b.value)],
      velocity: HT(T, N, b.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: l,
      restDelta: h,
      restSpeed: m
    }));
  };
  return R(0), {
    calculatedDuration: null,
    next: (N) => {
      let P = !1;
      return !k && O === void 0 && (P = !0, D(N), R(N)), O !== void 0 && N >= O ? k.next(N - O) : (!P && D(N), b);
    }
  };
}
function e5(e, t, n) {
  const o = [], i = n || Fr.mix || BT, l = e.length - 1;
  for (let c = 0; c < l; c++) {
    let f = i(e[c], e[c + 1]);
    if (t) {
      const d = Array.isArray(t) ? t[c] || Vn : t;
      f = Il(d, f);
    }
    o.push(f);
  }
  return o;
}
function t5(e, t, { clamp: n = !0, ease: o, mixer: i } = {}) {
  const l = e.length;
  if (Bg(l === t.length), l === 1)
    return () => t[0];
  if (l === 2 && t[0] === t[1])
    return () => t[1];
  const c = e[0] === e[1];
  e[0] > e[l - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const f = e5(t, o, i), d = f.length, h = (m) => {
    if (c && m < e[0])
      return t[0];
    let v = 0;
    if (d > 1)
      for (; v < e.length - 2 && !(m < e[v + 1]); v++)
        ;
    const b = /* @__PURE__ */ El(e[v], e[v + 1], m);
    return f[v](b);
  };
  return n ? (m) => h(gr(e[0], e[l - 1], m)) : h;
}
function n5(e, t) {
  const n = e[e.length - 1];
  for (let o = 1; o <= t; o++) {
    const i = /* @__PURE__ */ El(0, t, o);
    e.push(ht(n, 1, i));
  }
}
function r5(e) {
  const t = [0];
  return n5(t, e.length - 1), t;
}
function o5(e, t) {
  return e.map((n) => n * t);
}
function a5(e, t) {
  return e.map(() => t || zT).splice(0, e.length - 1);
}
function pl({ duration: e = 300, keyframes: t, times: n, ease: o = "easeInOut" }) {
  const i = g3(o) ? o.map(Ew) : Ew(o), l = {
    done: !1,
    value: t[0]
  }, c = o5(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : r5(t),
    e
  ), f = t5(c, t, {
    ease: Array.isArray(i) ? i : a5(t, i)
  });
  return {
    calculatedDuration: e,
    next: (d) => (l.value = f(d), l.done = d >= e, l)
  };
}
const i5 = (e) => e !== null;
function Kg(e, { repeat: t, repeatType: n = "loop" }, o, i = 1) {
  const l = e.filter(i5), f = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : l.length - 1;
  return !f || o === void 0 ? l[f] : o;
}
const s5 = {
  decay: Um,
  inertia: Um,
  tween: pl,
  keyframes: pl,
  spring: nf
};
function ZT(e) {
  typeof e.type == "string" && (e.type = s5[e.type]);
}
class Jg {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const l5 = (e) => e / 100;
class Qg extends Jg {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      const { motionValue: n } = this.options;
      n && n.updatedAt !== Xt.now() && this.tick(Xt.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), this.options.onStop?.());
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    ZT(t);
    const { type: n = pl, repeat: o = 0, repeatDelay: i = 0, repeatType: l, velocity: c = 0 } = t;
    let { keyframes: f } = t;
    const d = n || pl;
    d !== pl && typeof f[0] != "number" && (this.mixKeyframes = Il(l5, BT(f[0], f[1])), f = [0, 100]);
    const h = d({ ...t, keyframes: f });
    l === "mirror" && (this.mirroredGenerator = d({
      ...t,
      keyframes: [...f].reverse(),
      velocity: -c
    })), h.calculatedDuration === null && (h.calculatedDuration = Xg(h));
    const { calculatedDuration: m } = h;
    this.calculatedDuration = m, this.resolvedDuration = m + i, this.totalDuration = this.resolvedDuration * (o + 1) - i, this.generator = h;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: o, totalDuration: i, mixKeyframes: l, mirroredGenerator: c, resolvedDuration: f, calculatedDuration: d } = this;
    if (this.startTime === null)
      return o.next(0);
    const { delay: h = 0, keyframes: m, repeat: v, repeatType: b, repeatDelay: x, type: E, onUpdate: w, finalKeyframe: C } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const A = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1), M = this.playbackSpeed >= 0 ? A < 0 : A > i;
    this.currentTime = Math.max(A, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i);
    let T = this.currentTime, D = o;
    if (v) {
      const N = Math.min(this.currentTime, i) / f;
      let P = Math.floor(N), Y = N % 1;
      !Y && N >= 1 && (Y = 1), Y === 1 && P--, P = Math.min(P, v + 1), P % 2 && (b === "reverse" ? (Y = 1 - Y, x && (Y -= x / f)) : b === "mirror" && (D = c)), T = gr(0, 1, Y) * f;
    }
    const O = M ? { done: !1, value: m[0] } : D.next(T);
    l && (O.value = l(O.value));
    let { done: k } = O;
    !M && d !== null && (k = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);
    const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && k);
    return R && E !== Um && (O.value = Kg(m, this.options, C, this.speed)), w && w(O.value), R && this.finish(), O;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ In(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ In(t);
  }
  get time() {
    return /* @__PURE__ */ In(this.currentTime);
  }
  set time(t) {
    t = /* @__PURE__ */ Zr(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), this.driver?.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(Xt.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ In(this.currentTime));
  }
  play() {
    if (this.isStopped)
      return;
    const { driver: t = F3, startTime: n } = this.options;
    this.driver || (this.driver = t((i) => this.tick(i))), this.options.onPlay?.();
    const o = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = o) : this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime || (this.startTime = n ?? o), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(Xt.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.notifyFinished(), this.teardown(), this.state = "finished", this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), this.driver?.stop(), t.observe(this);
  }
}
function c5(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const ga = (e) => e * 180 / Math.PI, Bm = (e) => {
  const t = ga(Math.atan2(e[1], e[0]));
  return $m(t);
}, u5 = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate: Bm,
  rotateZ: Bm,
  skewX: (e) => ga(Math.atan(e[1])),
  skewY: (e) => ga(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, $m = (e) => (e = e % 360, e < 0 && (e += 360), e), zw = Bm, Dw = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), Nw = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), f5 = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: Dw,
  scaleY: Nw,
  scale: (e) => (Dw(e) + Nw(e)) / 2,
  rotateX: (e) => $m(ga(Math.atan2(e[6], e[5]))),
  rotateY: (e) => $m(ga(Math.atan2(-e[2], e[0]))),
  rotateZ: zw,
  rotate: zw,
  skewX: (e) => ga(Math.atan(e[4])),
  skewY: (e) => ga(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function Hm(e) {
  return e.includes("scale") ? 1 : 0;
}
function Zm(e, t) {
  if (!e || e === "none")
    return Hm(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let o, i;
  if (n)
    o = f5, i = n;
  else {
    const f = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    o = u5, i = f;
  }
  if (!i)
    return Hm(t);
  const l = o[t], c = i[1].split(",").map(h5);
  return typeof l == "function" ? l(c) : c[l];
}
const d5 = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return Zm(n, t);
};
function h5(e) {
  return parseFloat(e.trim());
}
const Yi = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], qi = new Set(Yi), Ow = (e) => e === Gi || e === xe, p5 = /* @__PURE__ */ new Set(["x", "y", "z"]), m5 = Yi.filter((e) => !p5.has(e));
function g5(e) {
  const t = [];
  return m5.forEach((n) => {
    const o = e.getValue(n);
    o !== void 0 && (t.push([n, o.get()]), o.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const Do = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => Zm(t, "x"),
  y: (e, { transform: t }) => Zm(t, "y")
};
Do.translateX = Do.x;
Do.translateY = Do.y;
const ya = /* @__PURE__ */ new Set();
let Fm = !1, Gm = !1, Ym = !1;
function FT() {
  if (Gm) {
    const e = Array.from(ya).filter((o) => o.needsMeasurement), t = new Set(e.map((o) => o.element)), n = /* @__PURE__ */ new Map();
    t.forEach((o) => {
      const i = g5(o);
      i.length && (n.set(o, i), o.render());
    }), e.forEach((o) => o.measureInitialState()), t.forEach((o) => {
      o.render();
      const i = n.get(o);
      i && i.forEach(([l, c]) => {
        o.getValue(l)?.set(c);
      });
    }), e.forEach((o) => o.measureEndState()), e.forEach((o) => {
      o.suspendedScrollY !== void 0 && window.scrollTo(0, o.suspendedScrollY);
    });
  }
  Gm = !1, Fm = !1, ya.forEach((e) => e.complete(Ym)), ya.clear();
}
function GT() {
  ya.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Gm = !0);
  });
}
function v5() {
  Ym = !0, GT(), FT(), Ym = !1;
}
class ev {
  constructor(t, n, o, i, l, c = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = o, this.motionValue = i, this.element = l, this.isAsync = c;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (ya.add(this), Fm || (Fm = !0, nt.read(GT), nt.resolveKeyframes(FT))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: o, motionValue: i } = this;
    if (t[0] === null) {
      const l = i?.get(), c = t[t.length - 1];
      if (l !== void 0)
        t[0] = l;
      else if (o && n) {
        const f = o.readValue(n, c);
        f != null && (t[0] = f);
      }
      t[0] === void 0 && (t[0] = c), i && l === void 0 && i.set(t[0]);
    }
    c5(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), ya.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (ya.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const y5 = (e) => e.startsWith("--");
function b5(e, t, n) {
  y5(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
const x5 = /* @__PURE__ */ $g(() => window.ScrollTimeline !== void 0), S5 = {};
function w5(e, t) {
  const n = /* @__PURE__ */ $g(e);
  return () => S5[t] ?? n();
}
const YT = /* @__PURE__ */ w5(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), ol = ([e, t, n, o]) => `cubic-bezier(${e}, ${t}, ${n}, ${o})`, jw = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ ol([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ ol([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ ol([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ ol([0.33, 1.53, 0.69, 0.99])
};
function qT(e, t) {
  if (e)
    return typeof e == "function" ? YT() ? $T(e, t) : "ease-out" : DT(e) ? ol(e) : Array.isArray(e) ? e.map((n) => qT(n, t) || jw.easeOut) : jw[e];
}
function E5(e, t, n, { delay: o = 0, duration: i = 300, repeat: l = 0, repeatType: c = "loop", ease: f = "easeOut", times: d } = {}, h = void 0) {
  const m = {
    [t]: n
  };
  d && (m.offset = d);
  const v = qT(f, i);
  Array.isArray(v) && (m.easing = v);
  const b = {
    delay: o,
    duration: i,
    easing: Array.isArray(v) ? "linear" : v,
    fill: "both",
    iterations: l + 1,
    direction: c === "reverse" ? "alternate" : "normal"
  };
  return h && (b.pseudoElement = h), e.animate(m, b);
}
function WT(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
function _5({ type: e, ...t }) {
  return WT(e) && YT() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class T5 extends Jg {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t)
      return;
    const { element: n, name: o, keyframes: i, pseudoElement: l, allowFlatten: c = !1, finalKeyframe: f, onComplete: d } = t;
    this.isPseudoElement = !!l, this.allowFlatten = c, this.options = t, Bg(typeof t.type != "string");
    const h = _5(t);
    this.animation = E5(n, o, i, h, l), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !l) {
        const m = Kg(i, this.options, f, this.speed);
        this.updateMotionValue ? this.updateMotionValue(m) : b5(n, o, m), this.animation.cancel();
      }
      d?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    const t = this.options?.element;
    !this.isPseudoElement && t?.isConnected && this.animation.commitStyles?.();
  }
  get duration() {
    const t = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ In(Number(t));
  }
  get iterationDuration() {
    const { delay: t = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ In(t);
  }
  get time() {
    return /* @__PURE__ */ In(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Zr(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(t) {
    this.manualStartTime = this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: "linear" }), this.animation.onfinish = null, t && x5() ? (this.animation.timeline = t, Vn) : n(this);
  }
}
const XT = {
  anticipate: AT,
  backInOut: CT,
  circInOut: MT
};
function C5(e) {
  return e in XT;
}
function A5(e) {
  typeof e.ease == "string" && C5(e.ease) && (e.ease = XT[e.ease]);
}
const qp = 10;
class R5 extends T5 {
  constructor(t) {
    A5(t), ZT(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: o, onComplete: i, element: l, ...c } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const f = new Qg({
      ...c,
      autoplay: !1
    }), d = Math.max(qp, Xt.now() - this.startTime), h = gr(0, qp, d - qp);
    n.setWithVelocity(f.sample(Math.max(0, d - h)).value, f.sample(d).value, h), f.stop();
  }
}
const kw = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(Po.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function M5(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function z5(e, t, n, o) {
  const i = e[0];
  if (i === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const l = e[e.length - 1], c = kw(i, t), f = kw(l, t);
  return !c || !f ? !1 : M5(e) || (n === "spring" || WT(n)) && o;
}
function qm(e) {
  e.duration = 0, e.type = "keyframes";
}
const D5 = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), N5 = /* @__PURE__ */ $g(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function O5(e) {
  const { motionValue: t, name: n, repeatDelay: o, repeatType: i, damping: l, type: c } = e;
  if (!(t?.owner?.current instanceof HTMLElement))
    return !1;
  const { onUpdate: d, transformTemplate: h } = t.owner.getProps();
  return N5() && n && D5.has(n) && (n !== "transform" || !h) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !d && !o && i !== "mirror" && l !== 0 && c !== "inertia";
}
const j5 = 40;
class k5 extends Jg {
  constructor({ autoplay: t = !0, delay: n = 0, type: o = "keyframes", repeat: i = 0, repeatDelay: l = 0, repeatType: c = "loop", keyframes: f, name: d, motionValue: h, element: m, ...v }) {
    super(), this.stop = () => {
      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();
    }, this.createdAt = Xt.now();
    const b = {
      autoplay: t,
      delay: n,
      type: o,
      repeat: i,
      repeatDelay: l,
      repeatType: c,
      name: d,
      motionValue: h,
      element: m,
      ...v
    }, x = m?.KeyframeResolver || ev;
    this.keyframeResolver = new x(f, (E, w, C) => this.onKeyframesResolved(E, w, b, !C), d, h, m), this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(t, n, o, i) {
    this.keyframeResolver = void 0;
    const { name: l, type: c, velocity: f, delay: d, isHandoff: h, onUpdate: m } = o;
    this.resolvedAt = Xt.now(), z5(t, l, c, f) || ((Fr.instantAnimations || !d) && m?.(Kg(t, o, n)), t[0] = t[t.length - 1], qm(o), o.repeat = 0);
    const b = {
      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > j5 ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...o,
      keyframes: t
    }, x = !h && O5(b), E = b.motionValue?.owner?.current, w = x ? new R5({
      ...b,
      element: E
    }) : new Qg(b);
    w.finished.then(() => {
      this.notifyFinished();
    }).catch(Vn), this.pendingTimeline && (this.stopTimeline = w.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = w;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    return this._animation || (this.keyframeResolver?.resume(), v5()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();
  }
}
function KT(e, t, n, o = 0, i = 1) {
  const l = Array.from(e).sort((h, m) => h.sortNodePosition(m)).indexOf(t), c = e.size, f = (c - 1) * o;
  return typeof n == "function" ? n(l, c) : i === 1 ? l * o : f - l * o;
}
const P5 = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function L5(e) {
  const t = P5.exec(e);
  if (!t)
    return [,];
  const [, n, o, i] = t;
  return [`--${n ?? o}`, i];
}
function JT(e, t, n = 1) {
  const [o, i] = L5(e);
  if (!o)
    return;
  const l = window.getComputedStyle(t).getPropertyValue(o);
  if (l) {
    const c = l.trim();
    return yT(c) ? parseFloat(c) : c;
  }
  return Gg(i) ? JT(i, t, n + 1) : i;
}
const I5 = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, V5 = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), U5 = {
  type: "keyframes",
  duration: 0.8
}, B5 = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, $5 = (e, { keyframes: t }) => t.length > 2 ? U5 : qi.has(e) ? e.startsWith("scale") ? V5(t[1]) : I5 : B5, H5 = (e) => e !== null;
function Z5(e, { repeat: t, repeatType: n = "loop" }, o) {
  const i = e.filter(H5), l = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1;
  return i[l];
}
function tv(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function F5({ when: e, delay: t, delayChildren: n, staggerChildren: o, staggerDirection: i, repeat: l, repeatType: c, repeatDelay: f, from: d, elapsed: h, ...m }) {
  return !!Object.keys(m).length;
}
const nv = (e, t, n, o = {}, i, l) => (c) => {
  const f = tv(o, e) || {}, d = f.delay || o.delay || 0;
  let { elapsed: h = 0 } = o;
  h = h - /* @__PURE__ */ Zr(d);
  const m = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...f,
    delay: -h,
    onUpdate: (b) => {
      t.set(b), f.onUpdate && f.onUpdate(b);
    },
    onComplete: () => {
      c(), f.onComplete && f.onComplete();
    },
    name: e,
    motionValue: t,
    element: l ? void 0 : i
  };
  F5(f) || Object.assign(m, $5(e, m)), m.duration && (m.duration = /* @__PURE__ */ Zr(m.duration)), m.repeatDelay && (m.repeatDelay = /* @__PURE__ */ Zr(m.repeatDelay)), m.from !== void 0 && (m.keyframes[0] = m.from);
  let v = !1;
  if ((m.type === !1 || m.duration === 0 && !m.repeatDelay) && (qm(m), m.delay === 0 && (v = !0)), (Fr.instantAnimations || Fr.skipAnimations || i?.shouldSkipAnimations) && (v = !0, qm(m), m.delay = 0), m.allowFlatten = !f.type && !f.ease, v && !l && t.get() !== void 0) {
    const b = Z5(m.keyframes, f);
    if (b !== void 0) {
      nt.update(() => {
        m.onUpdate(b), m.onComplete();
      });
      return;
    }
  }
  return f.isSync ? new Qg(m) : new k5(m);
};
function Pw(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, o) => {
    t[0][o] = n.get(), t[1][o] = n.getVelocity();
  }), t;
}
function rv(e, t, n, o) {
  if (typeof t == "function") {
    const [i, l] = Pw(o);
    t = t(n !== void 0 ? n : e.custom, i, l);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [i, l] = Pw(o);
    t = t(n !== void 0 ? n : e.custom, i, l);
  }
  return t;
}
function Oi(e, t, n) {
  const o = e.getProps();
  return rv(o, t, n !== void 0 ? n : o.custom, e);
}
const QT = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...Yi
]), Lw = 30, G5 = (e) => !isNaN(parseFloat(e));
class Y5 {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (o) => {
      const i = Xt.now();
      if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(o), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))
        for (const l of this.dependents)
          l.dirty();
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = Xt.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = G5(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new Hg());
    const o = this.events[t].add(n);
    return t === "change" ? () => {
      o(), nt.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : o;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t) {
    this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t);
  }
  setWithVelocity(t, n, o) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - o;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = Xt.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > Lw)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, Lw);
    return ST(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Ui(e, t) {
  return new Y5(e, t);
}
const Wm = (e) => Array.isArray(e);
function q5(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, Ui(n));
}
function W5(e) {
  return Wm(e) ? e[e.length - 1] || 0 : e;
}
function X5(e, t) {
  const n = Oi(e, t);
  let { transitionEnd: o = {}, transition: i = {}, ...l } = n || {};
  l = { ...l, ...o };
  for (const c in l) {
    const f = W5(l[c]);
    q5(e, c, f);
  }
}
const Ft = (e) => !!(e && e.getVelocity);
function K5(e) {
  return !!(Ft(e) && e.add);
}
function Xm(e, t) {
  const n = e.getValue("willChange");
  if (K5(n))
    return n.add(t);
  if (!n && Fr.WillChange) {
    const o = new Fr.WillChange("auto");
    e.addValue("willChange", o), o.add(t);
  }
}
function ov(e) {
  return e.replace(/([A-Z])/g, (t) => `-${t.toLowerCase()}`);
}
const J5 = "framerAppearId", eC = "data-" + ov(J5);
function tC(e) {
  return e.props[eC];
}
function Q5({ protectedKeys: e, needsAnimating: t }, n) {
  const o = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, o;
}
function nC(e, t, { delay: n = 0, transitionOverride: o, type: i } = {}) {
  let { transition: l = e.getDefaultTransition(), transitionEnd: c, ...f } = t;
  const d = l?.reduceMotion;
  o && (l = o);
  const h = [], m = i && e.animationState && e.animationState.getState()[i];
  for (const v in f) {
    const b = e.getValue(v, e.latestValues[v] ?? null), x = f[v];
    if (x === void 0 || m && Q5(m, v))
      continue;
    const E = {
      delay: n,
      ...tv(l || {}, v)
    }, w = b.get();
    if (w !== void 0 && !b.isAnimating && !Array.isArray(x) && x === w && !E.velocity)
      continue;
    let C = !1;
    if (window.MotionHandoffAnimation) {
      const T = tC(e);
      if (T) {
        const D = window.MotionHandoffAnimation(T, v, nt);
        D !== null && (E.startTime = D, C = !0);
      }
    }
    Xm(e, v);
    const A = d ?? e.shouldReduceMotion;
    b.start(nv(v, b, x, A && QT.has(v) ? { type: !1 } : E, e, C));
    const M = b.animation;
    M && h.push(M);
  }
  return c && Promise.all(h).then(() => {
    nt.update(() => {
      c && X5(e, c);
    });
  }), h;
}
function Km(e, t, n = {}) {
  const o = Oi(e, t, n.type === "exit" ? e.presenceContext?.custom : void 0);
  let { transition: i = e.getDefaultTransition() || {} } = o || {};
  n.transitionOverride && (i = n.transitionOverride);
  const l = o ? () => Promise.all(nC(e, o, n)) : () => Promise.resolve(), c = e.variantChildren && e.variantChildren.size ? (d = 0) => {
    const { delayChildren: h = 0, staggerChildren: m, staggerDirection: v } = i;
    return eV(e, t, d, h, m, v, n);
  } : () => Promise.resolve(), { when: f } = i;
  if (f) {
    const [d, h] = f === "beforeChildren" ? [l, c] : [c, l];
    return d().then(() => h());
  } else
    return Promise.all([l(), c(n.delay)]);
}
function eV(e, t, n = 0, o = 0, i = 0, l = 1, c) {
  const f = [];
  for (const d of e.variantChildren)
    d.notify("AnimationStart", t), f.push(Km(d, t, {
      ...c,
      delay: n + (typeof o == "function" ? 0 : o) + KT(e.variantChildren, d, o, i, l)
    }).then(() => d.notify("AnimationComplete", t)));
  return Promise.all(f);
}
function tV(e, t, n = {}) {
  e.notify("AnimationStart", t);
  let o;
  if (Array.isArray(t)) {
    const i = t.map((l) => Km(e, l, n));
    o = Promise.all(i);
  } else if (typeof t == "string")
    o = Km(e, t, n);
  else {
    const i = typeof t == "function" ? Oi(e, t, n.custom) : t;
    o = Promise.all(nC(e, i, n));
  }
  return o.then(() => {
    e.notify("AnimationComplete", t);
  });
}
const nV = {
  test: (e) => e === "auto",
  parse: (e) => e
}, rC = (e) => (t) => t.test(e), oC = [Gi, xe, hr, To, M3, R3, nV], Iw = (e) => oC.find(rC(e));
function rV(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || xT(e) : !0;
}
const oV = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function aV(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [o] = n.match(Yg) || [];
  if (!o)
    return e;
  const i = n.replace(o, "");
  let l = oV.has(t) ? 1 : 0;
  return o !== n && (l *= 100), t + "(" + l + i + ")";
}
const iV = /\b([a-z-]*)\(.*?\)/gu, Jm = {
  ...Po,
  getAnimatableNone: (e) => {
    const t = e.match(iV);
    return t ? t.map(aV).join(" ") : e;
  }
}, Vw = {
  ...Gi,
  transform: Math.round
}, sV = {
  rotate: To,
  rotateX: To,
  rotateY: To,
  rotateZ: To,
  scale: wu,
  scaleX: wu,
  scaleY: wu,
  scaleZ: wu,
  skew: To,
  skewX: To,
  skewY: To,
  distance: xe,
  translateX: xe,
  translateY: xe,
  translateZ: xe,
  x: xe,
  y: xe,
  z: xe,
  perspective: xe,
  transformPerspective: xe,
  opacity: _l,
  originX: Tw,
  originY: Tw,
  originZ: xe
}, av = {
  // Border props
  borderWidth: xe,
  borderTopWidth: xe,
  borderRightWidth: xe,
  borderBottomWidth: xe,
  borderLeftWidth: xe,
  borderRadius: xe,
  borderTopLeftRadius: xe,
  borderTopRightRadius: xe,
  borderBottomRightRadius: xe,
  borderBottomLeftRadius: xe,
  // Positioning props
  width: xe,
  maxWidth: xe,
  height: xe,
  maxHeight: xe,
  top: xe,
  right: xe,
  bottom: xe,
  left: xe,
  inset: xe,
  insetBlock: xe,
  insetBlockStart: xe,
  insetBlockEnd: xe,
  insetInline: xe,
  insetInlineStart: xe,
  insetInlineEnd: xe,
  // Spacing props
  padding: xe,
  paddingTop: xe,
  paddingRight: xe,
  paddingBottom: xe,
  paddingLeft: xe,
  paddingBlock: xe,
  paddingBlockStart: xe,
  paddingBlockEnd: xe,
  paddingInline: xe,
  paddingInlineStart: xe,
  paddingInlineEnd: xe,
  margin: xe,
  marginTop: xe,
  marginRight: xe,
  marginBottom: xe,
  marginLeft: xe,
  marginBlock: xe,
  marginBlockStart: xe,
  marginBlockEnd: xe,
  marginInline: xe,
  marginInlineStart: xe,
  marginInlineEnd: xe,
  // Typography
  fontSize: xe,
  // Misc
  backgroundPositionX: xe,
  backgroundPositionY: xe,
  ...sV,
  zIndex: Vw,
  // SVG
  fillOpacity: _l,
  strokeOpacity: _l,
  numOctaves: Vw
}, lV = {
  ...av,
  // Color props
  color: At,
  backgroundColor: At,
  outlineColor: At,
  fill: At,
  stroke: At,
  // Border props
  borderColor: At,
  borderTopColor: At,
  borderRightColor: At,
  borderBottomColor: At,
  borderLeftColor: At,
  filter: Jm,
  WebkitFilter: Jm
}, aC = (e) => lV[e];
function iC(e, t) {
  let n = aC(e);
  return n !== Jm && (n = Po), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const cV = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function uV(e, t, n) {
  let o = 0, i;
  for (; o < e.length && !i; ) {
    const l = e[o];
    typeof l == "string" && !cV.has(l) && Tl(l).values.length && (i = e[o]), o++;
  }
  if (i && n)
    for (const l of t)
      e[l] = iC(n, i);
}
class fV extends ev {
  constructor(t, n, o, i, l) {
    super(t, n, o, i, l, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: o } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let m = 0; m < t.length; m++) {
      let v = t[m];
      if (typeof v == "string" && (v = v.trim(), Gg(v))) {
        const b = JT(v, n.current);
        b !== void 0 && (t[m] = b), m === t.length - 1 && (this.finalKeyframe = v);
      }
    }
    if (this.resolveNoneKeyframes(), !QT.has(o) || t.length !== 2)
      return;
    const [i, l] = t, c = Iw(i), f = Iw(l), d = _w(i), h = _w(l);
    if (d !== h && Do[o]) {
      this.needsMeasurement = !0;
      return;
    }
    if (c !== f)
      if (Ow(c) && Ow(f))
        for (let m = 0; m < t.length; m++) {
          const v = t[m];
          typeof v == "string" && (t[m] = parseFloat(v));
        }
      else Do[o] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, o = [];
    for (let i = 0; i < t.length; i++)
      (t[i] === null || rV(t[i])) && o.push(i);
    o.length && uV(t, o, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: o } = this;
    if (!t || !t.current)
      return;
    o === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Do[o](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const i = n[n.length - 1];
    i !== void 0 && t.getValue(o, i).jump(i, !1);
  }
  measureEndState() {
    const { element: t, name: n, unresolvedKeyframes: o } = this;
    if (!t || !t.current)
      return;
    const i = t.getValue(n);
    i && i.jump(this.measuredOrigin, !1);
    const l = o.length - 1, c = o[l];
    o[l] = Do[n](t.measureViewportBox(), window.getComputedStyle(t.current)), c !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = c), this.removedTransforms?.length && this.removedTransforms.forEach(([f, d]) => {
      t.getValue(f).set(d);
    }), this.resolveNoneKeyframes();
  }
}
function dV(e, t, n) {
  if (e == null)
    return [];
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let o = document;
    const i = n?.[e] ?? o.querySelectorAll(e);
    return i ? Array.from(i) : [];
  }
  return Array.from(e).filter((o) => o != null);
}
const sC = (e, t) => t && typeof e == "number" ? t.transform(e) : e;
function Qm(e) {
  return bT(e) && "offsetHeight" in e;
}
const { schedule: iv } = /* @__PURE__ */ NT(queueMicrotask, !1), Xn = {
  x: !1,
  y: !1
};
function lC() {
  return Xn.x || Xn.y;
}
function hV(e) {
  return e === "x" || e === "y" ? Xn[e] ? null : (Xn[e] = !0, () => {
    Xn[e] = !1;
  }) : Xn.x || Xn.y ? null : (Xn.x = Xn.y = !0, () => {
    Xn.x = Xn.y = !1;
  });
}
function cC(e, t) {
  const n = dV(e), o = new AbortController(), i = {
    passive: !0,
    ...t,
    signal: o.signal
  };
  return [n, i, () => o.abort()];
}
function Uw(e) {
  return !(e.pointerType === "touch" || lC());
}
function pV(e, t, n = {}) {
  const [o, i, l] = cC(e, n), c = (f) => {
    if (!Uw(f))
      return;
    const { target: d } = f, h = t(d, f);
    if (typeof h != "function" || !d)
      return;
    const m = (v) => {
      Uw(v) && (h(v), d.removeEventListener("pointerleave", m));
    };
    d.addEventListener("pointerleave", m, i);
  };
  return o.forEach((f) => {
    f.addEventListener("pointerenter", c, i);
  }), l;
}
const uC = (e, t) => t ? e === t ? !0 : uC(e, t.parentElement) : !1, sv = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, mV = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function gV(e) {
  return mV.has(e.tagName) || e.isContentEditable === !0;
}
const vV = /* @__PURE__ */ new Set(["INPUT", "SELECT", "TEXTAREA"]);
function yV(e) {
  return vV.has(e.tagName) || e.isContentEditable === !0;
}
const Lu = /* @__PURE__ */ new WeakSet();
function Bw(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function Wp(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const bV = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const o = Bw(() => {
    if (Lu.has(n))
      return;
    Wp(n, "down");
    const i = Bw(() => {
      Wp(n, "up");
    }), l = () => Wp(n, "cancel");
    n.addEventListener("keyup", i, t), n.addEventListener("blur", l, t);
  });
  n.addEventListener("keydown", o, t), n.addEventListener("blur", () => n.removeEventListener("keydown", o), t);
};
function $w(e) {
  return sv(e) && !lC();
}
function xV(e, t, n = {}) {
  const [o, i, l] = cC(e, n), c = (f) => {
    const d = f.currentTarget;
    if (!$w(f))
      return;
    Lu.add(d);
    const h = t(d, f), m = (x, E) => {
      window.removeEventListener("pointerup", v), window.removeEventListener("pointercancel", b), Lu.has(d) && Lu.delete(d), $w(x) && typeof h == "function" && h(x, { success: E });
    }, v = (x) => {
      m(x, d === window || d === document || n.useGlobalTarget || uC(d, x.target));
    }, b = (x) => {
      m(x, !1);
    };
    window.addEventListener("pointerup", v, i), window.addEventListener("pointercancel", b, i);
  };
  return o.forEach((f) => {
    (n.useGlobalTarget ? window : f).addEventListener("pointerdown", c, i), Qm(f) && (f.addEventListener("focus", (h) => bV(h, i)), !gV(f) && !f.hasAttribute("tabindex") && (f.tabIndex = 0));
  }), l;
}
function fC(e) {
  return bT(e) && "ownerSVGElement" in e;
}
function SV(e) {
  return fC(e) && e.tagName === "svg";
}
const wV = [...oC, At, Po], EV = (e) => wV.find(rC(e)), Hw = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), Ri = () => ({
  x: Hw(),
  y: Hw()
}), Zw = () => ({ min: 0, max: 0 }), Dt = () => ({
  x: Zw(),
  y: Zw()
}), eg = { current: null }, dC = { current: !1 }, _V = typeof window < "u";
function TV() {
  if (dC.current = !0, !!_V)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => eg.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      eg.current = !1;
}
const CV = /* @__PURE__ */ new WeakMap();
function kf(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Cl(e) {
  return typeof e == "string" || Array.isArray(e);
}
const lv = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], cv = ["initial", ...lv];
function Pf(e) {
  return kf(e.animate) || cv.some((t) => Cl(e[t]));
}
function hC(e) {
  return !!(Pf(e) || e.variants);
}
function AV(e, t, n) {
  for (const o in t) {
    const i = t[o], l = n[o];
    if (Ft(i))
      e.addValue(o, i);
    else if (Ft(l))
      e.addValue(o, Ui(i, { owner: e }));
    else if (l !== i)
      if (e.hasValue(o)) {
        const c = e.getValue(o);
        c.liveStyle === !0 ? c.jump(i) : c.hasAnimated || c.set(i);
      } else {
        const c = e.getStaticValue(o);
        e.addValue(o, Ui(c !== void 0 ? c : i, { owner: e }));
      }
  }
  for (const o in n)
    t[o] === void 0 && e.removeValue(o);
  return t;
}
const Fw = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let rf = {};
function pC(e) {
  rf = e;
}
function RV() {
  return rf;
}
class MV {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, o) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: o, reducedMotionConfig: i, skipAnimations: l, blockInitialAnimation: c, visualState: f }, d = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = ev, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const x = Xt.now();
      this.renderScheduledAt < x && (this.renderScheduledAt = x, nt.render(this.render, !1, !0));
    };
    const { latestValues: h, renderState: m } = f;
    this.latestValues = h, this.baseTarget = { ...h }, this.initialValues = n.initial ? { ...h } : {}, this.renderState = m, this.parent = t, this.props = n, this.presenceContext = o, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.skipAnimationsConfig = l, this.options = d, this.blockInitialAnimation = !!c, this.isControllingVariants = Pf(n), this.isVariantNode = hC(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: v, ...b } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const x in b) {
      const E = b[x];
      h[x] !== void 0 && Ft(E) && E.set(h[x]);
    }
  }
  mount(t) {
    this.current = t, CV.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, o) => this.bindToMotionValue(o, n)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (dC.current || TV(), this.shouldReduceMotion = eg.current), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, this.parent?.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), ko(this.notifyUpdate), ko(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  addChild(t) {
    this.children.add(t), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(t);
  }
  removeChild(t) {
    this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t);
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const o = qi.has(t);
    o && this.onBindTransform && this.onBindTransform();
    const i = n.on("change", (c) => {
      this.latestValues[t] = c, this.props.onUpdate && nt.preRender(this.notifyUpdate), o && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let l;
    typeof window < "u" && window.MotionCheckAppearSync && (l = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      i(), l && l(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in rf) {
      const n = rf[t];
      if (!n)
        continue;
      const { isEnabled: o, Feature: i } = n;
      if (!this.features[t] && i && o(this.props) && (this.features[t] = new i(this)), this.features[t]) {
        const l = this.features[t];
        l.isMounted ? l.update() : (l.mount(), l.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Dt();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let o = 0; o < Fw.length; o++) {
      const i = Fw[o];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const l = "on" + i, c = t[l];
      c && (this.propEventSubscriptions[i] = this.on(i, c));
    }
    this.prevMotionValues = AV(this, this.scrapeMotionValuesFromProps(t, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const o = this.values.get(t);
    n !== o && (o && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let o = this.values.get(t);
    return o === void 0 && n !== void 0 && (o = Ui(n === null ? void 0 : n, { owner: this }), this.addValue(t, o)), o;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let o = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return o != null && (typeof o == "string" && (yT(o) || xT(o)) ? o = parseFloat(o) : !EV(o) && Po.test(n) && (o = iC(t, n)), this.setBaseTarget(t, Ft(o) ? o.get() : o)), Ft(o) ? o.get() : o;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    const { initial: n } = this.props;
    let o;
    if (typeof n == "string" || typeof n == "object") {
      const l = rv(this.props, n, this.presenceContext?.custom);
      l && (o = l[t]);
    }
    if (n && o !== void 0)
      return o;
    const i = this.getBaseTargetFromProps(this.props, t);
    return i !== void 0 && !Ft(i) ? i : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new Hg()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
  scheduleRenderMicrotask() {
    iv.render(this.render);
  }
}
class mC extends MV {
  constructor() {
    super(...arguments), this.KeyframeResolver = fV;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    const o = t.style;
    return o ? o[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: o }) {
    delete n[t], delete o[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    Ft(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class $o {
  constructor(t) {
    this.isMounted = !1, this.node = t;
  }
  update() {
  }
}
function gC({ top: e, left: t, right: n, bottom: o }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: o }
  };
}
function zV({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function DV(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), o = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: o.y,
    right: o.x
  };
}
function Xp(e) {
  return e === void 0 || e === 1;
}
function tg({ scale: e, scaleX: t, scaleY: n }) {
  return !Xp(e) || !Xp(t) || !Xp(n);
}
function pa(e) {
  return tg(e) || vC(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function vC(e) {
  return Gw(e.x) || Gw(e.y);
}
function Gw(e) {
  return e && e !== "0%";
}
function of(e, t, n) {
  const o = e - n, i = t * o;
  return n + i;
}
function Yw(e, t, n, o, i) {
  return i !== void 0 && (e = of(e, i, o)), of(e, n, o) + t;
}
function ng(e, t = 0, n = 1, o, i) {
  e.min = Yw(e.min, t, n, o, i), e.max = Yw(e.max, t, n, o, i);
}
function yC(e, { x: t, y: n }) {
  ng(e.x, t.translate, t.scale, t.originPoint), ng(e.y, n.translate, n.scale, n.originPoint);
}
const qw = 0.999999999999, Ww = 1.0000000000001;
function NV(e, t, n, o = !1) {
  const i = n.length;
  if (!i)
    return;
  t.x = t.y = 1;
  let l, c;
  for (let f = 0; f < i; f++) {
    l = n[f], c = l.projectionDelta;
    const { visualElement: d } = l.options;
    d && d.props.style && d.props.style.display === "contents" || (o && l.options.layoutScroll && l.scroll && l !== l.root && zi(e, {
      x: -l.scroll.offset.x,
      y: -l.scroll.offset.y
    }), c && (t.x *= c.x.scale, t.y *= c.y.scale, yC(e, c)), o && pa(l.latestValues) && zi(e, l.latestValues));
  }
  t.x < Ww && t.x > qw && (t.x = 1), t.y < Ww && t.y > qw && (t.y = 1);
}
function Mi(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function Xw(e, t, n, o, i = 0.5) {
  const l = ht(e.min, e.max, i);
  ng(e, t, n, l, o);
}
function zi(e, t) {
  Xw(e.x, t.x, t.scaleX, t.scale, t.originX), Xw(e.y, t.y, t.scaleY, t.scale, t.originY);
}
function bC(e, t) {
  return gC(DV(e.getBoundingClientRect(), t));
}
function OV(e, t, n) {
  const o = bC(e, n), { scroll: i } = t;
  return i && (Mi(o.x, i.offset.x), Mi(o.y, i.offset.y)), o;
}
const jV = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, kV = Yi.length;
function PV(e, t, n) {
  let o = "", i = !0;
  for (let l = 0; l < kV; l++) {
    const c = Yi[l], f = e[c];
    if (f === void 0)
      continue;
    let d = !0;
    if (typeof f == "number")
      d = f === (c.startsWith("scale") ? 1 : 0);
    else {
      const h = parseFloat(f);
      d = c.startsWith("scale") ? h === 1 : h === 0;
    }
    if (!d || n) {
      const h = sC(f, av[c]);
      if (!d) {
        i = !1;
        const m = jV[c] || c;
        o += `${m}(${h}) `;
      }
      n && (t[c] = h);
    }
  }
  return o = o.trim(), n ? o = n(t, i ? "" : o) : i && (o = "none"), o;
}
function uv(e, t, n) {
  const { style: o, vars: i, transformOrigin: l } = e;
  let c = !1, f = !1;
  for (const d in t) {
    const h = t[d];
    if (qi.has(d)) {
      c = !0;
      continue;
    } else if (jT(d)) {
      i[d] = h;
      continue;
    } else {
      const m = sC(h, av[d]);
      d.startsWith("origin") ? (f = !0, l[d] = m) : o[d] = m;
    }
  }
  if (t.transform || (c || n ? o.transform = PV(t, e.transform, n) : o.transform && (o.transform = "none")), f) {
    const { originX: d = "50%", originY: h = "50%", originZ: m = 0 } = l;
    o.transformOrigin = `${d} ${h} ${m}`;
  }
}
function xC(e, { style: t, vars: n }, o, i) {
  const l = e.style;
  let c;
  for (c in t)
    l[c] = t[c];
  i?.applyProjectionStyles(l, o);
  for (c in n)
    l.setProperty(c, n[c]);
}
function Kw(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const Js = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (xe.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = Kw(e, t.target.x), o = Kw(e, t.target.y);
    return `${n}% ${o}%`;
  }
}, LV = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const o = e, i = Po.parse(e);
    if (i.length > 5)
      return o;
    const l = Po.createTransformer(e), c = typeof i[0] != "number" ? 1 : 0, f = n.x.scale * t.x, d = n.y.scale * t.y;
    i[0 + c] /= f, i[1 + c] /= d;
    const h = ht(f, d, 0.5);
    return typeof i[2 + c] == "number" && (i[2 + c] /= h), typeof i[3 + c] == "number" && (i[3 + c] /= h), l(i);
  }
}, rg = {
  borderRadius: {
    ...Js,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Js,
  borderTopRightRadius: Js,
  borderBottomLeftRadius: Js,
  borderBottomRightRadius: Js,
  boxShadow: LV
};
function SC(e, { layout: t, layoutId: n }) {
  return qi.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!rg[e] || e === "opacity");
}
function fv(e, t, n) {
  const o = e.style, i = t?.style, l = {};
  if (!o)
    return l;
  for (const c in o)
    (Ft(o[c]) || i && Ft(i[c]) || SC(c, e) || n?.getValue(c)?.liveStyle !== void 0) && (l[c] = o[c]);
  return l;
}
function IV(e) {
  return window.getComputedStyle(e);
}
class VV extends mC {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = xC;
  }
  readValueFromInstance(t, n) {
    if (qi.has(n))
      return this.projection?.isProjecting ? Hm(n) : d5(t, n);
    {
      const o = IV(t), i = (jT(n) ? o.getPropertyValue(n) : o[n]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return bC(t, n);
  }
  build(t, n, o) {
    uv(t, n, o.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, o) {
    return fv(t, n, o);
  }
}
const UV = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, BV = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function $V(e, t, n = 1, o = 0, i = !0) {
  e.pathLength = 1;
  const l = i ? UV : BV;
  e[l.offset] = `${-o}`, e[l.array] = `${t} ${n}`;
}
const HV = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function wC(e, {
  attrX: t,
  attrY: n,
  attrScale: o,
  pathLength: i,
  pathSpacing: l = 1,
  pathOffset: c = 0,
  // This is object creation, which we try to avoid per-frame.
  ...f
}, d, h, m) {
  if (uv(e, f, h), d) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: v, style: b } = e;
  v.transform && (b.transform = v.transform, delete v.transform), (b.transform || v.transformOrigin) && (b.transformOrigin = v.transformOrigin ?? "50% 50%", delete v.transformOrigin), b.transform && (b.transformBox = m?.transformBox ?? "fill-box", delete v.transformBox);
  for (const x of HV)
    v[x] !== void 0 && (b[x] = v[x], delete v[x]);
  t !== void 0 && (v.x = t), n !== void 0 && (v.y = n), o !== void 0 && (v.scale = o), i !== void 0 && $V(v, i, l, c, !1);
}
const EC = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), _C = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function ZV(e, t, n, o) {
  xC(e, t, void 0, o);
  for (const i in t.attrs)
    e.setAttribute(EC.has(i) ? i : ov(i), t.attrs[i]);
}
function TC(e, t, n) {
  const o = fv(e, t, n);
  for (const i in e)
    if (Ft(e[i]) || Ft(t[i])) {
      const l = Yi.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      o[l] = e[i];
    }
  return o;
}
class FV extends mC {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Dt;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (qi.has(n)) {
      const o = aC(n);
      return o && o.default || 0;
    }
    return n = EC.has(n) ? n : ov(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, o) {
    return TC(t, n, o);
  }
  build(t, n, o) {
    wC(t, n, this.isSVGTag, o.transformTemplate, o.style);
  }
  renderInstance(t, n, o, i) {
    ZV(t, n, o, i);
  }
  mount(t) {
    this.isSVGTag = _C(t.tagName), super.mount(t);
  }
}
const GV = cv.length;
function CC(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const n = e.parent ? CC(e.parent) || {} : {};
    return e.props.initial !== void 0 && (n.initial = e.props.initial), n;
  }
  const t = {};
  for (let n = 0; n < GV; n++) {
    const o = cv[n], i = e.props[o];
    (Cl(i) || i === !1) && (t[o] = i);
  }
  return t;
}
function AC(e, t) {
  if (!Array.isArray(t))
    return !1;
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let o = 0; o < n; o++)
    if (t[o] !== e[o])
      return !1;
  return !0;
}
const YV = [...lv].reverse(), qV = lv.length;
function WV(e) {
  return (t) => Promise.all(t.map(({ animation: n, options: o }) => tV(e, n, o)));
}
function XV(e) {
  let t = WV(e), n = Jw(), o = !0;
  const i = (d) => (h, m) => {
    const v = Oi(e, m, d === "exit" ? e.presenceContext?.custom : void 0);
    if (v) {
      const { transition: b, transitionEnd: x, ...E } = v;
      h = { ...h, ...E, ...x };
    }
    return h;
  };
  function l(d) {
    t = d(e);
  }
  function c(d) {
    const { props: h } = e, m = CC(e.parent) || {}, v = [], b = /* @__PURE__ */ new Set();
    let x = {}, E = 1 / 0;
    for (let C = 0; C < qV; C++) {
      const A = YV[C], M = n[A], T = h[A] !== void 0 ? h[A] : m[A], D = Cl(T), O = A === d ? M.isActive : null;
      O === !1 && (E = C);
      let k = T === m[A] && T !== h[A] && D;
      if (k && o && e.manuallyAnimateOnMount && (k = !1), M.protectedKeys = { ...x }, // If it isn't active and hasn't *just* been set as inactive
      !M.isActive && O === null || // If we didn't and don't have any defined prop for this animation type
      !T && !M.prevProp || // Or if the prop doesn't define an animation
      kf(T) || typeof T == "boolean")
        continue;
      const R = KV(M.prevProp, T);
      let N = R || // If we're making this variant active, we want to always make it active
      A === d && M.isActive && !k && D || // If we removed a higher-priority variant (i is in reverse order)
      C > E && D, P = !1;
      const Y = Array.isArray(T) ? T : [T];
      let ne = Y.reduce(i(A), {});
      O === !1 && (ne = {});
      const { prevResolvedValues: J = {} } = M, ce = {
        ...J,
        ...ne
      }, ue = (G) => {
        N = !0, b.has(G) && (P = !0, b.delete(G)), M.needsAnimating[G] = !0;
        const U = e.getValue(G);
        U && (U.liveStyle = !1);
      };
      for (const G in ce) {
        const U = ne[G], te = J[G];
        if (x.hasOwnProperty(G))
          continue;
        let he = !1;
        Wm(U) && Wm(te) ? he = !AC(U, te) : he = U !== te, he ? U != null ? ue(G) : b.add(G) : U !== void 0 && b.has(G) ? ue(G) : M.protectedKeys[G] = !0;
      }
      M.prevProp = T, M.prevResolvedValues = ne, M.isActive && (x = { ...x, ...ne }), o && e.blockInitialAnimation && (N = !1);
      const de = k && R;
      N && (!de || P) && v.push(...Y.map((G) => {
        const U = { type: A };
        if (typeof G == "string" && o && !de && e.manuallyAnimateOnMount && e.parent) {
          const { parent: te } = e, he = Oi(te, G);
          if (te.enteringChildren && he) {
            const { delayChildren: j } = he.transition || {};
            U.delay = KT(te.enteringChildren, e, j);
          }
        }
        return {
          animation: G,
          options: U
        };
      }));
    }
    if (b.size) {
      const C = {};
      if (typeof h.initial != "boolean") {
        const A = Oi(e, Array.isArray(h.initial) ? h.initial[0] : h.initial);
        A && A.transition && (C.transition = A.transition);
      }
      b.forEach((A) => {
        const M = e.getBaseTarget(A), T = e.getValue(A);
        T && (T.liveStyle = !0), C[A] = M ?? null;
      }), v.push({ animation: C });
    }
    let w = !!v.length;
    return o && (h.initial === !1 || h.initial === h.animate) && !e.manuallyAnimateOnMount && (w = !1), o = !1, w ? t(v) : Promise.resolve();
  }
  function f(d, h) {
    if (n[d].isActive === h)
      return Promise.resolve();
    e.variantChildren?.forEach((v) => v.animationState?.setActive(d, h)), n[d].isActive = h;
    const m = c(d);
    for (const v in n)
      n[v].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: c,
    setActive: f,
    setAnimateFunction: l,
    getState: () => n,
    reset: () => {
      n = Jw();
    }
  };
}
function KV(e, t) {
  return typeof t == "string" ? t !== e : Array.isArray(t) ? !AC(t, e) : !1;
}
function ua(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function Jw() {
  return {
    animate: ua(!0),
    whileInView: ua(),
    whileHover: ua(),
    whileTap: ua(),
    whileDrag: ua(),
    whileFocus: ua(),
    exit: ua()
  };
}
function Qw(e, t) {
  e.min = t.min, e.max = t.max;
}
function Wn(e, t) {
  Qw(e.x, t.x), Qw(e.y, t.y);
}
function e1(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
const RC = 1e-4, JV = 1 - RC, QV = 1 + RC, MC = 0.01, eU = 0 - MC, tU = 0 + MC;
function Kt(e) {
  return e.max - e.min;
}
function nU(e, t, n) {
  return Math.abs(e - t) <= n;
}
function t1(e, t, n, o = 0.5) {
  e.origin = o, e.originPoint = ht(t.min, t.max, e.origin), e.scale = Kt(n) / Kt(t), e.translate = ht(n.min, n.max, e.origin) - e.originPoint, (e.scale >= JV && e.scale <= QV || isNaN(e.scale)) && (e.scale = 1), (e.translate >= eU && e.translate <= tU || isNaN(e.translate)) && (e.translate = 0);
}
function ml(e, t, n, o) {
  t1(e.x, t.x, n.x, o ? o.originX : void 0), t1(e.y, t.y, n.y, o ? o.originY : void 0);
}
function n1(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + Kt(t);
}
function rU(e, t, n) {
  n1(e.x, t.x, n.x), n1(e.y, t.y, n.y);
}
function r1(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + Kt(t);
}
function af(e, t, n) {
  r1(e.x, t.x, n.x), r1(e.y, t.y, n.y);
}
function o1(e, t, n, o, i) {
  return e -= t, e = of(e, 1 / n, o), i !== void 0 && (e = of(e, 1 / i, o)), e;
}
function oU(e, t = 0, n = 1, o = 0.5, i, l = e, c = e) {
  if (hr.test(t) && (t = parseFloat(t), t = ht(c.min, c.max, t / 100) - c.min), typeof t != "number")
    return;
  let f = ht(l.min, l.max, o);
  e === l && (f -= t), e.min = o1(e.min, t, n, f, i), e.max = o1(e.max, t, n, f, i);
}
function a1(e, t, [n, o, i], l, c) {
  oU(e, t[n], t[o], t[i], t.scale, l, c);
}
const aU = ["x", "scaleX", "originX"], iU = ["y", "scaleY", "originY"];
function i1(e, t, n, o) {
  a1(e.x, t, aU, n ? n.x : void 0, o ? o.x : void 0), a1(e.y, t, iU, n ? n.y : void 0, o ? o.y : void 0);
}
function s1(e) {
  return e.translate === 0 && e.scale === 1;
}
function zC(e) {
  return s1(e.x) && s1(e.y);
}
function l1(e, t) {
  return e.min === t.min && e.max === t.max;
}
function sU(e, t) {
  return l1(e.x, t.x) && l1(e.y, t.y);
}
function c1(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function DC(e, t) {
  return c1(e.x, t.x) && c1(e.y, t.y);
}
function u1(e) {
  return Kt(e.x) / Kt(e.y);
}
function f1(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
function Ln(e) {
  return [e("x"), e("y")];
}
function lU(e, t, n) {
  let o = "";
  const i = e.x.translate / t.x, l = e.y.translate / t.y, c = n?.z || 0;
  if ((i || l || c) && (o = `translate3d(${i}px, ${l}px, ${c}px) `), (t.x !== 1 || t.y !== 1) && (o += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: h, rotate: m, rotateX: v, rotateY: b, skewX: x, skewY: E } = n;
    h && (o = `perspective(${h}px) ${o}`), m && (o += `rotate(${m}deg) `), v && (o += `rotateX(${v}deg) `), b && (o += `rotateY(${b}deg) `), x && (o += `skewX(${x}deg) `), E && (o += `skewY(${E}deg) `);
  }
  const f = e.x.scale * t.x, d = e.y.scale * t.y;
  return (f !== 1 || d !== 1) && (o += `scale(${f}, ${d})`), o || "none";
}
const NC = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], cU = NC.length, d1 = (e) => typeof e == "string" ? parseFloat(e) : e, h1 = (e) => typeof e == "number" || xe.test(e);
function uU(e, t, n, o, i, l) {
  i ? (e.opacity = ht(0, n.opacity ?? 1, fU(o)), e.opacityExit = ht(t.opacity ?? 1, 0, dU(o))) : l && (e.opacity = ht(t.opacity ?? 1, n.opacity ?? 1, o));
  for (let c = 0; c < cU; c++) {
    const f = `border${NC[c]}Radius`;
    let d = p1(t, f), h = p1(n, f);
    if (d === void 0 && h === void 0)
      continue;
    d || (d = 0), h || (h = 0), d === 0 || h === 0 || h1(d) === h1(h) ? (e[f] = Math.max(ht(d1(d), d1(h), o), 0), (hr.test(h) || hr.test(d)) && (e[f] += "%")) : e[f] = h;
  }
  (t.rotate || n.rotate) && (e.rotate = ht(t.rotate || 0, n.rotate || 0, o));
}
function p1(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const fU = /* @__PURE__ */ OC(0, 0.5, RT), dU = /* @__PURE__ */ OC(0.5, 0.95, Vn);
function OC(e, t, n) {
  return (o) => o < e ? 0 : o > t ? 1 : n(/* @__PURE__ */ El(e, t, o));
}
function hU(e, t, n) {
  const o = Ft(e) ? e : Ui(e);
  return o.start(nv("", o, t, n)), o.animation;
}
function Al(e, t, n, o = { passive: !0 }) {
  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n);
}
const pU = (e, t) => e.depth - t.depth;
class mU {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    Vg(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    Ug(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(pU), this.isDirty = !1, this.children.forEach(t);
  }
}
function gU(e, t) {
  const n = Xt.now(), o = ({ timestamp: i }) => {
    const l = i - n;
    l >= t && (ko(o), e(l - t));
  };
  return nt.setup(o, !0), () => ko(o);
}
function Iu(e) {
  return Ft(e) ? e.get() : e;
}
class vU {
  constructor() {
    this.members = [];
  }
  add(t) {
    Vg(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (Ug(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((i) => t === i);
    if (n === 0)
      return !1;
    let o;
    for (let i = n; i >= 0; i--) {
      const l = this.members[i];
      if (l.isPresent !== !1) {
        o = l;
        break;
      }
    }
    return o ? (this.promote(o), !0) : !1;
  }
  promote(t, n) {
    const o = this.lead;
    if (t !== o && (this.prevLead = o, this.lead = t, t.show(), o)) {
      o.instance && o.scheduleRender(), t.scheduleRender();
      const i = o.options.layoutDependency, l = t.options.layoutDependency;
      i !== void 0 && l !== void 0 && i === l || (t.resumeFrom = o, n && (t.resumeFrom.preserveOpacity = !0), o.snapshot && (t.snapshot = o.snapshot, t.snapshot.latestValues = o.animationValues || o.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0));
      const { crossfade: f } = t.options;
      f === !1 && o.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: o } = t;
      n.onExitComplete && n.onExitComplete(), o && o.options.onExitComplete && o.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const Vu = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, Kp = ["", "X", "Y", "Z"], yU = 1e3;
let bU = 0;
function Jp(e, t, n, o) {
  const { latestValues: i } = t;
  i[e] && (n[e] = i[e], t.setStaticValue(e, 0), o && (o[e] = 0));
}
function jC(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = tC(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: i, layoutId: l } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", nt, !(i || l));
  }
  const { parent: o } = e;
  o && !o.hasCheckedOptimisedAppear && jC(o);
}
function kC({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: o, resetTransform: i }) {
  return class {
    constructor(c = {}, f = t?.()) {
      this.id = bU++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(wU), this.nodes.forEach(CU), this.nodes.forEach(AU), this.nodes.forEach(EU);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = c, this.root = f ? f.root || f : this, this.path = f ? [...f.path, f] : [], this.parent = f, this.depth = f ? f.depth + 1 : 0;
      for (let d = 0; d < this.path.length; d++)
        this.path[d].shouldResetTransform = !0;
      this.root === this && (this.nodes = new mU());
    }
    addEventListener(c, f) {
      return this.eventHandlers.has(c) || this.eventHandlers.set(c, new Hg()), this.eventHandlers.get(c).add(f);
    }
    notifyListeners(c, ...f) {
      const d = this.eventHandlers.get(c);
      d && d.notify(...f);
    }
    hasListeners(c) {
      return this.eventHandlers.has(c);
    }
    /**
     * Lifecycles
     */
    mount(c) {
      if (this.instance)
        return;
      this.isSVG = fC(c) && !SV(c), this.instance = c;
      const { layoutId: f, layout: d, visualElement: h } = this.options;
      if (h && !h.current && h.mount(c), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (d || f) && (this.isLayoutDirty = !0), e) {
        let m, v = 0;
        const b = () => this.root.updateBlockedByResize = !1;
        nt.read(() => {
          v = window.innerWidth;
        }), e(c, () => {
          const x = window.innerWidth;
          x !== v && (v = x, this.root.updateBlockedByResize = !0, m && m(), m = gU(b, 250), Vu.hasAnimatedSinceResize && (Vu.hasAnimatedSinceResize = !1, this.nodes.forEach(v1)));
        });
      }
      f && this.root.registerSharedNode(f, this), this.options.animate !== !1 && h && (f || d) && this.addEventListener("didUpdate", ({ delta: m, hasLayoutChanged: v, hasRelativeLayoutChanged: b, layout: x }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const E = this.options.transition || h.getDefaultTransition() || NU, { onLayoutAnimationStart: w, onLayoutAnimationComplete: C } = h.getProps(), A = !this.targetLayout || !DC(this.targetLayout, x), M = !v && b;
        if (this.options.layoutRoot || this.resumeFrom || M || v && (A || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const T = {
            ...tv(E, "layout"),
            onPlay: w,
            onComplete: C
          };
          (h.shouldReduceMotion || this.options.layoutRoot) && (T.delay = 0, T.type = !1), this.startAnimation(T), this.setAnimationOrigin(m, M);
        } else
          v || v1(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = x;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const c = this.getStack();
      c && c.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), ko(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(RU), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: c } = this.options;
      return c && c.getProps().transformTemplate;
    }
    willUpdate(c = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && jC(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let m = 0; m < this.path.length; m++) {
        const v = this.path[m];
        v.shouldResetTransform = !0, v.updateScroll("snapshot"), v.options.layoutRoot && v.willUpdate(!1);
      }
      const { layoutId: f, layout: d } = this.options;
      if (f === void 0 && !d)
        return;
      const h = this.getTransformTemplate();
      this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0, this.updateSnapshot(), c && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(m1);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(g1);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(TU), this.nodes.forEach(xU), this.nodes.forEach(SU)) : this.nodes.forEach(g1), this.clearAllSnapshots();
      const f = Xt.now();
      Bt.delta = gr(0, 1e3 / 60, f - Bt.timestamp), Bt.timestamp = f, Bt.isProcessing = !0, Hp.update.process(Bt), Hp.preRender.process(Bt), Hp.render.process(Bt), Bt.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, iv.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(_U), this.sharedNodes.forEach(MU);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, nt.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      nt.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Kt(this.snapshot.measuredBox.x) && !Kt(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let d = 0; d < this.path.length; d++)
          this.path[d].updateScroll();
      const c = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = Dt(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: f } = this.options;
      f && f.notify("LayoutMeasure", this.layout.layoutBox, c ? c.layoutBox : void 0);
    }
    updateScroll(c = "measure") {
      let f = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === c && (f = !1), f && this.instance) {
        const d = o(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: c,
          isRoot: d,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : d
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const c = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, f = this.projectionDelta && !zC(this.projectionDelta), d = this.getTransformTemplate(), h = d ? d(this.latestValues, "") : void 0, m = h !== this.prevTransformTemplateValue;
      c && this.instance && (f || pa(this.latestValues) || m) && (i(this.instance, h), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(c = !0) {
      const f = this.measurePageBox();
      let d = this.removeElementScroll(f);
      return c && (d = this.removeTransform(d)), OU(d), {
        animationId: this.root.animationId,
        measuredBox: f,
        layoutBox: d,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement: c } = this.options;
      if (!c)
        return Dt();
      const f = c.measureViewportBox();
      if (!(this.scroll?.wasRoot || this.path.some(jU))) {
        const { scroll: h } = this.root;
        h && (Mi(f.x, h.offset.x), Mi(f.y, h.offset.y));
      }
      return f;
    }
    removeElementScroll(c) {
      const f = Dt();
      if (Wn(f, c), this.scroll?.wasRoot)
        return f;
      for (let d = 0; d < this.path.length; d++) {
        const h = this.path[d], { scroll: m, options: v } = h;
        h !== this.root && m && v.layoutScroll && (m.wasRoot && Wn(f, c), Mi(f.x, m.offset.x), Mi(f.y, m.offset.y));
      }
      return f;
    }
    applyTransform(c, f = !1) {
      const d = Dt();
      Wn(d, c);
      for (let h = 0; h < this.path.length; h++) {
        const m = this.path[h];
        !f && m.options.layoutScroll && m.scroll && m !== m.root && zi(d, {
          x: -m.scroll.offset.x,
          y: -m.scroll.offset.y
        }), pa(m.latestValues) && zi(d, m.latestValues);
      }
      return pa(this.latestValues) && zi(d, this.latestValues), d;
    }
    removeTransform(c) {
      const f = Dt();
      Wn(f, c);
      for (let d = 0; d < this.path.length; d++) {
        const h = this.path[d];
        if (!h.instance || !pa(h.latestValues))
          continue;
        tg(h.latestValues) && h.updateSnapshot();
        const m = Dt(), v = h.measurePageBox();
        Wn(m, v), i1(f, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, m);
      }
      return pa(this.latestValues) && i1(f, this.latestValues), f;
    }
    setTargetDelta(c) {
      this.targetDelta = c, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(c) {
      this.options = {
        ...this.options,
        ...c,
        crossfade: c.crossfade !== void 0 ? c.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Bt.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(c = !1) {
      const f = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = f.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = f.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = f.isSharedProjectionDirty);
      const d = !!this.resumingFrom || this !== f;
      if (!(c || d && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: m, layoutId: v } = this.options;
      if (!this.layout || !(m || v))
        return;
      this.resolvedRelativeTargetAt = Bt.timestamp;
      const b = this.getClosestProjectingParent();
      b && this.linkedParentVersion !== b.layoutVersion && !b.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (b && b.layout ? this.createRelativeTarget(b, this.layout.layoutBox, b.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Dt(), this.targetWithTransforms = Dt()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), rU(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Wn(this.target, this.layout.layoutBox), yC(this.target, this.targetDelta)) : Wn(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, b && !!b.resumingFrom == !!this.resumingFrom && !b.options.layoutScroll && b.target && this.animationProgress !== 1 ? this.createRelativeTarget(b, this.target, b.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || tg(this.parent.latestValues) || vC(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(c, f, d) {
      this.relativeParent = c, this.linkedParentVersion = c.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Dt(), this.relativeTargetOrigin = Dt(), af(this.relativeTargetOrigin, f, d), Wn(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const c = this.getLead(), f = !!this.resumingFrom || this !== c;
      let d = !0;
      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (d = !1), f && (this.isSharedProjectionDirty || this.isTransformDirty) && (d = !1), this.resolvedRelativeTargetAt === Bt.timestamp && (d = !1), d)
        return;
      const { layout: h, layoutId: m } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || m))
        return;
      Wn(this.layoutCorrected, this.layout.layoutBox);
      const v = this.treeScale.x, b = this.treeScale.y;
      NV(this.layoutCorrected, this.treeScale, this.path, f), c.layout && !c.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (c.target = c.layout.layoutBox, c.targetWithTransforms = Dt());
      const { target: x } = c;
      if (!x) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (e1(this.prevProjectionDelta.x, this.projectionDelta.x), e1(this.prevProjectionDelta.y, this.projectionDelta.y)), ml(this.projectionDelta, this.layoutCorrected, x, this.latestValues), (this.treeScale.x !== v || this.treeScale.y !== b || !f1(this.projectionDelta.x, this.prevProjectionDelta.x) || !f1(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", x));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(c = !0) {
      if (this.options.visualElement?.scheduleRender(), c) {
        const f = this.getStack();
        f && f.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = Ri(), this.projectionDelta = Ri(), this.projectionDeltaWithTransform = Ri();
    }
    setAnimationOrigin(c, f = !1) {
      const d = this.snapshot, h = d ? d.latestValues : {}, m = { ...this.latestValues }, v = Ri();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !f;
      const b = Dt(), x = d ? d.source : void 0, E = this.layout ? this.layout.source : void 0, w = x !== E, C = this.getStack(), A = !C || C.members.length <= 1, M = !!(w && !A && this.options.crossfade === !0 && !this.path.some(DU));
      this.animationProgress = 0;
      let T;
      this.mixTargetDelta = (D) => {
        const O = D / 1e3;
        y1(v.x, c.x, O), y1(v.y, c.y, O), this.setTargetDelta(v), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (af(b, this.layout.layoutBox, this.relativeParent.layout.layoutBox), zU(this.relativeTarget, this.relativeTargetOrigin, b, O), T && sU(this.relativeTarget, T) && (this.isProjectionDirty = !1), T || (T = Dt()), Wn(T, this.relativeTarget)), w && (this.animationValues = m, uU(m, h, this.latestValues, O, M, A)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = O;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(c) {
      this.notifyListeners("animationStart"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (ko(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = nt.update(() => {
        Vu.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Ui(0)), this.currentAnimation = hU(this.motionValue, [0, 1e3], {
          ...c,
          velocity: 0,
          isSync: !0,
          onUpdate: (f) => {
            this.mixTargetDelta(f), c.onUpdate && c.onUpdate(f);
          },
          onStop: () => {
          },
          onComplete: () => {
            c.onComplete && c.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const c = this.getStack();
      c && c.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(yU), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const c = this.getLead();
      let { targetWithTransforms: f, target: d, layout: h, latestValues: m } = c;
      if (!(!f || !d || !h)) {
        if (this !== c && this.layout && h && PC(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
          d = this.target || Dt();
          const v = Kt(this.layout.layoutBox.x);
          d.x.min = c.target.x.min, d.x.max = d.x.min + v;
          const b = Kt(this.layout.layoutBox.y);
          d.y.min = c.target.y.min, d.y.max = d.y.min + b;
        }
        Wn(f, d), zi(f, m), ml(this.projectionDeltaWithTransform, this.layoutCorrected, f, m);
      }
    }
    registerSharedNode(c, f) {
      this.sharedNodes.has(c) || this.sharedNodes.set(c, new vU()), this.sharedNodes.get(c).add(f);
      const h = f.options.initialPromotionConfig;
      f.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(f) : void 0
      });
    }
    isLead() {
      const c = this.getStack();
      return c ? c.lead === this : !0;
    }
    getLead() {
      const { layoutId: c } = this.options;
      return c ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId: c } = this.options;
      return c ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId: c } = this.options;
      if (c)
        return this.root.sharedNodes.get(c);
    }
    promote({ needsReset: c, transition: f, preserveFollowOpacity: d } = {}) {
      const h = this.getStack();
      h && h.promote(this, d), c && (this.projectionDelta = void 0, this.needsReset = !0), f && this.setOptions({ transition: f });
    }
    relegate() {
      const c = this.getStack();
      return c ? c.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: c } = this.options;
      if (!c)
        return;
      let f = !1;
      const { latestValues: d } = c;
      if ((d.z || d.rotate || d.rotateX || d.rotateY || d.rotateZ || d.skewX || d.skewY) && (f = !0), !f)
        return;
      const h = {};
      d.z && Jp("z", c, h, this.animationValues);
      for (let m = 0; m < Kp.length; m++)
        Jp(`rotate${Kp[m]}`, c, h, this.animationValues), Jp(`skew${Kp[m]}`, c, h, this.animationValues);
      c.render();
      for (const m in h)
        c.setStaticValue(m, h[m]), this.animationValues && (this.animationValues[m] = h[m]);
      c.scheduleRender();
    }
    applyProjectionStyles(c, f) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        c.visibility = "hidden";
        return;
      }
      const d = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, c.visibility = "", c.opacity = "", c.pointerEvents = Iu(f?.pointerEvents) || "", c.transform = d ? d(this.latestValues, "") : "none";
        return;
      }
      const h = this.getLead();
      if (!this.projectionDelta || !this.layout || !h.target) {
        this.options.layoutId && (c.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, c.pointerEvents = Iu(f?.pointerEvents) || ""), this.hasProjected && !pa(this.latestValues) && (c.transform = d ? d({}, "") : "none", this.hasProjected = !1);
        return;
      }
      c.visibility = "";
      const m = h.animationValues || h.latestValues;
      this.applyTransformsToTarget();
      let v = lU(this.projectionDeltaWithTransform, this.treeScale, m);
      d && (v = d(m, v)), c.transform = v;
      const { x: b, y: x } = this.projectionDelta;
      c.transformOrigin = `${b.origin * 100}% ${x.origin * 100}% 0`, h.animationValues ? c.opacity = h === this ? m.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : m.opacityExit : c.opacity = h === this ? m.opacity !== void 0 ? m.opacity : "" : m.opacityExit !== void 0 ? m.opacityExit : 0;
      for (const E in rg) {
        if (m[E] === void 0)
          continue;
        const { correct: w, applyTo: C, isCSSVariable: A } = rg[E], M = v === "none" ? m[E] : w(m[E], h);
        if (C) {
          const T = C.length;
          for (let D = 0; D < T; D++)
            c[C[D]] = M;
        } else
          A ? this.options.visualElement.renderState.vars[E] = M : c[E] = M;
      }
      this.options.layoutId && (c.pointerEvents = h === this ? Iu(f?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((c) => c.currentAnimation?.stop()), this.root.nodes.forEach(m1), this.root.sharedNodes.clear();
    }
  };
}
function xU(e) {
  e.updateLayout();
}
function SU(e) {
  const t = e.resumeFrom?.snapshot || e.snapshot;
  if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: o } = e.layout, { animationType: i } = e.options, l = t.source !== e.layout.source;
    i === "size" ? Ln((m) => {
      const v = l ? t.measuredBox[m] : t.layoutBox[m], b = Kt(v);
      v.min = n[m].min, v.max = v.min + b;
    }) : PC(i, t.layoutBox, n) && Ln((m) => {
      const v = l ? t.measuredBox[m] : t.layoutBox[m], b = Kt(n[m]);
      v.max = v.min + b, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[m].max = e.relativeTarget[m].min + b);
    });
    const c = Ri();
    ml(c, n, t.layoutBox);
    const f = Ri();
    l ? ml(f, e.applyTransform(o, !0), t.measuredBox) : ml(f, n, t.layoutBox);
    const d = !zC(c);
    let h = !1;
    if (!e.resumeFrom) {
      const m = e.getClosestProjectingParent();
      if (m && !m.resumeFrom) {
        const { snapshot: v, layout: b } = m;
        if (v && b) {
          const x = Dt();
          af(x, t.layoutBox, v.layoutBox);
          const E = Dt();
          af(E, n, b.layoutBox), DC(x, E) || (h = !0), m.options.layoutRoot && (e.relativeTarget = E, e.relativeTargetOrigin = x, e.relativeParent = m);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: n,
      snapshot: t,
      delta: f,
      layoutDelta: c,
      hasLayoutChanged: d,
      hasRelativeLayoutChanged: h
    });
  } else if (e.isLead()) {
    const { onExitComplete: n } = e.options;
    n && n();
  }
  e.options.transition = void 0;
}
function wU(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function EU(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function _U(e) {
  e.clearSnapshot();
}
function m1(e) {
  e.clearMeasurements();
}
function g1(e) {
  e.isLayoutDirty = !1;
}
function TU(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function v1(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function CU(e) {
  e.resolveTargetDelta();
}
function AU(e) {
  e.calcProjection();
}
function RU(e) {
  e.resetSkewAndRotation();
}
function MU(e) {
  e.removeLeadSnapshot();
}
function y1(e, t, n) {
  e.translate = ht(t.translate, 0, n), e.scale = ht(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function b1(e, t, n, o) {
  e.min = ht(t.min, n.min, o), e.max = ht(t.max, n.max, o);
}
function zU(e, t, n, o) {
  b1(e.x, t.x, n.x, o), b1(e.y, t.y, n.y, o);
}
function DU(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const NU = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, x1 = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), S1 = x1("applewebkit/") && !x1("chrome/") ? Math.round : Vn;
function w1(e) {
  e.min = S1(e.min), e.max = S1(e.max);
}
function OU(e) {
  w1(e.x), w1(e.y);
}
function PC(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !nU(u1(t), u1(n), 0.2);
}
function jU(e) {
  return e !== e.root && e.scroll?.wasRoot;
}
const kU = kC({
  attachResizeListener: (e, t) => Al(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
    y: document.documentElement.scrollTop || document.body?.scrollTop || 0
  }),
  checkIsScrollRoot: () => !0
}), Qp = {
  current: void 0
}, LC = kC({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!Qp.current) {
      const e = new kU({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), Qp.current = e;
    }
    return Qp.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), dv = y.createContext({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
function E1(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function PU(...e) {
  return (t) => {
    let n = !1;
    const o = e.map((i) => {
      const l = E1(i, t);
      return !n && typeof l == "function" && (n = !0), l;
    });
    if (n)
      return () => {
        for (let i = 0; i < o.length; i++) {
          const l = o[i];
          typeof l == "function" ? l() : E1(e[i], null);
        }
      };
  };
}
function LU(...e) {
  return y.useCallback(PU(...e), e);
}
class IU extends y.Component {
  getSnapshotBeforeUpdate(t) {
    const n = this.props.childRef.current;
    if (n && t.isPresent && !this.props.isPresent) {
      const o = n.offsetParent, i = Qm(o) && o.offsetWidth || 0, l = Qm(o) && o.offsetHeight || 0, c = this.props.sizeRef.current;
      c.height = n.offsetHeight || 0, c.width = n.offsetWidth || 0, c.top = n.offsetTop, c.left = n.offsetLeft, c.right = i - c.width - c.left, c.bottom = l - c.height - c.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function VU({ children: e, isPresent: t, anchorX: n, anchorY: o, root: i }) {
  const l = y.useId(), c = y.useRef(null), f = y.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: d } = y.useContext(dv), h = e.props?.ref ?? e?.ref, m = LU(c, h);
  return y.useInsertionEffect(() => {
    const { width: v, height: b, top: x, left: E, right: w, bottom: C } = f.current;
    if (t || !c.current || !v || !b)
      return;
    const A = n === "left" ? `left: ${E}` : `right: ${w}`, M = o === "bottom" ? `bottom: ${C}` : `top: ${x}`;
    c.current.dataset.motionPopId = l;
    const T = document.createElement("style");
    d && (T.nonce = d);
    const D = i ?? document.head;
    return D.appendChild(T), T.sheet && T.sheet.insertRule(`
          [data-motion-pop-id="${l}"] {
            position: absolute !important;
            width: ${v}px !important;
            height: ${b}px !important;
            ${A}px !important;
            ${M}px !important;
          }
        `), () => {
      D.contains(T) && D.removeChild(T);
    };
  }, [t]), S.jsx(IU, { isPresent: t, childRef: c, sizeRef: f, children: y.cloneElement(e, { ref: m }) });
}
const UU = ({ children: e, initial: t, isPresent: n, onExitComplete: o, custom: i, presenceAffectsLayout: l, mode: c, anchorX: f, anchorY: d, root: h }) => {
  const m = Ig(BU), v = y.useId();
  let b = !0, x = y.useMemo(() => (b = !1, {
    id: v,
    initial: t,
    isPresent: n,
    custom: i,
    onExitComplete: (E) => {
      m.set(E, !0);
      for (const w of m.values())
        if (!w)
          return;
      o && o();
    },
    register: (E) => (m.set(E, !1), () => m.delete(E))
  }), [n, m, o]);
  return l && b && (x = { ...x }), y.useMemo(() => {
    m.forEach((E, w) => m.set(w, !1));
  }, [n]), y.useEffect(() => {
    !n && !m.size && o && o();
  }, [n]), c === "popLayout" && (e = S.jsx(VU, { isPresent: n, anchorX: f, anchorY: d, root: h, children: e })), S.jsx(jf.Provider, { value: x, children: e });
};
function BU() {
  return /* @__PURE__ */ new Map();
}
function IC(e = !0) {
  const t = y.useContext(jf);
  if (t === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: o, register: i } = t, l = y.useId();
  y.useEffect(() => {
    if (e)
      return i(l);
  }, [e]);
  const c = y.useCallback(() => e && o && o(l), [l, o, e]);
  return !n && o ? [!1, c] : [!0];
}
const Eu = (e) => e.key || "";
function _1(e) {
  const t = [];
  return y.Children.forEach(e, (n) => {
    y.isValidElement(n) && t.push(n);
  }), t;
}
const VC = ({ children: e, custom: t, initial: n = !0, onExitComplete: o, presenceAffectsLayout: i = !0, mode: l = "sync", propagate: c = !1, anchorX: f = "left", anchorY: d = "top", root: h }) => {
  const [m, v] = IC(c), b = y.useMemo(() => _1(e), [e]), x = c && !m ? [] : b.map(Eu), E = y.useRef(!0), w = y.useRef(b), C = Ig(() => /* @__PURE__ */ new Map()), A = y.useRef(/* @__PURE__ */ new Set()), [M, T] = y.useState(b), [D, O] = y.useState(b);
  vT(() => {
    E.current = !1, w.current = b;
    for (let N = 0; N < D.length; N++) {
      const P = Eu(D[N]);
      x.includes(P) ? (C.delete(P), A.current.delete(P)) : C.get(P) !== !0 && C.set(P, !1);
    }
  }, [D, x.length, x.join("-")]);
  const k = [];
  if (b !== M) {
    let N = [...b];
    for (let P = 0; P < D.length; P++) {
      const Y = D[P], ne = Eu(Y);
      x.includes(ne) || (N.splice(P, 0, Y), k.push(Y));
    }
    return l === "wait" && k.length && (N = k), O(_1(N)), T(b), null;
  }
  const { forceRender: R } = y.useContext(Lg);
  return S.jsx(S.Fragment, { children: D.map((N) => {
    const P = Eu(N), Y = c && !m ? !1 : b === D || x.includes(P), ne = () => {
      if (A.current.has(P))
        return;
      if (A.current.add(P), C.has(P))
        C.set(P, !0);
      else
        return;
      let J = !0;
      C.forEach((ce) => {
        ce || (J = !1);
      }), J && (R?.(), O(w.current), c && v?.(), o && o());
    };
    return S.jsx(UU, { isPresent: Y, initial: !E.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: i, mode: l, root: h, onExitComplete: Y ? void 0 : ne, anchorX: f, anchorY: d, children: N }, P);
  }) });
}, UC = y.createContext({ strict: !1 }), T1 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let C1 = !1;
function $U() {
  if (C1)
    return;
  const e = {};
  for (const t in T1)
    e[t] = {
      isEnabled: (n) => T1[t].some((o) => !!n[o])
    };
  pC(e), C1 = !0;
}
function BC() {
  return $U(), RV();
}
function HU(e) {
  const t = BC();
  for (const n in e)
    t[n] = {
      ...t[n],
      ...e[n]
    };
  pC(t);
}
const ZU = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function sf(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || ZU.has(e);
}
let $C = (e) => !sf(e);
function FU(e) {
  typeof e == "function" && ($C = (t) => t.startsWith("on") ? !sf(t) : e(t));
}
try {
  FU(require("@emotion/is-prop-valid").default);
} catch {
}
function GU(e, t, n) {
  const o = {};
  for (const i in e)
    i === "values" && typeof e.values == "object" || ($C(i) || n === !0 && sf(i) || !t && !sf(i) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && i.startsWith("onDrag")) && (o[i] = e[i]);
  return o;
}
const Lf = /* @__PURE__ */ y.createContext({});
function YU(e, t) {
  if (Pf(e)) {
    const { initial: n, animate: o } = e;
    return {
      initial: n === !1 || Cl(n) ? n : void 0,
      animate: Cl(o) ? o : void 0
    };
  }
  return e.inherit !== !1 ? t : {};
}
function qU(e) {
  const { initial: t, animate: n } = YU(e, y.useContext(Lf));
  return y.useMemo(() => ({ initial: t, animate: n }), [A1(t), A1(n)]);
}
function A1(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const hv = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function HC(e, t, n) {
  for (const o in t)
    !Ft(t[o]) && !SC(o, n) && (e[o] = t[o]);
}
function WU({ transformTemplate: e }, t) {
  return y.useMemo(() => {
    const n = hv();
    return uv(n, t, e), Object.assign({}, n.vars, n.style);
  }, [t]);
}
function XU(e, t) {
  const n = e.style || {}, o = {};
  return HC(o, n, e), Object.assign(o, WU(e, t)), o;
}
function KU(e, t) {
  const n = {}, o = XU(e, t);
  return e.drag && e.dragListener !== !1 && (n.draggable = !1, o.userSelect = o.WebkitUserSelect = o.WebkitTouchCallout = "none", o.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = o, n;
}
const ZC = () => ({
  ...hv(),
  attrs: {}
});
function JU(e, t, n, o) {
  const i = y.useMemo(() => {
    const l = ZC();
    return wC(l, t, _C(o), e.transformTemplate, e.style), {
      ...l.attrs,
      style: { ...l.style }
    };
  }, [t]);
  if (e.style) {
    const l = {};
    HC(l, e.style, e), i.style = { ...l, ...i.style };
  }
  return i;
}
const QU = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function pv(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(QU.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
function eB(e, t, n, { latestValues: o }, i, l = !1, c) {
  const d = (c ?? pv(e) ? JU : KU)(t, o, i, e), h = GU(t, typeof e == "string", l), m = e !== y.Fragment ? { ...h, ...d, ref: n } : {}, { children: v } = t, b = y.useMemo(() => Ft(v) ? v.get() : v, [v]);
  return y.createElement(e, {
    ...m,
    children: b
  });
}
function tB({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, o, i) {
  return {
    latestValues: nB(n, o, i, e),
    renderState: t()
  };
}
function nB(e, t, n, o) {
  const i = {}, l = o(e, {});
  for (const b in l)
    i[b] = Iu(l[b]);
  let { initial: c, animate: f } = e;
  const d = Pf(e), h = hC(e);
  t && h && !d && e.inherit !== !1 && (c === void 0 && (c = t.initial), f === void 0 && (f = t.animate));
  let m = n ? n.initial === !1 : !1;
  m = m || c === !1;
  const v = m ? f : c;
  if (v && typeof v != "boolean" && !kf(v)) {
    const b = Array.isArray(v) ? v : [v];
    for (let x = 0; x < b.length; x++) {
      const E = rv(e, b[x]);
      if (E) {
        const { transitionEnd: w, transition: C, ...A } = E;
        for (const M in A) {
          let T = A[M];
          if (Array.isArray(T)) {
            const D = m ? T.length - 1 : 0;
            T = T[D];
          }
          T !== null && (i[M] = T);
        }
        for (const M in w)
          i[M] = w[M];
      }
    }
  }
  return i;
}
const FC = (e) => (t, n) => {
  const o = y.useContext(Lf), i = y.useContext(jf), l = () => tB(e, t, o, i);
  return n ? l() : Ig(l);
}, rB = /* @__PURE__ */ FC({
  scrapeMotionValuesFromProps: fv,
  createRenderState: hv
}), oB = /* @__PURE__ */ FC({
  scrapeMotionValuesFromProps: TC,
  createRenderState: ZC
}), aB = /* @__PURE__ */ Symbol.for("motionComponentSymbol");
function iB(e, t, n) {
  const o = y.useRef(n);
  y.useInsertionEffect(() => {
    o.current = n;
  });
  const i = y.useRef(null);
  return y.useCallback((l) => {
    l && e.onMount?.(l), t && (l ? t.mount(l) : t.unmount());
    const c = o.current;
    if (typeof c == "function")
      if (l) {
        const f = c(l);
        typeof f == "function" && (i.current = f);
      } else i.current ? (i.current(), i.current = null) : c(l);
    else c && (c.current = l);
  }, [t]);
}
const GC = y.createContext({});
function al(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function sB(e, t, n, o, i, l) {
  const { visualElement: c } = y.useContext(Lf), f = y.useContext(UC), d = y.useContext(jf), h = y.useContext(dv), m = h.reducedMotion, v = h.skipAnimations, b = y.useRef(null), x = y.useRef(!1);
  o = o || f.renderer, !b.current && o && (b.current = o(e, {
    visualState: t,
    parent: c,
    props: n,
    presenceContext: d,
    blockInitialAnimation: d ? d.initial === !1 : !1,
    reducedMotionConfig: m,
    skipAnimations: v,
    isSVG: l
  }), x.current && b.current && (b.current.manuallyAnimateOnMount = !0));
  const E = b.current, w = y.useContext(GC);
  E && !E.projection && i && (E.type === "html" || E.type === "svg") && lB(b.current, n, i, w);
  const C = y.useRef(!1);
  y.useInsertionEffect(() => {
    E && C.current && E.update(n, d);
  });
  const A = n[eC], M = y.useRef(!!A && !window.MotionHandoffIsComplete?.(A) && window.MotionHasOptimisedAnimation?.(A));
  return vT(() => {
    x.current = !0, E && (C.current = !0, window.MotionIsMounted = !0, E.updateFeatures(), E.scheduleRenderMicrotask(), M.current && E.animationState && E.animationState.animateChanges());
  }), y.useEffect(() => {
    E && (!M.current && E.animationState && E.animationState.animateChanges(), M.current && (queueMicrotask(() => {
      window.MotionHandoffMarkAsComplete?.(A);
    }), M.current = !1), E.enteringChildren = void 0);
  }), E;
}
function lB(e, t, n, o) {
  const { layoutId: i, layout: l, drag: c, dragConstraints: f, layoutScroll: d, layoutRoot: h, layoutCrossfade: m } = t;
  e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : YC(e.parent)), e.projection.setOptions({
    layoutId: i,
    layout: l,
    alwaysMeasureLayout: !!c || f && al(f),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof l == "string" ? l : "both",
    initialPromotionConfig: o,
    crossfade: m,
    layoutScroll: d,
    layoutRoot: h
  });
}
function YC(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : YC(e.parent);
}
function em(e, { forwardMotionProps: t = !1, type: n } = {}, o, i) {
  o && HU(o);
  const l = n ? n === "svg" : pv(e), c = l ? oB : rB;
  function f(h, m) {
    let v;
    const b = {
      ...y.useContext(dv),
      ...h,
      layoutId: cB(h)
    }, { isStatic: x } = b, E = qU(h), w = c(h, x);
    if (!x && gT) {
      uB();
      const C = fB(b);
      v = C.MeasureLayout, E.visualElement = sB(e, w, b, i, C.ProjectionNode, l);
    }
    return S.jsxs(Lf.Provider, { value: E, children: [v && E.visualElement ? S.jsx(v, { visualElement: E.visualElement, ...b }) : null, eB(e, h, iB(w, E.visualElement, m), w, x, t, l)] });
  }
  f.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`;
  const d = y.forwardRef(f);
  return d[aB] = e, d;
}
function cB({ layoutId: e }) {
  const t = y.useContext(Lg).id;
  return t && e !== void 0 ? t + "-" + e : e;
}
function uB(e, t) {
  y.useContext(UC).strict;
}
function fB(e) {
  const t = BC(), { drag: n, layout: o } = t;
  if (!n && !o)
    return {};
  const i = { ...n, ...o };
  return {
    MeasureLayout: n?.isEnabled(e) || o?.isEnabled(e) ? i.MeasureLayout : void 0,
    ProjectionNode: i.ProjectionNode
  };
}
function dB(e, t) {
  if (typeof Proxy > "u")
    return em;
  const n = /* @__PURE__ */ new Map(), o = (l, c) => em(l, c, e, t), i = (l, c) => o(l, c);
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (l, c) => c === "create" ? o : (n.has(c) || n.set(c, em(c, void 0, e, t)), n.get(c))
  });
}
const hB = (e, t) => t.isSVG ?? pv(e) ? new FV(t) : new VV(t, {
  allowProjection: e !== y.Fragment
});
class pB extends $o {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(t) {
    super(t), t.animationState || (t.animationState = XV(t));
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.node.getProps();
    kf(t) && (this.unmountControls = t.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    this.node.animationState.reset(), this.unmountControls?.();
  }
}
let mB = 0;
class gB extends $o {
  constructor() {
    super(...arguments), this.id = mB++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: o } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || t === o)
      return;
    const i = this.node.animationState.setActive("exit", !t);
    n && !t && i.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: t, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), t && (this.unmount = t(this.id));
  }
  unmount() {
  }
}
const vB = {
  animation: {
    Feature: pB
  },
  exit: {
    Feature: gB
  }
};
function Bl(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const yB = (e) => (t) => sv(t) && e(t, Bl(t));
function gl(e, t, n, o) {
  return Al(e, t, yB(n), o);
}
const qC = ({ current: e }) => e ? e.ownerDocument.defaultView : null, R1 = (e, t) => Math.abs(e - t);
function bB(e, t) {
  const n = R1(e.x, t.x), o = R1(e.y, t.y);
  return Math.sqrt(n ** 2 + o ** 2);
}
const M1 = /* @__PURE__ */ new Set(["auto", "scroll"]);
class WC {
  constructor(t, n, { transformPagePoint: o, contextWindow: i = window, dragSnapToOrigin: l = !1, distanceThreshold: c = 3, element: f } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = /* @__PURE__ */ new Map(), this.removeScrollListeners = null, this.onElementScroll = (x) => {
      this.handleScroll(x.target);
    }, this.onWindowScroll = () => {
      this.handleScroll(window);
    }, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const x = nm(this.lastMoveEventInfo, this.history), E = this.startEvent !== null, w = bB(x.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!E && !w)
        return;
      const { point: C } = x, { timestamp: A } = Bt;
      this.history.push({ ...C, timestamp: A });
      const { onStart: M, onMove: T } = this.handlers;
      E || (M && M(this.lastMoveEvent, x), this.startEvent = this.lastMoveEvent), T && T(this.lastMoveEvent, x);
    }, this.handlePointerMove = (x, E) => {
      this.lastMoveEvent = x, this.lastMoveEventInfo = tm(E, this.transformPagePoint), nt.update(this.updatePoint, !0);
    }, this.handlePointerUp = (x, E) => {
      this.end();
      const { onEnd: w, onSessionEnd: C, resumeAnimation: A } = this.handlers;
      if ((this.dragSnapToOrigin || !this.startEvent) && A && A(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const M = nm(x.type === "pointercancel" ? this.lastMoveEventInfo : tm(E, this.transformPagePoint), this.history);
      this.startEvent && w && w(x, M), C && C(x, M);
    }, !sv(t))
      return;
    this.dragSnapToOrigin = l, this.handlers = n, this.transformPagePoint = o, this.distanceThreshold = c, this.contextWindow = i || window;
    const d = Bl(t), h = tm(d, this.transformPagePoint), { point: m } = h, { timestamp: v } = Bt;
    this.history = [{ ...m, timestamp: v }];
    const { onSessionStart: b } = n;
    b && b(t, nm(h, this.history)), this.removeListeners = Il(gl(this.contextWindow, "pointermove", this.handlePointerMove), gl(this.contextWindow, "pointerup", this.handlePointerUp), gl(this.contextWindow, "pointercancel", this.handlePointerUp)), f && this.startScrollTracking(f);
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(t) {
    let n = t.parentElement;
    for (; n; ) {
      const o = getComputedStyle(n);
      (M1.has(o.overflowX) || M1.has(o.overflowY)) && this.scrollPositions.set(n, {
        x: n.scrollLeft,
        y: n.scrollTop
      }), n = n.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    }), window.addEventListener("scroll", this.onElementScroll, {
      capture: !0,
      passive: !0
    }), window.addEventListener("scroll", this.onWindowScroll, {
      passive: !0
    }), this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: !0
      }), window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(t) {
    const n = this.scrollPositions.get(t);
    if (!n)
      return;
    const o = t === window, i = o ? { x: window.scrollX, y: window.scrollY } : {
      x: t.scrollLeft,
      y: t.scrollTop
    }, l = { x: i.x - n.x, y: i.y - n.y };
    l.x === 0 && l.y === 0 || (o ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += l.x, this.lastMoveEventInfo.point.y += l.y) : this.history.length > 0 && (this.history[0].x -= l.x, this.history[0].y -= l.y), this.scrollPositions.set(t, i), nt.update(this.updatePoint, !0));
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), ko(this.updatePoint);
  }
}
function tm(e, t) {
  return t ? { point: t(e.point) } : e;
}
function z1(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function nm({ point: e }, t) {
  return {
    point: e,
    delta: z1(e, XC(t)),
    offset: z1(e, xB(t)),
    velocity: SB(t, 0.1)
  };
}
function xB(e) {
  return e[0];
}
function XC(e) {
  return e[e.length - 1];
}
function SB(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, o = null;
  const i = XC(e);
  for (; n >= 0 && (o = e[n], !(i.timestamp - o.timestamp > /* @__PURE__ */ Zr(t))); )
    n--;
  if (!o)
    return { x: 0, y: 0 };
  const l = /* @__PURE__ */ In(i.timestamp - o.timestamp);
  if (l === 0)
    return { x: 0, y: 0 };
  const c = {
    x: (i.x - o.x) / l,
    y: (i.y - o.y) / l
  };
  return c.x === 1 / 0 && (c.x = 0), c.y === 1 / 0 && (c.y = 0), c;
}
function wB(e, { min: t, max: n }, o) {
  return t !== void 0 && e < t ? e = o ? ht(t, e, o.min) : Math.max(e, t) : n !== void 0 && e > n && (e = o ? ht(n, e, o.max) : Math.min(e, n)), e;
}
function D1(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function EB(e, { top: t, left: n, bottom: o, right: i }) {
  return {
    x: D1(e.x, n, i),
    y: D1(e.y, t, o)
  };
}
function N1(e, t) {
  let n = t.min - e.min, o = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, o] = [o, n]), { min: n, max: o };
}
function _B(e, t) {
  return {
    x: N1(e.x, t.x),
    y: N1(e.y, t.y)
  };
}
function TB(e, t) {
  let n = 0.5;
  const o = Kt(e), i = Kt(t);
  return i > o ? n = /* @__PURE__ */ El(t.min, t.max - o, e.min) : o > i && (n = /* @__PURE__ */ El(e.min, e.max - i, t.min)), gr(0, 1, n);
}
function CB(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
const og = 0.35;
function AB(e = og) {
  return e === !1 ? e = 0 : e === !0 && (e = og), {
    x: O1(e, "left", "right"),
    y: O1(e, "top", "bottom")
  };
}
function O1(e, t, n) {
  return {
    min: j1(e, t),
    max: j1(e, n)
  };
}
function j1(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
const RB = /* @__PURE__ */ new WeakMap();
class MB {
  constructor(t) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Dt(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1, distanceThreshold: o } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1)
      return;
    const l = (v) => {
      n ? (this.stopAnimation(), this.snapToCursor(Bl(v).point)) : this.pauseAnimation();
    }, c = (v, b) => {
      this.stopAnimation();
      const { drag: x, dragPropagation: E, onDragStart: w } = this.getProps();
      if (x && !E && (this.openDragLock && this.openDragLock(), this.openDragLock = hV(x), !this.openDragLock))
        return;
      this.latestPointerEvent = v, this.latestPanInfo = b, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Ln((A) => {
        let M = this.getAxisMotionValue(A).get() || 0;
        if (hr.test(M)) {
          const { projection: T } = this.visualElement;
          if (T && T.layout) {
            const D = T.layout.layoutBox[A];
            D && (M = Kt(D) * (parseFloat(M) / 100));
          }
        }
        this.originPoint[A] = M;
      }), w && nt.update(() => w(v, b), !1, !0), Xm(this.visualElement, "transform");
      const { animationState: C } = this.visualElement;
      C && C.setActive("whileDrag", !0);
    }, f = (v, b) => {
      this.latestPointerEvent = v, this.latestPanInfo = b;
      const { dragPropagation: x, dragDirectionLock: E, onDirectionLock: w, onDrag: C } = this.getProps();
      if (!x && !this.openDragLock)
        return;
      const { offset: A } = b;
      if (E && this.currentDirection === null) {
        this.currentDirection = zB(A), this.currentDirection !== null && w && w(this.currentDirection);
        return;
      }
      this.updateAxis("x", b.point, A), this.updateAxis("y", b.point, A), this.visualElement.render(), C && nt.update(() => C(v, b), !1, !0);
    }, d = (v, b) => {
      this.latestPointerEvent = v, this.latestPanInfo = b, this.stop(v, b), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, h = () => Ln((v) => this.getAnimationState(v) === "paused" && this.getAxisMotionValue(v).animation?.play()), { dragSnapToOrigin: m } = this.getProps();
    this.panSession = new WC(t, {
      onSessionStart: l,
      onStart: c,
      onMove: f,
      onSessionEnd: d,
      resumeAnimation: h
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: m,
      distanceThreshold: o,
      contextWindow: qC(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(t, n) {
    const o = t || this.latestPointerEvent, i = n || this.latestPanInfo, l = this.isDragging;
    if (this.cancel(), !l || !i || !o)
      return;
    const { velocity: c } = i;
    this.startAnimation(c);
    const { onDragEnd: f } = this.getProps();
    f && nt.postRender(() => f(o, i));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.endPanSession();
    const { dragPropagation: o } = this.getProps();
    !o && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end(), this.panSession = void 0;
  }
  updateAxis(t, n, o) {
    const { drag: i } = this.getProps();
    if (!o || !_u(t, i, this.currentDirection))
      return;
    const l = this.getAxisMotionValue(t);
    let c = this.originPoint[t] + o[t];
    this.constraints && this.constraints[t] && (c = wB(c, this.constraints[t], this.elastic[t])), l.set(c);
  }
  resolveConstraints() {
    const { dragConstraints: t, dragElastic: n } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints;
    t && al(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && o ? this.constraints = EB(o.layoutBox, t) : this.constraints = !1, this.elastic = AB(n), i !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && Ln((l) => {
      this.constraints !== !1 && this.getAxisMotionValue(l) && (this.constraints[l] = CB(o.layoutBox[l], this.constraints[l]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !al(t))
      return !1;
    const o = t.current, { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const l = OV(o, i.root, this.visualElement.getTransformPagePoint());
    let c = _B(i.layout.layoutBox, l);
    if (n) {
      const f = n(zV(c));
      this.hasMutatedConstraints = !!f, f && (c = gC(f));
    }
    return c;
  }
  startAnimation(t) {
    const { drag: n, dragMomentum: o, dragElastic: i, dragTransition: l, dragSnapToOrigin: c, onDragTransitionEnd: f } = this.getProps(), d = this.constraints || {}, h = Ln((m) => {
      if (!_u(m, n, this.currentDirection))
        return;
      let v = d && d[m] || {};
      c && (v = { min: 0, max: 0 });
      const b = i ? 200 : 1e6, x = i ? 40 : 1e7, E = {
        type: "inertia",
        velocity: o ? t[m] : 0,
        bounceStiffness: b,
        bounceDamping: x,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...l,
        ...v
      };
      return this.startAxisValueAnimation(m, E);
    });
    return Promise.all(h).then(f);
  }
  startAxisValueAnimation(t, n) {
    const o = this.getAxisMotionValue(t);
    return Xm(this.visualElement, t), o.start(nv(t, o, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    Ln((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    Ln((t) => this.getAxisMotionValue(t).animation?.pause());
  }
  getAnimationState(t) {
    return this.getAxisMotionValue(t).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, o = this.visualElement.getProps(), i = o[n];
    return i || this.visualElement.getValue(t, (o.initial ? o.initial[t] : void 0) || 0);
  }
  snapToCursor(t) {
    Ln((n) => {
      const { drag: o } = this.getProps();
      if (!_u(n, o, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, l = this.getAxisMotionValue(n);
      if (i && i.layout) {
        const { min: c, max: f } = i.layout.layoutBox[n], d = l.get() || 0;
        l.set(t[n] - ht(c, f, 0.5) + d);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: o } = this.visualElement;
    if (!al(n) || !o || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Ln((c) => {
      const f = this.getAxisMotionValue(c);
      if (f && this.constraints !== !1) {
        const d = f.get();
        i[c] = TB({ min: d, max: d }, this.constraints[c]);
      }
    });
    const { transformTemplate: l } = this.visualElement.getProps();
    this.visualElement.current.style.transform = l ? l({}, "") : "none", o.root && o.root.updateScroll(), o.updateLayout(), this.resolveConstraints(), Ln((c) => {
      if (!_u(c, t, null))
        return;
      const f = this.getAxisMotionValue(c), { min: d, max: h } = this.constraints[c];
      f.set(ht(d, h, i[c]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    RB.set(this.visualElement, this);
    const t = this.visualElement.current, n = gl(t, "pointerdown", (d) => {
      const { drag: h, dragListener: m = !0 } = this.getProps(), v = d.target, b = v !== t && yV(v);
      h && m && !b && this.start(d);
    }), o = () => {
      const { dragConstraints: d } = this.getProps();
      al(d) && d.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, l = i.addEventListener("measure", o);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), nt.read(o);
    const c = Al(window, "resize", () => this.scalePositionWithinConstraints()), f = i.addEventListener("didUpdate", (({ delta: d, hasLayoutChanged: h }) => {
      this.isDragging && h && (Ln((m) => {
        const v = this.getAxisMotionValue(m);
        v && (this.originPoint[m] += d[m].translate, v.set(v.get() + d[m].translate));
      }), this.visualElement.render());
    }));
    return () => {
      c(), n(), l(), f && f();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: o = !1, dragPropagation: i = !1, dragConstraints: l = !1, dragElastic: c = og, dragMomentum: f = !0 } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: o,
      dragPropagation: i,
      dragConstraints: l,
      dragElastic: c,
      dragMomentum: f
    };
  }
}
function _u(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function zB(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class DB extends $o {
  constructor(t) {
    super(t), this.removeGroupControls = Vn, this.removeListeners = Vn, this.controls = new MB(t);
  }
  mount() {
    const { dragControls: t } = this.node.getProps();
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Vn;
  }
  update() {
    const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {};
    t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls)));
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession();
  }
}
const rm = (e) => (t, n) => {
  e && nt.update(() => e(t, n), !1, !0);
};
class NB extends $o {
  constructor() {
    super(...arguments), this.removePointerDownListener = Vn;
  }
  onPointerDown(t) {
    this.session = new WC(t, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: qC(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: t, onPanStart: n, onPan: o, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: rm(t),
      onStart: rm(n),
      onMove: rm(o),
      onEnd: (l, c) => {
        delete this.session, i && nt.postRender(() => i(l, c));
      }
    };
  }
  mount() {
    this.removePointerDownListener = gl(this.node.current, "pointerdown", (t) => this.onPointerDown(t));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
let om = !1;
class OB extends y.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: o, layoutId: i } = this.props, { projection: l } = t;
    l && (n.group && n.group.add(l), o && o.register && i && o.register(l), om && l.root.didUpdate(), l.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), l.setOptions({
      ...l.options,
      layoutDependency: this.props.layoutDependency,
      onExitComplete: () => this.safeToRemove()
    })), Vu.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(t) {
    const { layoutDependency: n, visualElement: o, drag: i, isPresent: l } = this.props, { projection: c } = o;
    return c && (c.isPresent = l, t.layoutDependency !== n && c.setOptions({
      ...c.options,
      layoutDependency: n
    }), om = !0, i || t.layoutDependency !== n || n === void 0 || t.isPresent !== l ? c.willUpdate() : this.safeToRemove(), t.isPresent !== l && (l ? c.promote() : c.relegate() || nt.postRender(() => {
      const f = c.getStack();
      (!f || !f.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: t } = this.props.visualElement;
    t && (t.root.didUpdate(), iv.postRender(() => {
      !t.currentAnimation && t.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: t, layoutGroup: n, switchLayoutGroup: o } = this.props, { projection: i } = t;
    om = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), o && o.deregister && o.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: t } = this.props;
    t && t();
  }
  render() {
    return null;
  }
}
function KC(e) {
  const [t, n] = IC(), o = y.useContext(Lg);
  return S.jsx(OB, { ...e, layoutGroup: o, switchLayoutGroup: y.useContext(GC), isPresent: t, safeToRemove: n });
}
const jB = {
  pan: {
    Feature: NB
  },
  drag: {
    Feature: DB,
    ProjectionNode: LC,
    MeasureLayout: KC
  }
};
function k1(e, t, n) {
  const { props: o } = e;
  e.animationState && o.whileHover && e.animationState.setActive("whileHover", n === "Start");
  const i = "onHover" + n, l = o[i];
  l && nt.postRender(() => l(t, Bl(t)));
}
class kB extends $o {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = pV(t, (n, o) => (k1(this.node, o, "Start"), (i) => k1(this.node, i, "End"))));
  }
  unmount() {
  }
}
class PB extends $o {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.node.current.matches(":focus-visible");
    } catch {
      t = !0;
    }
    !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Il(Al(this.node.current, "focus", () => this.onFocus()), Al(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function P1(e, t, n) {
  const { props: o } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && o.whileTap && e.animationState.setActive("whileTap", n === "Start");
  const i = "onTap" + (n === "End" ? "" : n), l = o[i];
  l && nt.postRender(() => l(t, Bl(t)));
}
class LB extends $o {
  mount() {
    const { current: t } = this.node;
    t && (this.unmount = xV(t, (n, o) => (P1(this.node, o, "Start"), (i, { success: l }) => P1(this.node, i, l ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const ag = /* @__PURE__ */ new WeakMap(), am = /* @__PURE__ */ new WeakMap(), IB = (e) => {
  const t = ag.get(e.target);
  t && t(e);
}, VB = (e) => {
  e.forEach(IB);
};
function UB({ root: e, ...t }) {
  const n = e || document;
  am.has(n) || am.set(n, {});
  const o = am.get(n), i = JSON.stringify(t);
  return o[i] || (o[i] = new IntersectionObserver(VB, { root: e, ...t })), o[i];
}
function BB(e, t, n) {
  const o = UB(t);
  return ag.set(e, n), o.observe(e), () => {
    ag.delete(e), o.unobserve(e);
  };
}
const $B = {
  some: 0,
  all: 1
};
class HB extends $o {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: t = {} } = this.node.getProps(), { root: n, margin: o, amount: i = "some", once: l } = t, c = {
      root: n ? n.current : void 0,
      rootMargin: o,
      threshold: typeof i == "number" ? i : $B[i]
    }, f = (d) => {
      const { isIntersecting: h } = d;
      if (this.isInView === h || (this.isInView = h, l && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: m, onViewportLeave: v } = this.node.getProps(), b = h ? m : v;
      b && b(d);
    };
    return BB(this.node.current, c, f);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: t, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(ZB(t, n)) && this.startObserver();
  }
  unmount() {
  }
}
function ZB({ viewport: e = {} }, { viewport: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
const FB = {
  inView: {
    Feature: HB
  },
  tap: {
    Feature: LB
  },
  focus: {
    Feature: PB
  },
  hover: {
    Feature: kB
  }
}, GB = {
  layout: {
    ProjectionNode: LC,
    MeasureLayout: KC
  }
}, YB = {
  ...vB,
  ...FB,
  ...jB,
  ...GB
}, Uu = /* @__PURE__ */ dB(YB, hB);
function L1(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function qr(...e) {
  return (t) => {
    let n = !1;
    const o = e.map((i) => {
      const l = L1(i, t);
      return !n && typeof l == "function" && (n = !0), l;
    });
    if (n)
      return () => {
        for (let i = 0; i < o.length; i++) {
          const l = o[i];
          typeof l == "function" ? l() : L1(e[i], null);
        }
      };
  };
}
function Le(...e) {
  return y.useCallback(qr(...e), e);
}
var qB = /* @__PURE__ */ Symbol.for("react.lazy"), lf = Tf[" use ".trim().toString()];
function WB(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function JC(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === qB && "_payload" in e && WB(e._payload);
}
// @__NO_SIDE_EFFECTS__
function QC(e) {
  const t = /* @__PURE__ */ XB(e), n = y.forwardRef((o, i) => {
    let { children: l, ...c } = o;
    JC(l) && typeof lf == "function" && (l = lf(l._payload));
    const f = y.Children.toArray(l), d = f.find(JB);
    if (d) {
      const h = d.props.children, m = f.map((v) => v === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : v);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
var eA = /* @__PURE__ */ QC("Slot");
// @__NO_SIDE_EFFECTS__
function XB(e) {
  const t = y.forwardRef((n, o) => {
    let { children: i, ...l } = n;
    if (JC(i) && typeof lf == "function" && (i = lf(i._payload)), y.isValidElement(i)) {
      const c = e6(i), f = QB(l, i.props);
      return i.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(i, f);
    }
    return y.Children.count(i) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var KB = /* @__PURE__ */ Symbol("radix.slottable");
function JB(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === KB;
}
function QB(e, t) {
  const n = { ...t };
  for (const o in t) {
    const i = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? i && l ? n[o] = (...f) => {
      const d = l(...f);
      return i(...f), d;
    } : i && (n[o] = i) : o === "style" ? n[o] = { ...i, ...l } : o === "className" && (n[o] = [i, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function e6(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function tA(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = tA(e[t])) && (o && (o += " "), o += n);
  } else for (n in e) e[n] && (o && (o += " "), o += n);
  return o;
}
function nA() {
  for (var e, t, n = 0, o = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = tA(e)) && (o && (o += " "), o += t);
  return o;
}
const I1 = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, V1 = nA, rA = (e, t) => (n) => {
  var o;
  if (t?.variants == null) return V1(e, n?.class, n?.className);
  const { variants: i, defaultVariants: l } = t, c = Object.keys(i).map((h) => {
    const m = n?.[h], v = l?.[h];
    if (m === null) return null;
    const b = I1(m) || I1(v);
    return i[h][b];
  }), f = n && Object.entries(n).reduce((h, m) => {
    let [v, b] = m;
    return b === void 0 || (h[v] = b), h;
  }, {}), d = t == null || (o = t.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((h, m) => {
    let { class: v, className: b, ...x } = m;
    return Object.entries(x).every((E) => {
      let [w, C] = E;
      return Array.isArray(C) ? C.includes({
        ...l,
        ...f
      }[w]) : {
        ...l,
        ...f
      }[w] === C;
    }) ? [
      ...h,
      v,
      b
    ] : h;
  }, []);
  return V1(e, c, d, n?.class, n?.className);
}, t6 = (e, t) => {
  const n = new Array(e.length + t.length);
  for (let o = 0; o < e.length; o++)
    n[o] = e[o];
  for (let o = 0; o < t.length; o++)
    n[e.length + o] = t[o];
  return n;
}, n6 = (e, t) => ({
  classGroupId: e,
  validator: t
}), oA = (e = /* @__PURE__ */ new Map(), t = null, n) => ({
  nextPart: e,
  validators: t,
  classGroupId: n
}), cf = "-", U1 = [], r6 = "arbitrary..", o6 = (e) => {
  const t = i6(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: o
  } = e;
  return {
    getClassGroupId: (c) => {
      if (c.startsWith("[") && c.endsWith("]"))
        return a6(c);
      const f = c.split(cf), d = f[0] === "" && f.length > 1 ? 1 : 0;
      return aA(f, d, t);
    },
    getConflictingClassGroupIds: (c, f) => {
      if (f) {
        const d = o[c], h = n[c];
        return d ? h ? t6(h, d) : d : h || U1;
      }
      return n[c] || U1;
    }
  };
}, aA = (e, t, n) => {
  if (e.length - t === 0)
    return n.classGroupId;
  const i = e[t], l = n.nextPart.get(i);
  if (l) {
    const h = aA(e, t + 1, l);
    if (h) return h;
  }
  const c = n.validators;
  if (c === null)
    return;
  const f = t === 0 ? e.join(cf) : e.slice(t).join(cf), d = c.length;
  for (let h = 0; h < d; h++) {
    const m = c[h];
    if (m.validator(f))
      return m.classGroupId;
  }
}, a6 = (e) => e.slice(1, -1).indexOf(":") === -1 ? void 0 : (() => {
  const t = e.slice(1, -1), n = t.indexOf(":"), o = t.slice(0, n);
  return o ? r6 + o : void 0;
})(), i6 = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e;
  return s6(n, t);
}, s6 = (e, t) => {
  const n = oA();
  for (const o in e) {
    const i = e[o];
    mv(i, n, o, t);
  }
  return n;
}, mv = (e, t, n, o) => {
  const i = e.length;
  for (let l = 0; l < i; l++) {
    const c = e[l];
    l6(c, t, n, o);
  }
}, l6 = (e, t, n, o) => {
  if (typeof e == "string") {
    c6(e, t, n);
    return;
  }
  if (typeof e == "function") {
    u6(e, t, n, o);
    return;
  }
  f6(e, t, n, o);
}, c6 = (e, t, n) => {
  const o = e === "" ? t : iA(t, e);
  o.classGroupId = n;
}, u6 = (e, t, n, o) => {
  if (d6(e)) {
    mv(e(o), t, n, o);
    return;
  }
  t.validators === null && (t.validators = []), t.validators.push(n6(n, e));
}, f6 = (e, t, n, o) => {
  const i = Object.entries(e), l = i.length;
  for (let c = 0; c < l; c++) {
    const [f, d] = i[c];
    mv(d, iA(t, f), n, o);
  }
}, iA = (e, t) => {
  let n = e;
  const o = t.split(cf), i = o.length;
  for (let l = 0; l < i; l++) {
    const c = o[l];
    let f = n.nextPart.get(c);
    f || (f = oA(), n.nextPart.set(c, f)), n = f;
  }
  return n;
}, d6 = (e) => "isThemeGetter" in e && e.isThemeGetter === !0, h6 = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
  const i = (l, c) => {
    n[l] = c, t++, t > e && (t = 0, o = n, n = /* @__PURE__ */ Object.create(null));
  };
  return {
    get(l) {
      let c = n[l];
      if (c !== void 0)
        return c;
      if ((c = o[l]) !== void 0)
        return i(l, c), c;
    },
    set(l, c) {
      l in n ? n[l] = c : i(l, c);
    }
  };
}, ig = "!", B1 = ":", p6 = [], $1 = (e, t, n, o, i) => ({
  modifiers: e,
  hasImportantModifier: t,
  baseClassName: n,
  maybePostfixModifierPosition: o,
  isExternal: i
}), m6 = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let o = (i) => {
    const l = [];
    let c = 0, f = 0, d = 0, h;
    const m = i.length;
    for (let w = 0; w < m; w++) {
      const C = i[w];
      if (c === 0 && f === 0) {
        if (C === B1) {
          l.push(i.slice(d, w)), d = w + 1;
          continue;
        }
        if (C === "/") {
          h = w;
          continue;
        }
      }
      C === "[" ? c++ : C === "]" ? c-- : C === "(" ? f++ : C === ")" && f--;
    }
    const v = l.length === 0 ? i : i.slice(d);
    let b = v, x = !1;
    v.endsWith(ig) ? (b = v.slice(0, -1), x = !0) : (
      /**
       * In Tailwind CSS v3 the important modifier was at the start of the base class name. This is still supported for legacy reasons.
       * @see https://github.com/dcastil/tailwind-merge/issues/513#issuecomment-2614029864
       */
      v.startsWith(ig) && (b = v.slice(1), x = !0)
    );
    const E = h && h > d ? h - d : void 0;
    return $1(l, x, b, E);
  };
  if (t) {
    const i = t + B1, l = o;
    o = (c) => c.startsWith(i) ? l(c.slice(i.length)) : $1(p6, !1, c, void 0, !0);
  }
  if (n) {
    const i = o;
    o = (l) => n({
      className: l,
      parseClassName: i
    });
  }
  return o;
}, g6 = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.orderSensitiveModifiers.forEach((n, o) => {
    t.set(n, 1e6 + o);
  }), (n) => {
    const o = [];
    let i = [];
    for (let l = 0; l < n.length; l++) {
      const c = n[l], f = c[0] === "[", d = t.has(c);
      f || d ? (i.length > 0 && (i.sort(), o.push(...i), i = []), o.push(c)) : i.push(c);
    }
    return i.length > 0 && (i.sort(), o.push(...i)), o;
  };
}, v6 = (e) => ({
  cache: h6(e.cacheSize),
  parseClassName: m6(e),
  sortModifiers: g6(e),
  ...o6(e)
}), y6 = /\s+/, b6 = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: o,
    getConflictingClassGroupIds: i,
    sortModifiers: l
  } = t, c = [], f = e.trim().split(y6);
  let d = "";
  for (let h = f.length - 1; h >= 0; h -= 1) {
    const m = f[h], {
      isExternal: v,
      modifiers: b,
      hasImportantModifier: x,
      baseClassName: E,
      maybePostfixModifierPosition: w
    } = n(m);
    if (v) {
      d = m + (d.length > 0 ? " " + d : d);
      continue;
    }
    let C = !!w, A = o(C ? E.substring(0, w) : E);
    if (!A) {
      if (!C) {
        d = m + (d.length > 0 ? " " + d : d);
        continue;
      }
      if (A = o(E), !A) {
        d = m + (d.length > 0 ? " " + d : d);
        continue;
      }
      C = !1;
    }
    const M = b.length === 0 ? "" : b.length === 1 ? b[0] : l(b).join(":"), T = x ? M + ig : M, D = T + A;
    if (c.indexOf(D) > -1)
      continue;
    c.push(D);
    const O = i(A, C);
    for (let k = 0; k < O.length; ++k) {
      const R = O[k];
      c.push(T + R);
    }
    d = m + (d.length > 0 ? " " + d : d);
  }
  return d;
}, x6 = (...e) => {
  let t = 0, n, o, i = "";
  for (; t < e.length; )
    (n = e[t++]) && (o = sA(n)) && (i && (i += " "), i += o);
  return i;
}, sA = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let o = 0; o < e.length; o++)
    e[o] && (t = sA(e[o])) && (n && (n += " "), n += t);
  return n;
}, S6 = (e, ...t) => {
  let n, o, i, l;
  const c = (d) => {
    const h = t.reduce((m, v) => v(m), e());
    return n = v6(h), o = n.cache.get, i = n.cache.set, l = f, f(d);
  }, f = (d) => {
    const h = o(d);
    if (h)
      return h;
    const m = b6(d, n);
    return i(d, m), m;
  };
  return l = c, (...d) => l(x6(...d));
}, w6 = [], Mt = (e) => {
  const t = (n) => n[e] || w6;
  return t.isThemeGetter = !0, t;
}, lA = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, cA = /^\((?:(\w[\w-]*):)?(.+)\)$/i, E6 = /^\d+\/\d+$/, _6 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, T6 = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, C6 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, A6 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, R6 = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, vi = (e) => E6.test(e), Oe = (e) => !!e && !Number.isNaN(Number(e)), Eo = (e) => !!e && Number.isInteger(Number(e)), im = (e) => e.endsWith("%") && Oe(e.slice(0, -1)), Br = (e) => _6.test(e), M6 = () => !0, z6 = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  T6.test(e) && !C6.test(e)
), uA = () => !1, D6 = (e) => A6.test(e), N6 = (e) => R6.test(e), O6 = (e) => !ye(e) && !be(e), j6 = (e) => Wi(e, hA, uA), ye = (e) => lA.test(e), fa = (e) => Wi(e, pA, z6), sm = (e) => Wi(e, V6, Oe), H1 = (e) => Wi(e, fA, uA), k6 = (e) => Wi(e, dA, N6), Tu = (e) => Wi(e, mA, D6), be = (e) => cA.test(e), Qs = (e) => Xi(e, pA), P6 = (e) => Xi(e, U6), Z1 = (e) => Xi(e, fA), L6 = (e) => Xi(e, hA), I6 = (e) => Xi(e, dA), Cu = (e) => Xi(e, mA, !0), Wi = (e, t, n) => {
  const o = lA.exec(e);
  return o ? o[1] ? t(o[1]) : n(o[2]) : !1;
}, Xi = (e, t, n = !1) => {
  const o = cA.exec(e);
  return o ? o[1] ? t(o[1]) : n : !1;
}, fA = (e) => e === "position" || e === "percentage", dA = (e) => e === "image" || e === "url", hA = (e) => e === "length" || e === "size" || e === "bg-size", pA = (e) => e === "length", V6 = (e) => e === "number", U6 = (e) => e === "family-name", mA = (e) => e === "shadow", B6 = () => {
  const e = Mt("color"), t = Mt("font"), n = Mt("text"), o = Mt("font-weight"), i = Mt("tracking"), l = Mt("leading"), c = Mt("breakpoint"), f = Mt("container"), d = Mt("spacing"), h = Mt("radius"), m = Mt("shadow"), v = Mt("inset-shadow"), b = Mt("text-shadow"), x = Mt("drop-shadow"), E = Mt("blur"), w = Mt("perspective"), C = Mt("aspect"), A = Mt("ease"), M = Mt("animate"), T = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], D = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], O = () => [...D(), be, ye], k = () => ["auto", "hidden", "clip", "visible", "scroll"], R = () => ["auto", "contain", "none"], N = () => [be, ye, d], P = () => [vi, "full", "auto", ...N()], Y = () => [Eo, "none", "subgrid", be, ye], ne = () => ["auto", {
    span: ["full", Eo, be, ye]
  }, Eo, be, ye], J = () => [Eo, "auto", be, ye], ce = () => ["auto", "min", "max", "fr", be, ye], ue = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], de = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], I = () => ["auto", ...N()], G = () => [vi, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...N()], U = () => [e, be, ye], te = () => [...D(), Z1, H1, {
    position: [be, ye]
  }], he = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], j = () => ["auto", "cover", "contain", L6, j6, {
    size: [be, ye]
  }], W = () => [im, Qs, fa], $ = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    h,
    be,
    ye
  ], X = () => ["", Oe, Qs, fa], se = () => ["solid", "dashed", "dotted", "double"], ie = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], H = () => [Oe, im, Z1, H1], re = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    E,
    be,
    ye
  ], le = () => ["none", Oe, be, ye], fe = () => ["none", Oe, be, ye], me = () => [Oe, be, ye], Re = () => [vi, "full", ...N()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Br],
      breakpoint: [Br],
      color: [M6],
      container: [Br],
      "drop-shadow": [Br],
      ease: ["in", "out", "in-out"],
      font: [O6],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Br],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Br],
      shadow: [Br],
      spacing: ["px", Oe],
      text: [Br],
      "text-shadow": [Br],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", vi, ye, be, C]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Oe, ye, be, f]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": T()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": T()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: O()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: k()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": k()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": k()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: R()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": R()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": R()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: P()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": P()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": P()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: P()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: P()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: P()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: P()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: P()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: P()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [Eo, "auto", be, ye]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [vi, "full", "auto", f, ...N()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Oe, vi, "auto", "initial", "none", ye]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Oe, be, ye]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Oe, be, ye]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [Eo, "first", "last", "none", be, ye]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": Y()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ne()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": J()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": J()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": Y()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ne()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": J()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": J()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ce()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ce()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: N()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": N()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": N()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...ue(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...de(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...de()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ue()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...de(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...de(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": ue()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...de(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...de()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: N()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: N()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: N()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: N()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: N()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: N()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: N()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: N()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: N()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: I()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: I()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: I()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: I()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: I()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: I()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: I()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: I()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: I()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": N()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": N()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: G()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [f, "screen", ...G()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          f,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...G()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          f,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [c]
          },
          ...G()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...G()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...G()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...G()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, Qs, fa]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [o, be, sm]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", im, ye]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [P6, ye, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [i, be, ye]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Oe, "none", be, sm]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          l,
          ...N()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", be, ye]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", be, ye]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: U()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: U()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...se(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Oe, "from-font", "auto", be, fa]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: U()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Oe, "auto", be, ye]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: N()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", be, ye]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", be, ye]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: te()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: he()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: j()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, Eo, be, ye],
          radial: ["", be, ye],
          conic: [Eo, be, ye]
        }, I6, k6]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: U()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: W()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: W()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: W()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: U()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: U()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: U()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: $()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": $()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": $()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": $()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": $()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": $()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": $()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": $()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": $()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": $()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": $()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": $()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": $()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": $()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": $()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: X()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": X()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": X()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": X()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": X()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": X()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": X()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": X()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": X()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": X()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": X()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...se(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...se(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: U()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": U()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": U()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": U()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": U()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": U()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": U()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": U()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": U()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: U()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...se(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Oe, be, ye]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Oe, Qs, fa]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: U()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          m,
          Cu,
          Tu
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: U()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", v, Cu, Tu]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": U()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: X()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: U()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Oe, fa]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": U()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": X()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": U()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", b, Cu, Tu]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": U()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Oe, be, ye]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ie(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ie()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Oe]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": H()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": H()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": U()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": U()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": H()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": H()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": U()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": U()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": H()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": H()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": U()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": U()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": H()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": H()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": U()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": U()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": H()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": H()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": U()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": U()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": H()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": H()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": U()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": U()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": H()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": H()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": U()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": U()
      }],
      "mask-image-radial": [{
        "mask-radial": [be, ye]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": H()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": H()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": U()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": U()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": D()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Oe]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": H()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": H()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": U()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": U()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: te()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: he()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: j()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", be, ye]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          be,
          ye
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: re()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Oe, be, ye]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Oe, be, ye]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          x,
          Cu,
          Tu
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": U()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Oe, be, ye]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Oe, be, ye]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Oe, be, ye]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Oe, be, ye]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Oe, be, ye]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          be,
          ye
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": re()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Oe, be, ye]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Oe, be, ye]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Oe, be, ye]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Oe, be, ye]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Oe, be, ye]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Oe, be, ye]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Oe, be, ye]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Oe, be, ye]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": N()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": N()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": N()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", be, ye]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Oe, "initial", be, ye]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", A, be, ye]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Oe, be, ye]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", M, be, ye]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [w, be, ye]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": O()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: le()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": le()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": le()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": le()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: fe()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": fe()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": fe()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": fe()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: me()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": me()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": me()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [be, ye, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: O()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Re()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Re()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Re()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Re()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: U()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: U()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", be, ye]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": N()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": N()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": N()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": N()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": N()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": N()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": N()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": N()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": N()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": N()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": N()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": N()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": N()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": N()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": N()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": N()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": N()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": N()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", be, ye]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...U()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Oe, Qs, fa, sm]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...U()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, $6 = /* @__PURE__ */ S6(B6);
function Ge(...e) {
  return $6(nA(e));
}
function H6({ className: e, ...t }) {
  return /* @__PURE__ */ S.jsx(
    r2,
    {
      role: "status",
      "aria-label": "Loading",
      className: Ge("size-4 animate-spin", e),
      ...t
    }
  );
}
const Z6 = rA(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Nt({
  className: e,
  variant: t,
  size: n,
  asChild: o = !1,
  isLoading: i = !1,
  ...l
}) {
  const c = o ? eA : "button";
  return /* @__PURE__ */ S.jsxs(
    c,
    {
      "data-slot": "button",
      className: Ge(Z6({ variant: t, size: n, className: e })),
      ...l,
      children: [
        l.children,
        " ",
        i && /* @__PURE__ */ S.jsx(H6, {})
      ]
    }
  );
}
function ge(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e?.(i), n === !1 || !i.defaultPrevented)
      return t?.(i);
  };
}
function F6(e, t) {
  const n = y.createContext(t), o = (l) => {
    const { children: c, ...f } = l, d = y.useMemo(() => f, Object.values(f));
    return /* @__PURE__ */ S.jsx(n.Provider, { value: d, children: c });
  };
  o.displayName = e + "Provider";
  function i(l) {
    const c = y.useContext(n);
    if (c) return c;
    if (t !== void 0) return t;
    throw new Error(`\`${l}\` must be used within \`${e}\``);
  }
  return [o, i];
}
function yr(e, t = []) {
  let n = [];
  function o(l, c) {
    const f = y.createContext(c), d = n.length;
    n = [...n, c];
    const h = (v) => {
      const { scope: b, children: x, ...E } = v, w = b?.[e]?.[d] || f, C = y.useMemo(() => E, Object.values(E));
      return /* @__PURE__ */ S.jsx(w.Provider, { value: C, children: x });
    };
    h.displayName = l + "Provider";
    function m(v, b) {
      const x = b?.[e]?.[d] || f, E = y.useContext(x);
      if (E) return E;
      if (c !== void 0) return c;
      throw new Error(`\`${v}\` must be used within \`${l}\``);
    }
    return [h, m];
  }
  const i = () => {
    const l = n.map((c) => y.createContext(c));
    return function(f) {
      const d = f?.[e] || l;
      return y.useMemo(
        () => ({ [`__scope${e}`]: { ...f, [e]: d } }),
        [f, d]
      );
    };
  };
  return i.scopeName = e, [o, G6(i, ...t)];
}
function G6(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const o = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(l) {
      const c = o.reduce((f, { useScope: d, scopeName: h }) => {
        const v = d(l)[`__scope${h}`];
        return { ...f, ...v };
      }, {});
      return y.useMemo(() => ({ [`__scope${t.scopeName}`]: c }), [c]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
// @__NO_SIDE_EFFECTS__
function Y6(e) {
  const t = /* @__PURE__ */ q6(e), n = y.forwardRef((o, i) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(X6);
    if (d) {
      const h = d.props.children, m = f.map((v) => v === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : v);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function q6(e) {
  const t = y.forwardRef((n, o) => {
    const { children: i, ...l } = n;
    if (y.isValidElement(i)) {
      const c = J6(i), f = K6(l, i.props);
      return i.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(i, f);
    }
    return y.Children.count(i) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var W6 = /* @__PURE__ */ Symbol("radix.slottable");
function X6(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === W6;
}
function K6(e, t) {
  const n = { ...t };
  for (const o in t) {
    const i = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? i && l ? n[o] = (...f) => {
      const d = l(...f);
      return i(...f), d;
    } : i && (n[o] = i) : o === "style" ? n[o] = { ...i, ...l } : o === "className" && (n[o] = [i, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function J6(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Q6 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], ze = Q6.reduce((e, t) => {
  const n = /* @__PURE__ */ Y6(`Primitive.${t}`), o = y.forwardRef((i, l) => {
    const { asChild: c, ...f } = i, d = c ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(d, { ...f, ref: l });
  });
  return o.displayName = `Primitive.${t}`, { ...e, [t]: o };
}, {});
function gA(e, t) {
  e && Vo.flushSync(() => e.dispatchEvent(t));
}
function $t(e) {
  const t = y.useRef(e);
  return y.useEffect(() => {
    t.current = e;
  }), y.useMemo(() => (...n) => t.current?.(...n), []);
}
function e9(e, t = globalThis?.document) {
  const n = $t(e);
  y.useEffect(() => {
    const o = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", o, { capture: !0 }), () => t.removeEventListener("keydown", o, { capture: !0 });
  }, [n, t]);
}
var t9 = "DismissableLayer", sg = "dismissableLayer.update", n9 = "dismissableLayer.pointerDownOutside", r9 = "dismissableLayer.focusOutside", F1, vA = y.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), $l = y.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: i,
      onFocusOutside: l,
      onInteractOutside: c,
      onDismiss: f,
      ...d
    } = e, h = y.useContext(vA), [m, v] = y.useState(null), b = m?.ownerDocument ?? globalThis?.document, [, x] = y.useState({}), E = Le(t, (R) => v(R)), w = Array.from(h.layers), [C] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1), A = w.indexOf(C), M = m ? w.indexOf(m) : -1, T = h.layersWithOutsidePointerEventsDisabled.size > 0, D = M >= A, O = i9((R) => {
      const N = R.target, P = [...h.branches].some((Y) => Y.contains(N));
      !D || P || (i?.(R), c?.(R), R.defaultPrevented || f?.());
    }, b), k = s9((R) => {
      const N = R.target;
      [...h.branches].some((Y) => Y.contains(N)) || (l?.(R), c?.(R), R.defaultPrevented || f?.());
    }, b);
    return e9((R) => {
      M === h.layers.size - 1 && (o?.(R), !R.defaultPrevented && f && (R.preventDefault(), f()));
    }, b), y.useEffect(() => {
      if (m)
        return n && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (F1 = b.body.style.pointerEvents, b.body.style.pointerEvents = "none"), h.layersWithOutsidePointerEventsDisabled.add(m)), h.layers.add(m), G1(), () => {
          n && h.layersWithOutsidePointerEventsDisabled.size === 1 && (b.body.style.pointerEvents = F1);
        };
    }, [m, b, n, h]), y.useEffect(() => () => {
      m && (h.layers.delete(m), h.layersWithOutsidePointerEventsDisabled.delete(m), G1());
    }, [m, h]), y.useEffect(() => {
      const R = () => x({});
      return document.addEventListener(sg, R), () => document.removeEventListener(sg, R);
    }, []), /* @__PURE__ */ S.jsx(
      ze.div,
      {
        ...d,
        ref: E,
        style: {
          pointerEvents: T ? D ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: ge(e.onFocusCapture, k.onFocusCapture),
        onBlurCapture: ge(e.onBlurCapture, k.onBlurCapture),
        onPointerDownCapture: ge(
          e.onPointerDownCapture,
          O.onPointerDownCapture
        )
      }
    );
  }
);
$l.displayName = t9;
var o9 = "DismissableLayerBranch", a9 = y.forwardRef((e, t) => {
  const n = y.useContext(vA), o = y.useRef(null), i = Le(t, o);
  return y.useEffect(() => {
    const l = o.current;
    if (l)
      return n.branches.add(l), () => {
        n.branches.delete(l);
      };
  }, [n.branches]), /* @__PURE__ */ S.jsx(ze.div, { ...e, ref: i });
});
a9.displayName = o9;
function i9(e, t = globalThis?.document) {
  const n = $t(e), o = y.useRef(!1), i = y.useRef(() => {
  });
  return y.useEffect(() => {
    const l = (f) => {
      if (f.target && !o.current) {
        let d = function() {
          yA(
            n9,
            n,
            h,
            { discrete: !0 }
          );
        };
        const h = { originalEvent: f };
        f.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = d, t.addEventListener("click", i.current, { once: !0 })) : d();
      } else
        t.removeEventListener("click", i.current);
      o.current = !1;
    }, c = window.setTimeout(() => {
      t.addEventListener("pointerdown", l);
    }, 0);
    return () => {
      window.clearTimeout(c), t.removeEventListener("pointerdown", l), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => o.current = !0
  };
}
function s9(e, t = globalThis?.document) {
  const n = $t(e), o = y.useRef(!1);
  return y.useEffect(() => {
    const i = (l) => {
      l.target && !o.current && yA(r9, n, { originalEvent: l }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => o.current = !0,
    onBlurCapture: () => o.current = !1
  };
}
function G1() {
  const e = new CustomEvent(sg);
  document.dispatchEvent(e);
}
function yA(e, t, n, { discrete: o }) {
  const i = n.originalEvent.target, l = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), o ? gA(i, l) : i.dispatchEvent(l);
}
var Ht = globalThis?.document ? y.useLayoutEffect : () => {
}, l9 = Tf[" useId ".trim().toString()] || (() => {
}), c9 = 0;
function pr(e) {
  const [t, n] = y.useState(l9());
  return Ht(() => {
    n((o) => o ?? String(c9++));
  }, [e]), t ? `radix-${t}` : "";
}
const u9 = ["top", "right", "bottom", "left"], Lo = Math.min, wn = Math.max, uf = Math.round, Au = Math.floor, mr = (e) => ({
  x: e,
  y: e
}), f9 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, d9 = {
  start: "end",
  end: "start"
};
function lg(e, t, n) {
  return wn(e, Lo(t, n));
}
function Gr(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Yr(e) {
  return e.split("-")[0];
}
function Ki(e) {
  return e.split("-")[1];
}
function gv(e) {
  return e === "x" ? "y" : "x";
}
function vv(e) {
  return e === "y" ? "height" : "width";
}
const h9 = /* @__PURE__ */ new Set(["top", "bottom"]);
function dr(e) {
  return h9.has(Yr(e)) ? "y" : "x";
}
function yv(e) {
  return gv(dr(e));
}
function p9(e, t, n) {
  n === void 0 && (n = !1);
  const o = Ki(e), i = yv(e), l = vv(i);
  let c = i === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[l] > t.floating[l] && (c = ff(c)), [c, ff(c)];
}
function m9(e) {
  const t = ff(e);
  return [cg(e), t, cg(t)];
}
function cg(e) {
  return e.replace(/start|end/g, (t) => d9[t]);
}
const Y1 = ["left", "right"], q1 = ["right", "left"], g9 = ["top", "bottom"], v9 = ["bottom", "top"];
function y9(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? q1 : Y1 : t ? Y1 : q1;
    case "left":
    case "right":
      return t ? g9 : v9;
    default:
      return [];
  }
}
function b9(e, t, n, o) {
  const i = Ki(e);
  let l = y9(Yr(e), n === "start", o);
  return i && (l = l.map((c) => c + "-" + i), t && (l = l.concat(l.map(cg)))), l;
}
function ff(e) {
  return e.replace(/left|right|bottom|top/g, (t) => f9[t]);
}
function x9(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function bA(e) {
  return typeof e != "number" ? x9(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function df(e) {
  const {
    x: t,
    y: n,
    width: o,
    height: i
  } = e;
  return {
    width: o,
    height: i,
    top: n,
    left: t,
    right: t + o,
    bottom: n + i,
    x: t,
    y: n
  };
}
function W1(e, t, n) {
  let {
    reference: o,
    floating: i
  } = e;
  const l = dr(t), c = yv(t), f = vv(c), d = Yr(t), h = l === "y", m = o.x + o.width / 2 - i.width / 2, v = o.y + o.height / 2 - i.height / 2, b = o[f] / 2 - i[f] / 2;
  let x;
  switch (d) {
    case "top":
      x = {
        x: m,
        y: o.y - i.height
      };
      break;
    case "bottom":
      x = {
        x: m,
        y: o.y + o.height
      };
      break;
    case "right":
      x = {
        x: o.x + o.width,
        y: v
      };
      break;
    case "left":
      x = {
        x: o.x - i.width,
        y: v
      };
      break;
    default:
      x = {
        x: o.x,
        y: o.y
      };
  }
  switch (Ki(t)) {
    case "start":
      x[c] -= b * (n && h ? -1 : 1);
      break;
    case "end":
      x[c] += b * (n && h ? -1 : 1);
      break;
  }
  return x;
}
async function S9(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: i,
    platform: l,
    rects: c,
    elements: f,
    strategy: d
  } = e, {
    boundary: h = "clippingAncestors",
    rootBoundary: m = "viewport",
    elementContext: v = "floating",
    altBoundary: b = !1,
    padding: x = 0
  } = Gr(t, e), E = bA(x), C = f[b ? v === "floating" ? "reference" : "floating" : v], A = df(await l.getClippingRect({
    element: (n = await (l.isElement == null ? void 0 : l.isElement(C))) == null || n ? C : C.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(f.floating)),
    boundary: h,
    rootBoundary: m,
    strategy: d
  })), M = v === "floating" ? {
    x: o,
    y: i,
    width: c.floating.width,
    height: c.floating.height
  } : c.reference, T = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f.floating)), D = await (l.isElement == null ? void 0 : l.isElement(T)) ? await (l.getScale == null ? void 0 : l.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = df(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: f,
    rect: M,
    offsetParent: T,
    strategy: d
  }) : M);
  return {
    top: (A.top - O.top + E.top) / D.y,
    bottom: (O.bottom - A.bottom + E.bottom) / D.y,
    left: (A.left - O.left + E.left) / D.x,
    right: (O.right - A.right + E.right) / D.x
  };
}
const w9 = async (e, t, n) => {
  const {
    placement: o = "bottom",
    strategy: i = "absolute",
    middleware: l = [],
    platform: c
  } = n, f = l.filter(Boolean), d = await (c.isRTL == null ? void 0 : c.isRTL(t));
  let h = await c.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: m,
    y: v
  } = W1(h, o, d), b = o, x = {}, E = 0;
  for (let C = 0; C < f.length; C++) {
    var w;
    const {
      name: A,
      fn: M
    } = f[C], {
      x: T,
      y: D,
      data: O,
      reset: k
    } = await M({
      x: m,
      y: v,
      initialPlacement: o,
      placement: b,
      strategy: i,
      middlewareData: x,
      rects: h,
      platform: {
        ...c,
        detectOverflow: (w = c.detectOverflow) != null ? w : S9
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    m = T ?? m, v = D ?? v, x = {
      ...x,
      [A]: {
        ...x[A],
        ...O
      }
    }, k && E <= 50 && (E++, typeof k == "object" && (k.placement && (b = k.placement), k.rects && (h = k.rects === !0 ? await c.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : k.rects), {
      x: m,
      y: v
    } = W1(h, b, d)), C = -1);
  }
  return {
    x: m,
    y: v,
    placement: b,
    strategy: i,
    middlewareData: x
  };
}, E9 = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: o,
      placement: i,
      rects: l,
      platform: c,
      elements: f,
      middlewareData: d
    } = t, {
      element: h,
      padding: m = 0
    } = Gr(e, t) || {};
    if (h == null)
      return {};
    const v = bA(m), b = {
      x: n,
      y: o
    }, x = yv(i), E = vv(x), w = await c.getDimensions(h), C = x === "y", A = C ? "top" : "left", M = C ? "bottom" : "right", T = C ? "clientHeight" : "clientWidth", D = l.reference[E] + l.reference[x] - b[x] - l.floating[E], O = b[x] - l.reference[x], k = await (c.getOffsetParent == null ? void 0 : c.getOffsetParent(h));
    let R = k ? k[T] : 0;
    (!R || !await (c.isElement == null ? void 0 : c.isElement(k))) && (R = f.floating[T] || l.floating[E]);
    const N = D / 2 - O / 2, P = R / 2 - w[E] / 2 - 1, Y = Lo(v[A], P), ne = Lo(v[M], P), J = Y, ce = R - w[E] - ne, ue = R / 2 - w[E] / 2 + N, de = lg(J, ue, ce), I = !d.arrow && Ki(i) != null && ue !== de && l.reference[E] / 2 - (ue < J ? Y : ne) - w[E] / 2 < 0, G = I ? ue < J ? ue - J : ue - ce : 0;
    return {
      [x]: b[x] + G,
      data: {
        [x]: de,
        centerOffset: ue - de - G,
        ...I && {
          alignmentOffset: G
        }
      },
      reset: I
    };
  }
}), _9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: i,
        middlewareData: l,
        rects: c,
        initialPlacement: f,
        platform: d,
        elements: h
      } = t, {
        mainAxis: m = !0,
        crossAxis: v = !0,
        fallbackPlacements: b,
        fallbackStrategy: x = "bestFit",
        fallbackAxisSideDirection: E = "none",
        flipAlignment: w = !0,
        ...C
      } = Gr(e, t);
      if ((n = l.arrow) != null && n.alignmentOffset)
        return {};
      const A = Yr(i), M = dr(f), T = Yr(f) === f, D = await (d.isRTL == null ? void 0 : d.isRTL(h.floating)), O = b || (T || !w ? [ff(f)] : m9(f)), k = E !== "none";
      !b && k && O.push(...b9(f, w, E, D));
      const R = [f, ...O], N = await d.detectOverflow(t, C), P = [];
      let Y = ((o = l.flip) == null ? void 0 : o.overflows) || [];
      if (m && P.push(N[A]), v) {
        const ue = p9(i, c, D);
        P.push(N[ue[0]], N[ue[1]]);
      }
      if (Y = [...Y, {
        placement: i,
        overflows: P
      }], !P.every((ue) => ue <= 0)) {
        var ne, J;
        const ue = (((ne = l.flip) == null ? void 0 : ne.index) || 0) + 1, de = R[ue];
        if (de && (!(v === "alignment" ? M !== dr(de) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        Y.every((U) => dr(U.placement) === M ? U.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ue,
              overflows: Y
            },
            reset: {
              placement: de
            }
          };
        let I = (J = Y.filter((G) => G.overflows[0] <= 0).sort((G, U) => G.overflows[1] - U.overflows[1])[0]) == null ? void 0 : J.placement;
        if (!I)
          switch (x) {
            case "bestFit": {
              var ce;
              const G = (ce = Y.filter((U) => {
                if (k) {
                  const te = dr(U.placement);
                  return te === M || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  te === "y";
                }
                return !0;
              }).map((U) => [U.placement, U.overflows.filter((te) => te > 0).reduce((te, he) => te + he, 0)]).sort((U, te) => U[1] - te[1])[0]) == null ? void 0 : ce[0];
              G && (I = G);
              break;
            }
            case "initialPlacement":
              I = f;
              break;
          }
        if (i !== I)
          return {
            reset: {
              placement: I
            }
          };
      }
      return {};
    }
  };
};
function X1(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function K1(e) {
  return u9.some((t) => e[t] >= 0);
}
const T9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n,
        platform: o
      } = t, {
        strategy: i = "referenceHidden",
        ...l
      } = Gr(e, t);
      switch (i) {
        case "referenceHidden": {
          const c = await o.detectOverflow(t, {
            ...l,
            elementContext: "reference"
          }), f = X1(c, n.reference);
          return {
            data: {
              referenceHiddenOffsets: f,
              referenceHidden: K1(f)
            }
          };
        }
        case "escaped": {
          const c = await o.detectOverflow(t, {
            ...l,
            altBoundary: !0
          }), f = X1(c, n.floating);
          return {
            data: {
              escapedOffsets: f,
              escaped: K1(f)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, xA = /* @__PURE__ */ new Set(["left", "top"]);
async function C9(e, t) {
  const {
    placement: n,
    platform: o,
    elements: i
  } = e, l = await (o.isRTL == null ? void 0 : o.isRTL(i.floating)), c = Yr(n), f = Ki(n), d = dr(n) === "y", h = xA.has(c) ? -1 : 1, m = l && d ? -1 : 1, v = Gr(t, e);
  let {
    mainAxis: b,
    crossAxis: x,
    alignmentAxis: E
  } = typeof v == "number" ? {
    mainAxis: v,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: v.mainAxis || 0,
    crossAxis: v.crossAxis || 0,
    alignmentAxis: v.alignmentAxis
  };
  return f && typeof E == "number" && (x = f === "end" ? E * -1 : E), d ? {
    x: x * m,
    y: b * h
  } : {
    x: b * h,
    y: x * m
  };
}
const A9 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, o;
      const {
        x: i,
        y: l,
        placement: c,
        middlewareData: f
      } = t, d = await C9(t, e);
      return c === ((n = f.offset) == null ? void 0 : n.placement) && (o = f.arrow) != null && o.alignmentOffset ? {} : {
        x: i + d.x,
        y: l + d.y,
        data: {
          ...d,
          placement: c
        }
      };
    }
  };
}, R9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: i,
        platform: l
      } = t, {
        mainAxis: c = !0,
        crossAxis: f = !1,
        limiter: d = {
          fn: (A) => {
            let {
              x: M,
              y: T
            } = A;
            return {
              x: M,
              y: T
            };
          }
        },
        ...h
      } = Gr(e, t), m = {
        x: n,
        y: o
      }, v = await l.detectOverflow(t, h), b = dr(Yr(i)), x = gv(b);
      let E = m[x], w = m[b];
      if (c) {
        const A = x === "y" ? "top" : "left", M = x === "y" ? "bottom" : "right", T = E + v[A], D = E - v[M];
        E = lg(T, E, D);
      }
      if (f) {
        const A = b === "y" ? "top" : "left", M = b === "y" ? "bottom" : "right", T = w + v[A], D = w - v[M];
        w = lg(T, w, D);
      }
      const C = d.fn({
        ...t,
        [x]: E,
        [b]: w
      });
      return {
        ...C,
        data: {
          x: C.x - n,
          y: C.y - o,
          enabled: {
            [x]: c,
            [b]: f
          }
        }
      };
    }
  };
}, M9 = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: o,
        placement: i,
        rects: l,
        middlewareData: c
      } = t, {
        offset: f = 0,
        mainAxis: d = !0,
        crossAxis: h = !0
      } = Gr(e, t), m = {
        x: n,
        y: o
      }, v = dr(i), b = gv(v);
      let x = m[b], E = m[v];
      const w = Gr(f, t), C = typeof w == "number" ? {
        mainAxis: w,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...w
      };
      if (d) {
        const T = b === "y" ? "height" : "width", D = l.reference[b] - l.floating[T] + C.mainAxis, O = l.reference[b] + l.reference[T] - C.mainAxis;
        x < D ? x = D : x > O && (x = O);
      }
      if (h) {
        var A, M;
        const T = b === "y" ? "width" : "height", D = xA.has(Yr(i)), O = l.reference[v] - l.floating[T] + (D && ((A = c.offset) == null ? void 0 : A[v]) || 0) + (D ? 0 : C.crossAxis), k = l.reference[v] + l.reference[T] + (D ? 0 : ((M = c.offset) == null ? void 0 : M[v]) || 0) - (D ? C.crossAxis : 0);
        E < O ? E = O : E > k && (E = k);
      }
      return {
        [b]: x,
        [v]: E
      };
    }
  };
}, z9 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: i,
        rects: l,
        platform: c,
        elements: f
      } = t, {
        apply: d = () => {
        },
        ...h
      } = Gr(e, t), m = await c.detectOverflow(t, h), v = Yr(i), b = Ki(i), x = dr(i) === "y", {
        width: E,
        height: w
      } = l.floating;
      let C, A;
      v === "top" || v === "bottom" ? (C = v, A = b === (await (c.isRTL == null ? void 0 : c.isRTL(f.floating)) ? "start" : "end") ? "left" : "right") : (A = v, C = b === "end" ? "top" : "bottom");
      const M = w - m.top - m.bottom, T = E - m.left - m.right, D = Lo(w - m[C], M), O = Lo(E - m[A], T), k = !t.middlewareData.shift;
      let R = D, N = O;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (N = T), (o = t.middlewareData.shift) != null && o.enabled.y && (R = M), k && !b) {
        const Y = wn(m.left, 0), ne = wn(m.right, 0), J = wn(m.top, 0), ce = wn(m.bottom, 0);
        x ? N = E - 2 * (Y !== 0 || ne !== 0 ? Y + ne : wn(m.left, m.right)) : R = w - 2 * (J !== 0 || ce !== 0 ? J + ce : wn(m.top, m.bottom));
      }
      await d({
        ...t,
        availableWidth: N,
        availableHeight: R
      });
      const P = await c.getDimensions(f.floating);
      return E !== P.width || w !== P.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function If() {
  return typeof window < "u";
}
function Ji(e) {
  return SA(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function En(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function br(e) {
  var t;
  return (t = (SA(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function SA(e) {
  return If() ? e instanceof Node || e instanceof En(e).Node : !1;
}
function er(e) {
  return If() ? e instanceof Element || e instanceof En(e).Element : !1;
}
function vr(e) {
  return If() ? e instanceof HTMLElement || e instanceof En(e).HTMLElement : !1;
}
function J1(e) {
  return !If() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof En(e).ShadowRoot;
}
const D9 = /* @__PURE__ */ new Set(["inline", "contents"]);
function Hl(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: i
  } = tr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !D9.has(i);
}
const N9 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function O9(e) {
  return N9.has(Ji(e));
}
const j9 = [":popover-open", ":modal"];
function Vf(e) {
  return j9.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const k9 = ["transform", "translate", "scale", "rotate", "perspective"], P9 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], L9 = ["paint", "layout", "strict", "content"];
function bv(e) {
  const t = xv(), n = er(e) ? tr(e) : e;
  return k9.some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || P9.some((o) => (n.willChange || "").includes(o)) || L9.some((o) => (n.contain || "").includes(o));
}
function I9(e) {
  let t = Io(e);
  for (; vr(t) && !Bi(t); ) {
    if (bv(t))
      return t;
    if (Vf(t))
      return null;
    t = Io(t);
  }
  return null;
}
function xv() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const V9 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Bi(e) {
  return V9.has(Ji(e));
}
function tr(e) {
  return En(e).getComputedStyle(e);
}
function Uf(e) {
  return er(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Io(e) {
  if (Ji(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    J1(e) && e.host || // Fallback.
    br(e)
  );
  return J1(t) ? t.host : t;
}
function wA(e) {
  const t = Io(e);
  return Bi(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : vr(t) && Hl(t) ? t : wA(t);
}
function Rl(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = wA(e), l = i === ((o = e.ownerDocument) == null ? void 0 : o.body), c = En(i);
  if (l) {
    const f = ug(c);
    return t.concat(c, c.visualViewport || [], Hl(i) ? i : [], f && n ? Rl(f) : []);
  }
  return t.concat(i, Rl(i, [], n));
}
function ug(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function EA(e) {
  const t = tr(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const i = vr(e), l = i ? e.offsetWidth : n, c = i ? e.offsetHeight : o, f = uf(n) !== l || uf(o) !== c;
  return f && (n = l, o = c), {
    width: n,
    height: o,
    $: f
  };
}
function Sv(e) {
  return er(e) ? e : e.contextElement;
}
function ji(e) {
  const t = Sv(e);
  if (!vr(t))
    return mr(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: i,
    $: l
  } = EA(t);
  let c = (l ? uf(n.width) : n.width) / o, f = (l ? uf(n.height) : n.height) / i;
  return (!c || !Number.isFinite(c)) && (c = 1), (!f || !Number.isFinite(f)) && (f = 1), {
    x: c,
    y: f
  };
}
const U9 = /* @__PURE__ */ mr(0);
function _A(e) {
  const t = En(e);
  return !xv() || !t.visualViewport ? U9 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function B9(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== En(e) ? !1 : t;
}
function Sa(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), l = Sv(e);
  let c = mr(1);
  t && (o ? er(o) && (c = ji(o)) : c = ji(e));
  const f = B9(l, n, o) ? _A(l) : mr(0);
  let d = (i.left + f.x) / c.x, h = (i.top + f.y) / c.y, m = i.width / c.x, v = i.height / c.y;
  if (l) {
    const b = En(l), x = o && er(o) ? En(o) : o;
    let E = b, w = ug(E);
    for (; w && o && x !== E; ) {
      const C = ji(w), A = w.getBoundingClientRect(), M = tr(w), T = A.left + (w.clientLeft + parseFloat(M.paddingLeft)) * C.x, D = A.top + (w.clientTop + parseFloat(M.paddingTop)) * C.y;
      d *= C.x, h *= C.y, m *= C.x, v *= C.y, d += T, h += D, E = En(w), w = ug(E);
    }
  }
  return df({
    width: m,
    height: v,
    x: d,
    y: h
  });
}
function Bf(e, t) {
  const n = Uf(e).scrollLeft;
  return t ? t.left + n : Sa(br(e)).left + n;
}
function TA(e, t) {
  const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - Bf(e, n), i = n.top + t.scrollTop;
  return {
    x: o,
    y: i
  };
}
function $9(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: i
  } = e;
  const l = i === "fixed", c = br(o), f = t ? Vf(t.floating) : !1;
  if (o === c || f && l)
    return n;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = mr(1);
  const m = mr(0), v = vr(o);
  if ((v || !v && !l) && ((Ji(o) !== "body" || Hl(c)) && (d = Uf(o)), vr(o))) {
    const x = Sa(o);
    h = ji(o), m.x = x.x + o.clientLeft, m.y = x.y + o.clientTop;
  }
  const b = c && !v && !l ? TA(c, d) : mr(0);
  return {
    width: n.width * h.x,
    height: n.height * h.y,
    x: n.x * h.x - d.scrollLeft * h.x + m.x + b.x,
    y: n.y * h.y - d.scrollTop * h.y + m.y + b.y
  };
}
function H9(e) {
  return Array.from(e.getClientRects());
}
function Z9(e) {
  const t = br(e), n = Uf(e), o = e.ownerDocument.body, i = wn(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), l = wn(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let c = -n.scrollLeft + Bf(e);
  const f = -n.scrollTop;
  return tr(o).direction === "rtl" && (c += wn(t.clientWidth, o.clientWidth) - i), {
    width: i,
    height: l,
    x: c,
    y: f
  };
}
const Q1 = 25;
function F9(e, t) {
  const n = En(e), o = br(e), i = n.visualViewport;
  let l = o.clientWidth, c = o.clientHeight, f = 0, d = 0;
  if (i) {
    l = i.width, c = i.height;
    const m = xv();
    (!m || m && t === "fixed") && (f = i.offsetLeft, d = i.offsetTop);
  }
  const h = Bf(o);
  if (h <= 0) {
    const m = o.ownerDocument, v = m.body, b = getComputedStyle(v), x = m.compatMode === "CSS1Compat" && parseFloat(b.marginLeft) + parseFloat(b.marginRight) || 0, E = Math.abs(o.clientWidth - v.clientWidth - x);
    E <= Q1 && (l -= E);
  } else h <= Q1 && (l += h);
  return {
    width: l,
    height: c,
    x: f,
    y: d
  };
}
const G9 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Y9(e, t) {
  const n = Sa(e, !0, t === "fixed"), o = n.top + e.clientTop, i = n.left + e.clientLeft, l = vr(e) ? ji(e) : mr(1), c = e.clientWidth * l.x, f = e.clientHeight * l.y, d = i * l.x, h = o * l.y;
  return {
    width: c,
    height: f,
    x: d,
    y: h
  };
}
function eE(e, t, n) {
  let o;
  if (t === "viewport")
    o = F9(e, n);
  else if (t === "document")
    o = Z9(br(e));
  else if (er(t))
    o = Y9(t, n);
  else {
    const i = _A(e);
    o = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return df(o);
}
function CA(e, t) {
  const n = Io(e);
  return n === t || !er(n) || Bi(n) ? !1 : tr(n).position === "fixed" || CA(n, t);
}
function q9(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = Rl(e, [], !1).filter((f) => er(f) && Ji(f) !== "body"), i = null;
  const l = tr(e).position === "fixed";
  let c = l ? Io(e) : e;
  for (; er(c) && !Bi(c); ) {
    const f = tr(c), d = bv(c);
    !d && f.position === "fixed" && (i = null), (l ? !d && !i : !d && f.position === "static" && !!i && G9.has(i.position) || Hl(c) && !d && CA(e, c)) ? o = o.filter((m) => m !== c) : i = f, c = Io(c);
  }
  return t.set(e, o), o;
}
function W9(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: i
  } = e;
  const c = [...n === "clippingAncestors" ? Vf(t) ? [] : q9(t, this._c) : [].concat(n), o], f = c[0], d = c.reduce((h, m) => {
    const v = eE(t, m, i);
    return h.top = wn(v.top, h.top), h.right = Lo(v.right, h.right), h.bottom = Lo(v.bottom, h.bottom), h.left = wn(v.left, h.left), h;
  }, eE(t, f, i));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
function X9(e) {
  const {
    width: t,
    height: n
  } = EA(e);
  return {
    width: t,
    height: n
  };
}
function K9(e, t, n) {
  const o = vr(t), i = br(t), l = n === "fixed", c = Sa(e, !0, l, t);
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = mr(0);
  function h() {
    d.x = Bf(i);
  }
  if (o || !o && !l)
    if ((Ji(t) !== "body" || Hl(i)) && (f = Uf(t)), o) {
      const x = Sa(t, !0, l, t);
      d.x = x.x + t.clientLeft, d.y = x.y + t.clientTop;
    } else i && h();
  l && !o && i && h();
  const m = i && !o && !l ? TA(i, f) : mr(0), v = c.left + f.scrollLeft - d.x - m.x, b = c.top + f.scrollTop - d.y - m.y;
  return {
    x: v,
    y: b,
    width: c.width,
    height: c.height
  };
}
function lm(e) {
  return tr(e).position === "static";
}
function tE(e, t) {
  if (!vr(e) || tr(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return br(e) === n && (n = n.ownerDocument.body), n;
}
function AA(e, t) {
  const n = En(e);
  if (Vf(e))
    return n;
  if (!vr(e)) {
    let i = Io(e);
    for (; i && !Bi(i); ) {
      if (er(i) && !lm(i))
        return i;
      i = Io(i);
    }
    return n;
  }
  let o = tE(e, t);
  for (; o && O9(o) && lm(o); )
    o = tE(o, t);
  return o && Bi(o) && lm(o) && !bv(o) ? n : o || I9(e) || n;
}
const J9 = async function(e) {
  const t = this.getOffsetParent || AA, n = this.getDimensions, o = await n(e.floating);
  return {
    reference: K9(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function Q9(e) {
  return tr(e).direction === "rtl";
}
const e$ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: $9,
  getDocumentElement: br,
  getClippingRect: W9,
  getOffsetParent: AA,
  getElementRects: J9,
  getClientRects: H9,
  getDimensions: X9,
  getScale: ji,
  isElement: er,
  isRTL: Q9
};
function RA(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function t$(e, t) {
  let n = null, o;
  const i = br(e);
  function l() {
    var f;
    clearTimeout(o), (f = n) == null || f.disconnect(), n = null;
  }
  function c(f, d) {
    f === void 0 && (f = !1), d === void 0 && (d = 1), l();
    const h = e.getBoundingClientRect(), {
      left: m,
      top: v,
      width: b,
      height: x
    } = h;
    if (f || t(), !b || !x)
      return;
    const E = Au(v), w = Au(i.clientWidth - (m + b)), C = Au(i.clientHeight - (v + x)), A = Au(m), T = {
      rootMargin: -E + "px " + -w + "px " + -C + "px " + -A + "px",
      threshold: wn(0, Lo(1, d)) || 1
    };
    let D = !0;
    function O(k) {
      const R = k[0].intersectionRatio;
      if (R !== d) {
        if (!D)
          return c();
        R ? c(!1, R) : o = setTimeout(() => {
          c(!1, 1e-7);
        }, 1e3);
      }
      R === 1 && !RA(h, e.getBoundingClientRect()) && c(), D = !1;
    }
    try {
      n = new IntersectionObserver(O, {
        ...T,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(O, T);
    }
    n.observe(e);
  }
  return c(!0), l;
}
function n$(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: l = !0,
    elementResize: c = typeof ResizeObserver == "function",
    layoutShift: f = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = o, h = Sv(e), m = i || l ? [...h ? Rl(h) : [], ...Rl(t)] : [];
  m.forEach((A) => {
    i && A.addEventListener("scroll", n, {
      passive: !0
    }), l && A.addEventListener("resize", n);
  });
  const v = h && f ? t$(h, n) : null;
  let b = -1, x = null;
  c && (x = new ResizeObserver((A) => {
    let [M] = A;
    M && M.target === h && x && (x.unobserve(t), cancelAnimationFrame(b), b = requestAnimationFrame(() => {
      var T;
      (T = x) == null || T.observe(t);
    })), n();
  }), h && !d && x.observe(h), x.observe(t));
  let E, w = d ? Sa(e) : null;
  d && C();
  function C() {
    const A = Sa(e);
    w && !RA(w, A) && n(), w = A, E = requestAnimationFrame(C);
  }
  return n(), () => {
    var A;
    m.forEach((M) => {
      i && M.removeEventListener("scroll", n), l && M.removeEventListener("resize", n);
    }), v?.(), (A = x) == null || A.disconnect(), x = null, d && cancelAnimationFrame(E);
  };
}
const r$ = A9, o$ = R9, a$ = _9, i$ = z9, s$ = T9, nE = E9, l$ = M9, c$ = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), i = {
    platform: e$,
    ...n
  }, l = {
    ...i.platform,
    _c: o
  };
  return w9(e, t, {
    ...i,
    platform: l
  });
};
var u$ = typeof document < "u", f$ = function() {
}, Bu = u$ ? y.useLayoutEffect : f$;
function hf(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, o, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (o = n; o-- !== 0; )
        if (!hf(e[o], t[o]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[o]))
        return !1;
    for (o = n; o-- !== 0; ) {
      const l = i[o];
      if (!(l === "_owner" && e.$$typeof) && !hf(e[l], t[l]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function MA(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function rE(e, t) {
  const n = MA(e);
  return Math.round(t * n) / n;
}
function cm(e) {
  const t = y.useRef(e);
  return Bu(() => {
    t.current = e;
  }), t;
}
function d$(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: i,
    elements: {
      reference: l,
      floating: c
    } = {},
    transform: f = !0,
    whileElementsMounted: d,
    open: h
  } = e, [m, v] = y.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [b, x] = y.useState(o);
  hf(b, o) || x(o);
  const [E, w] = y.useState(null), [C, A] = y.useState(null), M = y.useCallback((U) => {
    U !== k.current && (k.current = U, w(U));
  }, []), T = y.useCallback((U) => {
    U !== R.current && (R.current = U, A(U));
  }, []), D = l || E, O = c || C, k = y.useRef(null), R = y.useRef(null), N = y.useRef(m), P = d != null, Y = cm(d), ne = cm(i), J = cm(h), ce = y.useCallback(() => {
    if (!k.current || !R.current)
      return;
    const U = {
      placement: t,
      strategy: n,
      middleware: b
    };
    ne.current && (U.platform = ne.current), c$(k.current, R.current, U).then((te) => {
      const he = {
        ...te,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: J.current !== !1
      };
      ue.current && !hf(N.current, he) && (N.current = he, Vo.flushSync(() => {
        v(he);
      }));
    });
  }, [b, t, n, ne, J]);
  Bu(() => {
    h === !1 && N.current.isPositioned && (N.current.isPositioned = !1, v((U) => ({
      ...U,
      isPositioned: !1
    })));
  }, [h]);
  const ue = y.useRef(!1);
  Bu(() => (ue.current = !0, () => {
    ue.current = !1;
  }), []), Bu(() => {
    if (D && (k.current = D), O && (R.current = O), D && O) {
      if (Y.current)
        return Y.current(D, O, ce);
      ce();
    }
  }, [D, O, ce, Y, P]);
  const de = y.useMemo(() => ({
    reference: k,
    floating: R,
    setReference: M,
    setFloating: T
  }), [M, T]), I = y.useMemo(() => ({
    reference: D,
    floating: O
  }), [D, O]), G = y.useMemo(() => {
    const U = {
      position: n,
      left: 0,
      top: 0
    };
    if (!I.floating)
      return U;
    const te = rE(I.floating, m.x), he = rE(I.floating, m.y);
    return f ? {
      ...U,
      transform: "translate(" + te + "px, " + he + "px)",
      ...MA(I.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: te,
      top: he
    };
  }, [n, f, I.floating, m.x, m.y]);
  return y.useMemo(() => ({
    ...m,
    update: ce,
    refs: de,
    elements: I,
    floatingStyles: G
  }), [m, ce, de, I, G]);
}
const h$ = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: o,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return o && t(o) ? o.current != null ? nE({
        element: o.current,
        padding: i
      }).fn(n) : {} : o ? nE({
        element: o,
        padding: i
      }).fn(n) : {};
    }
  };
}, p$ = (e, t) => ({
  ...r$(e),
  options: [e, t]
}), m$ = (e, t) => ({
  ...o$(e),
  options: [e, t]
}), g$ = (e, t) => ({
  ...l$(e),
  options: [e, t]
}), v$ = (e, t) => ({
  ...a$(e),
  options: [e, t]
}), y$ = (e, t) => ({
  ...i$(e),
  options: [e, t]
}), b$ = (e, t) => ({
  ...s$(e),
  options: [e, t]
}), x$ = (e, t) => ({
  ...h$(e),
  options: [e, t]
});
var S$ = "Arrow", zA = y.forwardRef((e, t) => {
  const { children: n, width: o = 10, height: i = 5, ...l } = e;
  return /* @__PURE__ */ S.jsx(
    ze.svg,
    {
      ...l,
      ref: t,
      width: o,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ S.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
zA.displayName = S$;
var w$ = zA;
function DA(e) {
  const [t, n] = y.useState(void 0);
  return Ht(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const o = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const l = i[0];
        let c, f;
        if ("borderBoxSize" in l) {
          const d = l.borderBoxSize, h = Array.isArray(d) ? d[0] : d;
          c = h.inlineSize, f = h.blockSize;
        } else
          c = e.offsetWidth, f = e.offsetHeight;
        n({ width: c, height: f });
      });
      return o.observe(e, { box: "border-box" }), () => o.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var wv = "Popper", [NA, Qi] = yr(wv), [E$, OA] = NA(wv), jA = (e) => {
  const { __scopePopper: t, children: n } = e, [o, i] = y.useState(null);
  return /* @__PURE__ */ S.jsx(E$, { scope: t, anchor: o, onAnchorChange: i, children: n });
};
jA.displayName = wv;
var kA = "PopperAnchor", PA = y.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: o, ...i } = e, l = OA(kA, n), c = y.useRef(null), f = Le(t, c), d = y.useRef(null);
    return y.useEffect(() => {
      const h = d.current;
      d.current = o?.current || c.current, h !== d.current && l.onAnchorChange(d.current);
    }), o ? null : /* @__PURE__ */ S.jsx(ze.div, { ...i, ref: f });
  }
);
PA.displayName = kA;
var Ev = "PopperContent", [_$, T$] = NA(Ev), LA = y.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: o = "bottom",
      sideOffset: i = 0,
      align: l = "center",
      alignOffset: c = 0,
      arrowPadding: f = 0,
      avoidCollisions: d = !0,
      collisionBoundary: h = [],
      collisionPadding: m = 0,
      sticky: v = "partial",
      hideWhenDetached: b = !1,
      updatePositionStrategy: x = "optimized",
      onPlaced: E,
      ...w
    } = e, C = OA(Ev, n), [A, M] = y.useState(null), T = Le(t, (H) => M(H)), [D, O] = y.useState(null), k = DA(D), R = k?.width ?? 0, N = k?.height ?? 0, P = o + (l !== "center" ? "-" + l : ""), Y = typeof m == "number" ? m : { top: 0, right: 0, bottom: 0, left: 0, ...m }, ne = Array.isArray(h) ? h : [h], J = ne.length > 0, ce = {
      padding: Y,
      boundary: ne.filter(A$),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: J
    }, { refs: ue, floatingStyles: de, placement: I, isPositioned: G, middlewareData: U } = d$({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: P,
      whileElementsMounted: (...H) => n$(...H, {
        animationFrame: x === "always"
      }),
      elements: {
        reference: C.anchor
      },
      middleware: [
        p$({ mainAxis: i + N, alignmentAxis: c }),
        d && m$({
          mainAxis: !0,
          crossAxis: !1,
          limiter: v === "partial" ? g$() : void 0,
          ...ce
        }),
        d && v$({ ...ce }),
        y$({
          ...ce,
          apply: ({ elements: H, rects: re, availableWidth: le, availableHeight: fe }) => {
            const { width: me, height: Re } = re.reference, je = H.floating.style;
            je.setProperty("--radix-popper-available-width", `${le}px`), je.setProperty("--radix-popper-available-height", `${fe}px`), je.setProperty("--radix-popper-anchor-width", `${me}px`), je.setProperty("--radix-popper-anchor-height", `${Re}px`);
          }
        }),
        D && x$({ element: D, padding: f }),
        R$({ arrowWidth: R, arrowHeight: N }),
        b && b$({ strategy: "referenceHidden", ...ce })
      ]
    }), [te, he] = UA(I), j = $t(E);
    Ht(() => {
      G && j?.();
    }, [G, j]);
    const W = U.arrow?.x, $ = U.arrow?.y, X = U.arrow?.centerOffset !== 0, [se, ie] = y.useState();
    return Ht(() => {
      A && ie(window.getComputedStyle(A).zIndex);
    }, [A]), /* @__PURE__ */ S.jsx(
      "div",
      {
        ref: ue.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...de,
          transform: G ? de.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: se,
          "--radix-popper-transform-origin": [
            U.transformOrigin?.x,
            U.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...U.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ S.jsx(
          _$,
          {
            scope: n,
            placedSide: te,
            onArrowChange: O,
            arrowX: W,
            arrowY: $,
            shouldHideArrow: X,
            children: /* @__PURE__ */ S.jsx(
              ze.div,
              {
                "data-side": te,
                "data-align": he,
                ...w,
                ref: T,
                style: {
                  ...w.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: G ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
LA.displayName = Ev;
var IA = "PopperArrow", C$ = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, VA = y.forwardRef(function(t, n) {
  const { __scopePopper: o, ...i } = t, l = T$(IA, o), c = C$[l.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ S.jsx(
      "span",
      {
        ref: l.onArrowChange,
        style: {
          position: "absolute",
          left: l.arrowX,
          top: l.arrowY,
          [c]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[l.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[l.placedSide],
          visibility: l.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ S.jsx(
          w$,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
VA.displayName = IA;
function A$(e) {
  return e !== null;
}
var R$ = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: o, middlewareData: i } = t, c = i.arrow?.centerOffset !== 0, f = c ? 0 : e.arrowWidth, d = c ? 0 : e.arrowHeight, [h, m] = UA(n), v = { start: "0%", center: "50%", end: "100%" }[m], b = (i.arrow?.x ?? 0) + f / 2, x = (i.arrow?.y ?? 0) + d / 2;
    let E = "", w = "";
    return h === "bottom" ? (E = c ? v : `${b}px`, w = `${-d}px`) : h === "top" ? (E = c ? v : `${b}px`, w = `${o.floating.height + d}px`) : h === "right" ? (E = `${-d}px`, w = c ? v : `${x}px`) : h === "left" && (E = `${o.floating.width + d}px`, w = c ? v : `${x}px`), { data: { x: E, y: w } };
  }
});
function UA(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var _v = jA, Tv = PA, Cv = LA, Av = VA, M$ = "Portal", Zl = y.forwardRef((e, t) => {
  const { container: n, ...o } = e, [i, l] = y.useState(!1);
  Ht(() => l(!0), []);
  const c = n || i && globalThis?.document?.body;
  return c ? hO.createPortal(/* @__PURE__ */ S.jsx(ze.div, { ...o, ref: t }), c) : null;
});
Zl.displayName = M$;
function z$(e, t) {
  return y.useReducer((n, o) => t[n][o] ?? n, e);
}
var cn = (e) => {
  const { present: t, children: n } = e, o = D$(t), i = typeof n == "function" ? n({ present: o.isPresent }) : y.Children.only(n), l = Le(o.ref, N$(i));
  return typeof n == "function" || o.isPresent ? y.cloneElement(i, { ref: l }) : null;
};
cn.displayName = "Presence";
function D$(e) {
  const [t, n] = y.useState(), o = y.useRef(null), i = y.useRef(e), l = y.useRef("none"), c = e ? "mounted" : "unmounted", [f, d] = z$(c, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return y.useEffect(() => {
    const h = Ru(o.current);
    l.current = f === "mounted" ? h : "none";
  }, [f]), Ht(() => {
    const h = o.current, m = i.current;
    if (m !== e) {
      const b = l.current, x = Ru(h);
      e ? d("MOUNT") : x === "none" || h?.display === "none" ? d("UNMOUNT") : d(m && b !== x ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, d]), Ht(() => {
    if (t) {
      let h;
      const m = t.ownerDocument.defaultView ?? window, v = (x) => {
        const w = Ru(o.current).includes(CSS.escape(x.animationName));
        if (x.target === t && w && (d("ANIMATION_END"), !i.current)) {
          const C = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", h = m.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = C);
          });
        }
      }, b = (x) => {
        x.target === t && (l.current = Ru(o.current));
      };
      return t.addEventListener("animationstart", b), t.addEventListener("animationcancel", v), t.addEventListener("animationend", v), () => {
        m.clearTimeout(h), t.removeEventListener("animationstart", b), t.removeEventListener("animationcancel", v), t.removeEventListener("animationend", v);
      };
    } else
      d("ANIMATION_END");
  }, [t, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(f),
    ref: y.useCallback((h) => {
      o.current = h ? getComputedStyle(h) : null, n(h);
    }, [])
  };
}
function Ru(e) {
  return e?.animationName || "none";
}
function N$(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var O$ = /* @__PURE__ */ Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function j$(e) {
  const t = ({ children: n }) => /* @__PURE__ */ S.jsx(S.Fragment, { children: n });
  return t.displayName = `${e}.Slottable`, t.__radixId = O$, t;
}
var k$ = Tf[" useInsertionEffect ".trim().toString()] || Ht;
function wa({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: o
}) {
  const [i, l, c] = P$({
    defaultProp: t,
    onChange: n
  }), f = e !== void 0, d = f ? e : i;
  {
    const m = y.useRef(e !== void 0);
    y.useEffect(() => {
      const v = m.current;
      v !== f && console.warn(
        `${o} is changing from ${v ? "controlled" : "uncontrolled"} to ${f ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), m.current = f;
    }, [f, o]);
  }
  const h = y.useCallback(
    (m) => {
      if (f) {
        const v = L$(m) ? m(e) : m;
        v !== e && c.current?.(v);
      } else
        l(m);
    },
    [f, e, l, c]
  );
  return [d, h];
}
function P$({
  defaultProp: e,
  onChange: t
}) {
  const [n, o] = y.useState(e), i = y.useRef(n), l = y.useRef(t);
  return k$(() => {
    l.current = t;
  }, [t]), y.useEffect(() => {
    i.current !== n && (l.current?.(n), i.current = n);
  }, [n, i]), [n, o, l];
}
function L$(e) {
  return typeof e == "function";
}
var BA = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), I$ = "VisuallyHidden", $A = y.forwardRef(
  (e, t) => /* @__PURE__ */ S.jsx(
    ze.span,
    {
      ...e,
      ref: t,
      style: { ...BA, ...e.style }
    }
  )
);
$A.displayName = I$;
var V$ = $A, [$f] = yr("Tooltip", [
  Qi
]), Hf = Qi(), HA = "TooltipProvider", U$ = 700, fg = "tooltip.open", [B$, Rv] = $f(HA), ZA = (e) => {
  const {
    __scopeTooltip: t,
    delayDuration: n = U$,
    skipDelayDuration: o = 300,
    disableHoverableContent: i = !1,
    children: l
  } = e, c = y.useRef(!0), f = y.useRef(!1), d = y.useRef(0);
  return y.useEffect(() => {
    const h = d.current;
    return () => window.clearTimeout(h);
  }, []), /* @__PURE__ */ S.jsx(
    B$,
    {
      scope: t,
      isOpenDelayedRef: c,
      delayDuration: n,
      onOpen: y.useCallback(() => {
        window.clearTimeout(d.current), c.current = !1;
      }, []),
      onClose: y.useCallback(() => {
        window.clearTimeout(d.current), d.current = window.setTimeout(
          () => c.current = !0,
          o
        );
      }, [o]),
      isPointerInTransitRef: f,
      onPointerInTransitChange: y.useCallback((h) => {
        f.current = h;
      }, []),
      disableHoverableContent: i,
      children: l
    }
  );
};
ZA.displayName = HA;
var Ml = "Tooltip", [$$, Fl] = $f(Ml), FA = (e) => {
  const {
    __scopeTooltip: t,
    children: n,
    open: o,
    defaultOpen: i,
    onOpenChange: l,
    disableHoverableContent: c,
    delayDuration: f
  } = e, d = Rv(Ml, e.__scopeTooltip), h = Hf(t), [m, v] = y.useState(null), b = pr(), x = y.useRef(0), E = c ?? d.disableHoverableContent, w = f ?? d.delayDuration, C = y.useRef(!1), [A, M] = wa({
    prop: o,
    defaultProp: i ?? !1,
    onChange: (R) => {
      R ? (d.onOpen(), document.dispatchEvent(new CustomEvent(fg))) : d.onClose(), l?.(R);
    },
    caller: Ml
  }), T = y.useMemo(() => A ? C.current ? "delayed-open" : "instant-open" : "closed", [A]), D = y.useCallback(() => {
    window.clearTimeout(x.current), x.current = 0, C.current = !1, M(!0);
  }, [M]), O = y.useCallback(() => {
    window.clearTimeout(x.current), x.current = 0, M(!1);
  }, [M]), k = y.useCallback(() => {
    window.clearTimeout(x.current), x.current = window.setTimeout(() => {
      C.current = !0, M(!0), x.current = 0;
    }, w);
  }, [w, M]);
  return y.useEffect(() => () => {
    x.current && (window.clearTimeout(x.current), x.current = 0);
  }, []), /* @__PURE__ */ S.jsx(_v, { ...h, children: /* @__PURE__ */ S.jsx(
    $$,
    {
      scope: t,
      contentId: b,
      open: A,
      stateAttribute: T,
      trigger: m,
      onTriggerChange: v,
      onTriggerEnter: y.useCallback(() => {
        d.isOpenDelayedRef.current ? k() : D();
      }, [d.isOpenDelayedRef, k, D]),
      onTriggerLeave: y.useCallback(() => {
        E ? O() : (window.clearTimeout(x.current), x.current = 0);
      }, [O, E]),
      onOpen: D,
      onClose: O,
      disableHoverableContent: E,
      children: n
    }
  ) });
};
FA.displayName = Ml;
var dg = "TooltipTrigger", GA = y.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...o } = e, i = Fl(dg, n), l = Rv(dg, n), c = Hf(n), f = y.useRef(null), d = Le(t, f, i.onTriggerChange), h = y.useRef(!1), m = y.useRef(!1), v = y.useCallback(() => h.current = !1, []);
    return y.useEffect(() => () => document.removeEventListener("pointerup", v), [v]), /* @__PURE__ */ S.jsx(Tv, { asChild: !0, ...c, children: /* @__PURE__ */ S.jsx(
      ze.button,
      {
        "aria-describedby": i.open ? i.contentId : void 0,
        "data-state": i.stateAttribute,
        ...o,
        ref: d,
        onPointerMove: ge(e.onPointerMove, (b) => {
          b.pointerType !== "touch" && !m.current && !l.isPointerInTransitRef.current && (i.onTriggerEnter(), m.current = !0);
        }),
        onPointerLeave: ge(e.onPointerLeave, () => {
          i.onTriggerLeave(), m.current = !1;
        }),
        onPointerDown: ge(e.onPointerDown, () => {
          i.open && i.onClose(), h.current = !0, document.addEventListener("pointerup", v, { once: !0 });
        }),
        onFocus: ge(e.onFocus, () => {
          h.current || i.onOpen();
        }),
        onBlur: ge(e.onBlur, i.onClose),
        onClick: ge(e.onClick, i.onClose)
      }
    ) });
  }
);
GA.displayName = dg;
var Mv = "TooltipPortal", [H$, Z$] = $f(Mv, {
  forceMount: void 0
}), YA = (e) => {
  const { __scopeTooltip: t, forceMount: n, children: o, container: i } = e, l = Fl(Mv, t);
  return /* @__PURE__ */ S.jsx(H$, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(cn, { present: n || l.open, children: /* @__PURE__ */ S.jsx(Zl, { asChild: !0, container: i, children: o }) }) });
};
YA.displayName = Mv;
var $i = "TooltipContent", qA = y.forwardRef(
  (e, t) => {
    const n = Z$($i, e.__scopeTooltip), { forceMount: o = n.forceMount, side: i = "top", ...l } = e, c = Fl($i, e.__scopeTooltip);
    return /* @__PURE__ */ S.jsx(cn, { present: o || c.open, children: c.disableHoverableContent ? /* @__PURE__ */ S.jsx(WA, { side: i, ...l, ref: t }) : /* @__PURE__ */ S.jsx(F$, { side: i, ...l, ref: t }) });
  }
), F$ = y.forwardRef((e, t) => {
  const n = Fl($i, e.__scopeTooltip), o = Rv($i, e.__scopeTooltip), i = y.useRef(null), l = Le(t, i), [c, f] = y.useState(null), { trigger: d, onClose: h } = n, m = i.current, { onPointerInTransitChange: v } = o, b = y.useCallback(() => {
    f(null), v(!1);
  }, [v]), x = y.useCallback(
    (E, w) => {
      const C = E.currentTarget, A = { x: E.clientX, y: E.clientY }, M = W$(A, C.getBoundingClientRect()), T = X$(A, M), D = K$(w.getBoundingClientRect()), O = Q$([...T, ...D]);
      f(O), v(!0);
    },
    [v]
  );
  return y.useEffect(() => () => b(), [b]), y.useEffect(() => {
    if (d && m) {
      const E = (C) => x(C, m), w = (C) => x(C, d);
      return d.addEventListener("pointerleave", E), m.addEventListener("pointerleave", w), () => {
        d.removeEventListener("pointerleave", E), m.removeEventListener("pointerleave", w);
      };
    }
  }, [d, m, x, b]), y.useEffect(() => {
    if (c) {
      const E = (w) => {
        const C = w.target, A = { x: w.clientX, y: w.clientY }, M = d?.contains(C) || m?.contains(C), T = !J$(A, c);
        M ? b() : T && (b(), h());
      };
      return document.addEventListener("pointermove", E), () => document.removeEventListener("pointermove", E);
    }
  }, [d, m, c, h, b]), /* @__PURE__ */ S.jsx(WA, { ...e, ref: l });
}), [G$, Y$] = $f(Ml, { isInside: !1 }), q$ = /* @__PURE__ */ j$("TooltipContent"), WA = y.forwardRef(
  (e, t) => {
    const {
      __scopeTooltip: n,
      children: o,
      "aria-label": i,
      onEscapeKeyDown: l,
      onPointerDownOutside: c,
      ...f
    } = e, d = Fl($i, n), h = Hf(n), { onClose: m } = d;
    return y.useEffect(() => (document.addEventListener(fg, m), () => document.removeEventListener(fg, m)), [m]), y.useEffect(() => {
      if (d.trigger) {
        const v = (b) => {
          b.target?.contains(d.trigger) && m();
        };
        return window.addEventListener("scroll", v, { capture: !0 }), () => window.removeEventListener("scroll", v, { capture: !0 });
      }
    }, [d.trigger, m]), /* @__PURE__ */ S.jsx(
      $l,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: l,
        onPointerDownOutside: c,
        onFocusOutside: (v) => v.preventDefault(),
        onDismiss: m,
        children: /* @__PURE__ */ S.jsxs(
          Cv,
          {
            "data-state": d.stateAttribute,
            ...h,
            ...f,
            ref: t,
            style: {
              ...f.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ S.jsx(q$, { children: o }),
              /* @__PURE__ */ S.jsx(G$, { scope: n, isInside: !0, children: /* @__PURE__ */ S.jsx(V$, { id: d.contentId, role: "tooltip", children: i || o }) })
            ]
          }
        )
      }
    );
  }
);
qA.displayName = $i;
var XA = "TooltipArrow", KA = y.forwardRef(
  (e, t) => {
    const { __scopeTooltip: n, ...o } = e, i = Hf(n);
    return Y$(
      XA,
      n
    ).isInside ? null : /* @__PURE__ */ S.jsx(Av, { ...i, ...o, ref: t });
  }
);
KA.displayName = XA;
function W$(e, t) {
  const n = Math.abs(t.top - e.y), o = Math.abs(t.bottom - e.y), i = Math.abs(t.right - e.x), l = Math.abs(t.left - e.x);
  switch (Math.min(n, o, i, l)) {
    case l:
      return "left";
    case i:
      return "right";
    case n:
      return "top";
    case o:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function X$(e, t, n = 5) {
  const o = [];
  switch (t) {
    case "top":
      o.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      o.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      o.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      o.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return o;
}
function K$(e) {
  const { top: t, right: n, bottom: o, left: i } = e;
  return [
    { x: i, y: t },
    { x: n, y: t },
    { x: n, y: o },
    { x: i, y: o }
  ];
}
function J$(e, t) {
  const { x: n, y: o } = e;
  let i = !1;
  for (let l = 0, c = t.length - 1; l < t.length; c = l++) {
    const f = t[l], d = t[c], h = f.x, m = f.y, v = d.x, b = d.y;
    m > o != b > o && n < (v - h) * (o - m) / (b - m) + h && (i = !i);
  }
  return i;
}
function Q$(e) {
  const t = e.slice();
  return t.sort((n, o) => n.x < o.x ? -1 : n.x > o.x ? 1 : n.y < o.y ? -1 : n.y > o.y ? 1 : 0), eH(t);
}
function eH(e) {
  if (e.length <= 1) return e.slice();
  const t = [];
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    for (; t.length >= 2; ) {
      const l = t[t.length - 1], c = t[t.length - 2];
      if ((l.x - c.x) * (i.y - c.y) >= (l.y - c.y) * (i.x - c.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  t.pop();
  const n = [];
  for (let o = e.length - 1; o >= 0; o--) {
    const i = e[o];
    for (; n.length >= 2; ) {
      const l = n[n.length - 1], c = n[n.length - 2];
      if ((l.x - c.x) * (i.y - c.y) >= (l.y - c.y) * (i.x - c.x)) n.pop();
      else break;
    }
    n.push(i);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
var tH = ZA, nH = FA, rH = GA, oH = YA, aH = qA, iH = KA;
function zv({
  delayDuration: e = 0,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    tH,
    {
      "data-slot": "tooltip-provider",
      delayDuration: e,
      ...t
    }
  );
}
function il({ ...e }) {
  return /* @__PURE__ */ S.jsx(zv, { children: /* @__PURE__ */ S.jsx(nH, { "data-slot": "tooltip", ...e }) });
}
function sl({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(rH, { "data-slot": "tooltip-trigger", ...e });
}
function ll({
  className: e,
  sideOffset: t = 0,
  hasArrow: n = !1,
  children: o,
  ...i
}) {
  return /* @__PURE__ */ S.jsx(oH, { children: /* @__PURE__ */ S.jsxs(
    aH,
    {
      "data-slot": "tooltip-content",
      sideOffset: t,
      className: Ge(
        "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        e
      ),
      ...i,
      children: [
        o,
        /* @__PURE__ */ S.jsx(
          iH,
          {
            className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] opacity-0 bg-transparent"
          }
        )
      ]
    }
  ) });
}
const sH = rA(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function JA({
  className: e,
  variant: t,
  asChild: n = !1,
  ...o
}) {
  const i = n ? eA : "span";
  return /* @__PURE__ */ S.jsx(
    i,
    {
      "data-slot": "badge",
      className: Ge(sH({ variant: t }), e),
      ...o
    }
  );
}
var um = "focusScope.autoFocusOnMount", fm = "focusScope.autoFocusOnUnmount", oE = { bubbles: !1, cancelable: !0 }, lH = "FocusScope", Zf = y.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: o = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: l,
    ...c
  } = e, [f, d] = y.useState(null), h = $t(i), m = $t(l), v = y.useRef(null), b = Le(t, (w) => d(w)), x = y.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  y.useEffect(() => {
    if (o) {
      let w = function(T) {
        if (x.paused || !f) return;
        const D = T.target;
        f.contains(D) ? v.current = D : Co(v.current, { select: !0 });
      }, C = function(T) {
        if (x.paused || !f) return;
        const D = T.relatedTarget;
        D !== null && (f.contains(D) || Co(v.current, { select: !0 }));
      }, A = function(T) {
        if (document.activeElement === document.body)
          for (const O of T)
            O.removedNodes.length > 0 && Co(f);
      };
      document.addEventListener("focusin", w), document.addEventListener("focusout", C);
      const M = new MutationObserver(A);
      return f && M.observe(f, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", w), document.removeEventListener("focusout", C), M.disconnect();
      };
    }
  }, [o, f, x.paused]), y.useEffect(() => {
    if (f) {
      iE.add(x);
      const w = document.activeElement;
      if (!f.contains(w)) {
        const A = new CustomEvent(um, oE);
        f.addEventListener(um, h), f.dispatchEvent(A), A.defaultPrevented || (cH(pH(QA(f)), { select: !0 }), document.activeElement === w && Co(f));
      }
      return () => {
        f.removeEventListener(um, h), setTimeout(() => {
          const A = new CustomEvent(fm, oE);
          f.addEventListener(fm, m), f.dispatchEvent(A), A.defaultPrevented || Co(w ?? document.body, { select: !0 }), f.removeEventListener(fm, m), iE.remove(x);
        }, 0);
      };
    }
  }, [f, h, m, x]);
  const E = y.useCallback(
    (w) => {
      if (!n && !o || x.paused) return;
      const C = w.key === "Tab" && !w.altKey && !w.ctrlKey && !w.metaKey, A = document.activeElement;
      if (C && A) {
        const M = w.currentTarget, [T, D] = uH(M);
        T && D ? !w.shiftKey && A === D ? (w.preventDefault(), n && Co(T, { select: !0 })) : w.shiftKey && A === T && (w.preventDefault(), n && Co(D, { select: !0 })) : A === M && w.preventDefault();
      }
    },
    [n, o, x.paused]
  );
  return /* @__PURE__ */ S.jsx(ze.div, { tabIndex: -1, ...c, ref: b, onKeyDown: E });
});
Zf.displayName = lH;
function cH(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const o of e)
    if (Co(o, { select: t }), document.activeElement !== n) return;
}
function uH(e) {
  const t = QA(e), n = aE(t, e), o = aE(t.reverse(), e);
  return [n, o];
}
function QA(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const i = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || i ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function aE(e, t) {
  for (const n of e)
    if (!fH(n, { upTo: t })) return n;
}
function fH(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function dH(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Co(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && dH(e) && t && e.select();
  }
}
var iE = hH();
function hH() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = sE(e, t), e.unshift(t);
    },
    remove(t) {
      e = sE(e, t), e[0]?.resume();
    }
  };
}
function sE(e, t) {
  const n = [...e], o = n.indexOf(t);
  return o !== -1 && n.splice(o, 1), n;
}
function pH(e) {
  return e.filter((t) => t.tagName !== "A");
}
var dm = 0;
function Dv() {
  y.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? lE()), document.body.insertAdjacentElement("beforeend", e[1] ?? lE()), dm++, () => {
      dm === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), dm--;
    };
  }, []);
}
function lE() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var fr = function() {
  return fr = Object.assign || function(t) {
    for (var n, o = 1, i = arguments.length; o < i; o++) {
      n = arguments[o];
      for (var l in n) Object.prototype.hasOwnProperty.call(n, l) && (t[l] = n[l]);
    }
    return t;
  }, fr.apply(this, arguments);
};
function eR(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, o = Object.getOwnPropertySymbols(e); i < o.length; i++)
      t.indexOf(o[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[i]) && (n[o[i]] = e[o[i]]);
  return n;
}
function mH(e, t, n) {
  if (n || arguments.length === 2) for (var o = 0, i = t.length, l; o < i; o++)
    (l || !(o in t)) && (l || (l = Array.prototype.slice.call(t, 0, o)), l[o] = t[o]);
  return e.concat(l || Array.prototype.slice.call(t));
}
var $u = "right-scroll-bar-position", Hu = "width-before-scroll-bar", gH = "with-scroll-bars-hidden", vH = "--removed-body-scroll-bar-size";
function hm(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function yH(e, t) {
  var n = y.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(o) {
          var i = n.value;
          i !== o && (n.value = o, n.callback(o, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var bH = typeof window < "u" ? y.useLayoutEffect : y.useEffect, cE = /* @__PURE__ */ new WeakMap();
function xH(e, t) {
  var n = yH(null, function(o) {
    return e.forEach(function(i) {
      return hm(i, o);
    });
  });
  return bH(function() {
    var o = cE.get(n);
    if (o) {
      var i = new Set(o), l = new Set(e), c = n.current;
      i.forEach(function(f) {
        l.has(f) || hm(f, null);
      }), l.forEach(function(f) {
        i.has(f) || hm(f, c);
      });
    }
    cE.set(n, e);
  }, [e]), n;
}
function SH(e) {
  return e;
}
function wH(e, t) {
  t === void 0 && (t = SH);
  var n = [], o = !1, i = {
    read: function() {
      if (o)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(l) {
      var c = t(l, o);
      return n.push(c), function() {
        n = n.filter(function(f) {
          return f !== c;
        });
      };
    },
    assignSyncMedium: function(l) {
      for (o = !0; n.length; ) {
        var c = n;
        n = [], c.forEach(l);
      }
      n = {
        push: function(f) {
          return l(f);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(l) {
      o = !0;
      var c = [];
      if (n.length) {
        var f = n;
        n = [], f.forEach(l), c = n;
      }
      var d = function() {
        var m = c;
        c = [], m.forEach(l);
      }, h = function() {
        return Promise.resolve().then(d);
      };
      h(), n = {
        push: function(m) {
          c.push(m), h();
        },
        filter: function(m) {
          return c = c.filter(m), n;
        }
      };
    }
  };
  return i;
}
function EH(e) {
  e === void 0 && (e = {});
  var t = wH(null);
  return t.options = fr({ async: !0, ssr: !1 }, e), t;
}
var tR = function(e) {
  var t = e.sideCar, n = eR(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var o = t.read();
  if (!o)
    throw new Error("Sidecar medium not found");
  return y.createElement(o, fr({}, n));
};
tR.isSideCarExport = !0;
function _H(e, t) {
  return e.useMedium(t), tR;
}
var nR = EH(), pm = function() {
}, Ff = y.forwardRef(function(e, t) {
  var n = y.useRef(null), o = y.useState({
    onScrollCapture: pm,
    onWheelCapture: pm,
    onTouchMoveCapture: pm
  }), i = o[0], l = o[1], c = e.forwardProps, f = e.children, d = e.className, h = e.removeScrollBar, m = e.enabled, v = e.shards, b = e.sideCar, x = e.noRelative, E = e.noIsolation, w = e.inert, C = e.allowPinchZoom, A = e.as, M = A === void 0 ? "div" : A, T = e.gapMode, D = eR(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), O = b, k = xH([n, t]), R = fr(fr({}, D), i);
  return y.createElement(
    y.Fragment,
    null,
    m && y.createElement(O, { sideCar: nR, removeScrollBar: h, shards: v, noRelative: x, noIsolation: E, inert: w, setCallbacks: l, allowPinchZoom: !!C, lockRef: n, gapMode: T }),
    c ? y.cloneElement(y.Children.only(f), fr(fr({}, R), { ref: k })) : y.createElement(M, fr({}, R, { className: d, ref: k }), f)
  );
});
Ff.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Ff.classNames = {
  fullWidth: Hu,
  zeroRight: $u
};
var TH = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function CH() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = TH();
  return t && e.setAttribute("nonce", t), e;
}
function AH(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function RH(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var MH = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = CH()) && (AH(t, n), RH(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, zH = function() {
  var e = MH();
  return function(t, n) {
    y.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, rR = function() {
  var e = zH(), t = function(n) {
    var o = n.styles, i = n.dynamic;
    return e(o, i), null;
  };
  return t;
}, DH = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, mm = function(e) {
  return parseInt(e || "", 10) || 0;
}, NH = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], o = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [mm(n), mm(o), mm(i)];
}, OH = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return DH;
  var t = NH(e), n = document.documentElement.clientWidth, o = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, o - n + t[2] - t[0])
  };
}, jH = rR(), ki = "data-scroll-locked", kH = function(e, t, n, o) {
  var i = e.left, l = e.top, c = e.right, f = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(gH, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(f, "px ").concat(o, `;
  }
  body[`).concat(ki, `] {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(o, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(l, `px;
    padding-right: `).concat(c, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(o, `;
    `),
    n === "padding" && "padding-right: ".concat(f, "px ").concat(o, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat($u, ` {
    right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(Hu, ` {
    margin-right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat($u, " .").concat($u, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(Hu, " .").concat(Hu, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body[`).concat(ki, `] {
    `).concat(vH, ": ").concat(f, `px;
  }
`);
}, uE = function() {
  var e = parseInt(document.body.getAttribute(ki) || "0", 10);
  return isFinite(e) ? e : 0;
}, PH = function() {
  y.useEffect(function() {
    return document.body.setAttribute(ki, (uE() + 1).toString()), function() {
      var e = uE() - 1;
      e <= 0 ? document.body.removeAttribute(ki) : document.body.setAttribute(ki, e.toString());
    };
  }, []);
}, LH = function(e) {
  var t = e.noRelative, n = e.noImportant, o = e.gapMode, i = o === void 0 ? "margin" : o;
  PH();
  var l = y.useMemo(function() {
    return OH(i);
  }, [i]);
  return y.createElement(jH, { styles: kH(l, !t, i, n ? "" : "!important") });
}, hg = !1;
if (typeof window < "u")
  try {
    var Mu = Object.defineProperty({}, "passive", {
      get: function() {
        return hg = !0, !0;
      }
    });
    window.addEventListener("test", Mu, Mu), window.removeEventListener("test", Mu, Mu);
  } catch {
    hg = !1;
  }
var yi = hg ? { passive: !1 } : !1, IH = function(e) {
  return e.tagName === "TEXTAREA";
}, oR = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !IH(e) && n[t] === "visible")
  );
}, VH = function(e) {
  return oR(e, "overflowY");
}, UH = function(e) {
  return oR(e, "overflowX");
}, fE = function(e, t) {
  var n = t.ownerDocument, o = t;
  do {
    typeof ShadowRoot < "u" && o instanceof ShadowRoot && (o = o.host);
    var i = aR(e, o);
    if (i) {
      var l = iR(e, o), c = l[1], f = l[2];
      if (c > f)
        return !0;
    }
    o = o.parentNode;
  } while (o && o !== n.body);
  return !1;
}, BH = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, o = e.clientHeight;
  return [
    t,
    n,
    o
  ];
}, $H = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, o = e.clientWidth;
  return [
    t,
    n,
    o
  ];
}, aR = function(e, t) {
  return e === "v" ? VH(t) : UH(t);
}, iR = function(e, t) {
  return e === "v" ? BH(t) : $H(t);
}, HH = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, ZH = function(e, t, n, o, i) {
  var l = HH(e, window.getComputedStyle(t).direction), c = l * o, f = n.target, d = t.contains(f), h = !1, m = c > 0, v = 0, b = 0;
  do {
    if (!f)
      break;
    var x = iR(e, f), E = x[0], w = x[1], C = x[2], A = w - C - l * E;
    (E || A) && aR(e, f) && (v += A, b += E);
    var M = f.parentNode;
    f = M && M.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? M.host : M;
  } while (
    // portaled content
    !d && f !== document.body || // self content
    d && (t.contains(f) || t === f)
  );
  return (m && Math.abs(v) < 1 || !m && Math.abs(b) < 1) && (h = !0), h;
}, zu = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, dE = function(e) {
  return [e.deltaX, e.deltaY];
}, hE = function(e) {
  return e && "current" in e ? e.current : e;
}, FH = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, GH = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, YH = 0, bi = [];
function qH(e) {
  var t = y.useRef([]), n = y.useRef([0, 0]), o = y.useRef(), i = y.useState(YH++)[0], l = y.useState(rR)[0], c = y.useRef(e);
  y.useEffect(function() {
    c.current = e;
  }, [e]), y.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var w = mH([e.lockRef.current], (e.shards || []).map(hE), !0).filter(Boolean);
      return w.forEach(function(C) {
        return C.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), w.forEach(function(C) {
          return C.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var f = y.useCallback(function(w, C) {
    if ("touches" in w && w.touches.length === 2 || w.type === "wheel" && w.ctrlKey)
      return !c.current.allowPinchZoom;
    var A = zu(w), M = n.current, T = "deltaX" in w ? w.deltaX : M[0] - A[0], D = "deltaY" in w ? w.deltaY : M[1] - A[1], O, k = w.target, R = Math.abs(T) > Math.abs(D) ? "h" : "v";
    if ("touches" in w && R === "h" && k.type === "range")
      return !1;
    var N = window.getSelection(), P = N && N.anchorNode, Y = P ? P === k || P.contains(k) : !1;
    if (Y)
      return !1;
    var ne = fE(R, k);
    if (!ne)
      return !0;
    if (ne ? O = R : (O = R === "v" ? "h" : "v", ne = fE(R, k)), !ne)
      return !1;
    if (!o.current && "changedTouches" in w && (T || D) && (o.current = O), !O)
      return !0;
    var J = o.current || O;
    return ZH(J, C, w, J === "h" ? T : D);
  }, []), d = y.useCallback(function(w) {
    var C = w;
    if (!(!bi.length || bi[bi.length - 1] !== l)) {
      var A = "deltaY" in C ? dE(C) : zu(C), M = t.current.filter(function(O) {
        return O.name === C.type && (O.target === C.target || C.target === O.shadowParent) && FH(O.delta, A);
      })[0];
      if (M && M.should) {
        C.cancelable && C.preventDefault();
        return;
      }
      if (!M) {
        var T = (c.current.shards || []).map(hE).filter(Boolean).filter(function(O) {
          return O.contains(C.target);
        }), D = T.length > 0 ? f(C, T[0]) : !c.current.noIsolation;
        D && C.cancelable && C.preventDefault();
      }
    }
  }, []), h = y.useCallback(function(w, C, A, M) {
    var T = { name: w, delta: C, target: A, should: M, shadowParent: WH(A) };
    t.current.push(T), setTimeout(function() {
      t.current = t.current.filter(function(D) {
        return D !== T;
      });
    }, 1);
  }, []), m = y.useCallback(function(w) {
    n.current = zu(w), o.current = void 0;
  }, []), v = y.useCallback(function(w) {
    h(w.type, dE(w), w.target, f(w, e.lockRef.current));
  }, []), b = y.useCallback(function(w) {
    h(w.type, zu(w), w.target, f(w, e.lockRef.current));
  }, []);
  y.useEffect(function() {
    return bi.push(l), e.setCallbacks({
      onScrollCapture: v,
      onWheelCapture: v,
      onTouchMoveCapture: b
    }), document.addEventListener("wheel", d, yi), document.addEventListener("touchmove", d, yi), document.addEventListener("touchstart", m, yi), function() {
      bi = bi.filter(function(w) {
        return w !== l;
      }), document.removeEventListener("wheel", d, yi), document.removeEventListener("touchmove", d, yi), document.removeEventListener("touchstart", m, yi);
    };
  }, []);
  var x = e.removeScrollBar, E = e.inert;
  return y.createElement(
    y.Fragment,
    null,
    E ? y.createElement(l, { styles: GH(i) }) : null,
    x ? y.createElement(LH, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function WH(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const XH = _H(nR, qH);
var Gf = y.forwardRef(function(e, t) {
  return y.createElement(Ff, fr({}, e, { ref: t, sideCar: XH }));
});
Gf.classNames = Ff.classNames;
var KH = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, xi = /* @__PURE__ */ new WeakMap(), Du = /* @__PURE__ */ new WeakMap(), Nu = {}, gm = 0, sR = function(e) {
  return e && (e.host || sR(e.parentNode));
}, JH = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var o = sR(n);
    return o && e.contains(o) ? o : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, QH = function(e, t, n, o) {
  var i = JH(t, Array.isArray(e) ? e : [e]);
  Nu[n] || (Nu[n] = /* @__PURE__ */ new WeakMap());
  var l = Nu[n], c = [], f = /* @__PURE__ */ new Set(), d = new Set(i), h = function(v) {
    !v || f.has(v) || (f.add(v), h(v.parentNode));
  };
  i.forEach(h);
  var m = function(v) {
    !v || d.has(v) || Array.prototype.forEach.call(v.children, function(b) {
      if (f.has(b))
        m(b);
      else
        try {
          var x = b.getAttribute(o), E = x !== null && x !== "false", w = (xi.get(b) || 0) + 1, C = (l.get(b) || 0) + 1;
          xi.set(b, w), l.set(b, C), c.push(b), w === 1 && E && Du.set(b, !0), C === 1 && b.setAttribute(n, "true"), E || b.setAttribute(o, "true");
        } catch (A) {
          console.error("aria-hidden: cannot operate on ", b, A);
        }
    });
  };
  return m(t), f.clear(), gm++, function() {
    c.forEach(function(v) {
      var b = xi.get(v) - 1, x = l.get(v) - 1;
      xi.set(v, b), l.set(v, x), b || (Du.has(v) || v.removeAttribute(o), Du.delete(v)), x || v.removeAttribute(n);
    }), gm--, gm || (xi = /* @__PURE__ */ new WeakMap(), xi = /* @__PURE__ */ new WeakMap(), Du = /* @__PURE__ */ new WeakMap(), Nu = {});
  };
}, Nv = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var o = Array.from(Array.isArray(e) ? e : [e]), i = KH(e);
  return i ? (o.push.apply(o, Array.from(i.querySelectorAll("[aria-live], script"))), QH(o, i, n, "aria-hidden")) : function() {
    return null;
  };
};
// @__NO_SIDE_EFFECTS__
function e8(e) {
  const t = /* @__PURE__ */ t8(e), n = y.forwardRef((o, i) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(r8);
    if (d) {
      const h = d.props.children, m = f.map((v) => v === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : v);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function t8(e) {
  const t = y.forwardRef((n, o) => {
    const { children: i, ...l } = n;
    if (y.isValidElement(i)) {
      const c = a8(i), f = o8(l, i.props);
      return i.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(i, f);
    }
    return y.Children.count(i) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var n8 = /* @__PURE__ */ Symbol("radix.slottable");
function r8(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === n8;
}
function o8(e, t) {
  const n = { ...t };
  for (const o in t) {
    const i = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? i && l ? n[o] = (...f) => {
      const d = l(...f);
      return i(...f), d;
    } : i && (n[o] = i) : o === "style" ? n[o] = { ...i, ...l } : o === "className" && (n[o] = [i, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function a8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Yf = "Dialog", [lR] = yr(Yf), [i8, nr] = lR(Yf), cR = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: o,
    defaultOpen: i,
    onOpenChange: l,
    modal: c = !0
  } = e, f = y.useRef(null), d = y.useRef(null), [h, m] = wa({
    prop: o,
    defaultProp: i ?? !1,
    onChange: l,
    caller: Yf
  });
  return /* @__PURE__ */ S.jsx(
    i8,
    {
      scope: t,
      triggerRef: f,
      contentRef: d,
      contentId: pr(),
      titleId: pr(),
      descriptionId: pr(),
      open: h,
      onOpenChange: m,
      onOpenToggle: y.useCallback(() => m((v) => !v), [m]),
      modal: c,
      children: n
    }
  );
};
cR.displayName = Yf;
var uR = "DialogTrigger", s8 = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, i = nr(uR, n), l = Le(t, i.triggerRef);
    return /* @__PURE__ */ S.jsx(
      ze.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": kv(i.open),
        ...o,
        ref: l,
        onClick: ge(e.onClick, i.onOpenToggle)
      }
    );
  }
);
s8.displayName = uR;
var Ov = "DialogPortal", [l8, fR] = lR(Ov, {
  forceMount: void 0
}), dR = (e) => {
  const { __scopeDialog: t, forceMount: n, children: o, container: i } = e, l = nr(Ov, t);
  return /* @__PURE__ */ S.jsx(l8, { scope: t, forceMount: n, children: y.Children.map(o, (c) => /* @__PURE__ */ S.jsx(cn, { present: n || l.open, children: /* @__PURE__ */ S.jsx(Zl, { asChild: !0, container: i, children: c }) })) });
};
dR.displayName = Ov;
var pf = "DialogOverlay", hR = y.forwardRef(
  (e, t) => {
    const n = fR(pf, e.__scopeDialog), { forceMount: o = n.forceMount, ...i } = e, l = nr(pf, e.__scopeDialog);
    return l.modal ? /* @__PURE__ */ S.jsx(cn, { present: o || l.open, children: /* @__PURE__ */ S.jsx(u8, { ...i, ref: t }) }) : null;
  }
);
hR.displayName = pf;
var c8 = /* @__PURE__ */ e8("DialogOverlay.RemoveScroll"), u8 = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, i = nr(pf, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ S.jsx(Gf, { as: c8, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ S.jsx(
        ze.div,
        {
          "data-state": kv(i.open),
          ...o,
          ref: t,
          style: { pointerEvents: "auto", ...o.style }
        }
      ) })
    );
  }
), Ea = "DialogContent", pR = y.forwardRef(
  (e, t) => {
    const n = fR(Ea, e.__scopeDialog), { forceMount: o = n.forceMount, ...i } = e, l = nr(Ea, e.__scopeDialog);
    return /* @__PURE__ */ S.jsx(cn, { present: o || l.open, children: l.modal ? /* @__PURE__ */ S.jsx(f8, { ...i, ref: t }) : /* @__PURE__ */ S.jsx(d8, { ...i, ref: t }) });
  }
);
pR.displayName = Ea;
var f8 = y.forwardRef(
  (e, t) => {
    const n = nr(Ea, e.__scopeDialog), o = y.useRef(null), i = Le(t, n.contentRef, o);
    return y.useEffect(() => {
      const l = o.current;
      if (l) return Nv(l);
    }, []), /* @__PURE__ */ S.jsx(
      mR,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: ge(e.onCloseAutoFocus, (l) => {
          l.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: ge(e.onPointerDownOutside, (l) => {
          const c = l.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
          (c.button === 2 || f) && l.preventDefault();
        }),
        onFocusOutside: ge(
          e.onFocusOutside,
          (l) => l.preventDefault()
        )
      }
    );
  }
), d8 = y.forwardRef(
  (e, t) => {
    const n = nr(Ea, e.__scopeDialog), o = y.useRef(!1), i = y.useRef(!1);
    return /* @__PURE__ */ S.jsx(
      mR,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (l) => {
          e.onCloseAutoFocus?.(l), l.defaultPrevented || (o.current || n.triggerRef.current?.focus(), l.preventDefault()), o.current = !1, i.current = !1;
        },
        onInteractOutside: (l) => {
          e.onInteractOutside?.(l), l.defaultPrevented || (o.current = !0, l.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const c = l.target;
          n.triggerRef.current?.contains(c) && l.preventDefault(), l.detail.originalEvent.type === "focusin" && i.current && l.preventDefault();
        }
      }
    );
  }
), mR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: o, onOpenAutoFocus: i, onCloseAutoFocus: l, ...c } = e, f = nr(Ea, n), d = y.useRef(null), h = Le(t, d);
    return Dv(), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        Zf,
        {
          asChild: !0,
          loop: !0,
          trapped: o,
          onMountAutoFocus: i,
          onUnmountAutoFocus: l,
          children: /* @__PURE__ */ S.jsx(
            $l,
            {
              role: "dialog",
              id: f.contentId,
              "aria-describedby": f.descriptionId,
              "aria-labelledby": f.titleId,
              "data-state": kv(f.open),
              ...c,
              ref: h,
              onDismiss: () => f.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(h8, { titleId: f.titleId }),
        /* @__PURE__ */ S.jsx(m8, { contentRef: d, descriptionId: f.descriptionId })
      ] })
    ] });
  }
), jv = "DialogTitle", gR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, i = nr(jv, n);
    return /* @__PURE__ */ S.jsx(ze.h2, { id: i.titleId, ...o, ref: t });
  }
);
gR.displayName = jv;
var vR = "DialogDescription", yR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, i = nr(vR, n);
    return /* @__PURE__ */ S.jsx(ze.p, { id: i.descriptionId, ...o, ref: t });
  }
);
yR.displayName = vR;
var bR = "DialogClose", xR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...o } = e, i = nr(bR, n);
    return /* @__PURE__ */ S.jsx(
      ze.button,
      {
        type: "button",
        ...o,
        ref: t,
        onClick: ge(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
xR.displayName = bR;
function kv(e) {
  return e ? "open" : "closed";
}
var SR = "DialogTitleWarning", [lY, wR] = F6(SR, {
  contentName: Ea,
  titleName: jv,
  docsSlug: "dialog"
}), h8 = ({ titleId: e }) => {
  const t = wR(SR), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return y.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, p8 = "DialogDescriptionWarning", m8 = ({ contentRef: e, descriptionId: t }) => {
  const o = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${wR(p8).contentName}}.`;
  return y.useEffect(() => {
    const i = e.current?.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(o));
  }, [o, e, t]), null;
}, g8 = cR, v8 = dR, y8 = hR, b8 = pR, x8 = gR, S8 = yR, w8 = xR;
function Pv({ ...e }) {
  return /* @__PURE__ */ S.jsx(g8, { "data-slot": "dialog", ...e });
}
function E8({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(v8, { "data-slot": "dialog-portal", ...e });
}
function _8({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    y8,
    {
      "data-slot": "dialog-overlay",
      className: Ge(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        e
      ),
      ...t
    }
  );
}
function Lv({
  className: e,
  children: t,
  showCloseButton: n = !0,
  ...o
}) {
  return /* @__PURE__ */ S.jsxs(E8, { "data-slot": "dialog-portal", children: [
    /* @__PURE__ */ S.jsx(_8, {}),
    /* @__PURE__ */ S.jsxs(
      b8,
      {
        "data-slot": "dialog-content",
        className: Ge(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-[1000] grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          e
        ),
        ...o,
        onCloseAutoFocus: (i) => {
          i.preventDefault(), document.body.style.pointerEvents = "";
        },
        children: [
          t,
          n && /* @__PURE__ */ S.jsxs(
            w8,
            {
              "data-slot": "dialog-close",
              className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
              children: [
                /* @__PURE__ */ S.jsx(Rf, {}),
                /* @__PURE__ */ S.jsx("span", { className: "sr-only", children: "Close" })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function Iv({ className: e, ...t }) {
  return /* @__PURE__ */ S.jsx(
    "div",
    {
      "data-slot": "dialog-header",
      className: Ge("flex flex-col gap-2 text-center sm:text-left", e),
      ...t
    }
  );
}
function ER({ className: e, ...t }) {
  return /* @__PURE__ */ S.jsx(
    "div",
    {
      "data-slot": "dialog-footer",
      className: Ge(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        e
      ),
      ...t
    }
  );
}
function Vv({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    x8,
    {
      "data-slot": "dialog-title",
      className: Ge("text-lg leading-none font-semibold", e),
      ...t
    }
  );
}
function T8({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    S8,
    {
      "data-slot": "dialog-description",
      className: Ge("text-muted-foreground text-sm", e),
      ...t
    }
  );
}
var C8 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], A8 = C8.reduce((e, t) => {
  const n = /* @__PURE__ */ QC(`Primitive.${t}`), o = y.forwardRef((i, l) => {
    const { asChild: c, ...f } = i, d = c ? n : t;
    return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(d, { ...f, ref: l });
  });
  return o.displayName = `Primitive.${t}`, { ...e, [t]: o };
}, {}), R8 = "Label", _R = y.forwardRef((e, t) => /* @__PURE__ */ S.jsx(
  A8.label,
  {
    ...e,
    ref: t,
    onMouseDown: (n) => {
      n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault());
    }
  }
));
_R.displayName = R8;
var M8 = _R;
function z8({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    M8,
    {
      "data-slot": "label",
      className: Ge(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        e
      ),
      ...t
    }
  );
}
const D8 = { "gpt-4.1": "openai/gpt-4.1", "gpt-4.1-mini": "openai/gpt-4.1-mini", "gpt-4o-mini": "openai/gpt-4o-mini", "gpt-4o": "openai/gpt-4o", "gpt-5": "openai/gpt-5", "gpt-5.1": "openai/gpt-5.1", "gpt-5-mini": "openai/gpt-5-mini", "gpt-5-nano": "openai/gpt-5-nano", "gpt-oss-120b": "openai/gpt-oss-120b", "gpt-2.5-flash": "openai/gpt-2.5-flash" }, N8 = { "gemini-2.5-flash-lite": "google/gemini-2.5-flash-lite", "gemini-2.5-flash": "google/gemini-2.5-flash", "gemini-2.5-pro": "google/gemini-2.5-pro", "gemini-2.0-flash": "google/gemini-2.0-flash" }, O8 = { "claude-sonnet-4.5": "anthropic/claude-sonnet-4.5", "claude-sonnet-4": "anthropic/claude-sonnet-4", "claude-3.7-sonnet": "anthropic/claude-3.7-sonnet" }, j8 = { "grok-4-fast-reasoning": "xai/grok-4-fast-reasoning", "grok-4-fast-non-reasoning": "xai/grok-4-fast-non-reasoning" }, k8 = { "llama-4-maverick": "meta/llama-4-maverick" }, P8 = { "deepseek-v3.1": "deepseek/deepseek-v3.1" }, L8 = {
  openai: D8,
  google: N8,
  anthropic: O8,
  xai: j8,
  meta: k8,
  deepseek: P8
};
function pg(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
// @__NO_SIDE_EFFECTS__
function pE(e) {
  const t = /* @__PURE__ */ I8(e), n = y.forwardRef((o, i) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(U8);
    if (d) {
      const h = d.props.children, m = f.map((v) => v === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : v);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function I8(e) {
  const t = y.forwardRef((n, o) => {
    const { children: i, ...l } = n;
    if (y.isValidElement(i)) {
      const c = $8(i), f = B8(l, i.props);
      return i.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(i, f);
    }
    return y.Children.count(i) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var V8 = /* @__PURE__ */ Symbol("radix.slottable");
function U8(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === V8;
}
function B8(e, t) {
  const n = { ...t };
  for (const o in t) {
    const i = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? i && l ? n[o] = (...f) => {
      const d = l(...f);
      return i(...f), d;
    } : i && (n[o] = i) : o === "style" ? n[o] = { ...i, ...l } : o === "className" && (n[o] = [i, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function $8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function Uv(e) {
  const t = e + "CollectionProvider", [n, o] = yr(t), [i, l] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), c = (w) => {
    const { scope: C, children: A } = w, M = Jn.useRef(null), T = Jn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ S.jsx(i, { scope: C, itemMap: T, collectionRef: M, children: A });
  };
  c.displayName = t;
  const f = e + "CollectionSlot", d = /* @__PURE__ */ pE(f), h = Jn.forwardRef(
    (w, C) => {
      const { scope: A, children: M } = w, T = l(f, A), D = Le(C, T.collectionRef);
      return /* @__PURE__ */ S.jsx(d, { ref: D, children: M });
    }
  );
  h.displayName = f;
  const m = e + "CollectionItemSlot", v = "data-radix-collection-item", b = /* @__PURE__ */ pE(m), x = Jn.forwardRef(
    (w, C) => {
      const { scope: A, children: M, ...T } = w, D = Jn.useRef(null), O = Le(C, D), k = l(m, A);
      return Jn.useEffect(() => (k.itemMap.set(D, { ref: D, ...T }), () => {
        k.itemMap.delete(D);
      })), /* @__PURE__ */ S.jsx(b, { [v]: "", ref: O, children: M });
    }
  );
  x.displayName = m;
  function E(w) {
    const C = l(e + "CollectionConsumer", w);
    return Jn.useCallback(() => {
      const M = C.collectionRef.current;
      if (!M) return [];
      const T = Array.from(M.querySelectorAll(`[${v}]`));
      return Array.from(C.itemMap.values()).sort(
        (k, R) => T.indexOf(k.ref.current) - T.indexOf(R.ref.current)
      );
    }, [C.collectionRef, C.itemMap]);
  }
  return [
    { Provider: c, Slot: h, ItemSlot: x },
    E,
    o
  ];
}
var H8 = y.createContext(void 0);
function qf(e) {
  const t = y.useContext(H8);
  return e || t || "ltr";
}
// @__NO_SIDE_EFFECTS__
function Z8(e) {
  const t = /* @__PURE__ */ F8(e), n = y.forwardRef((o, i) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(Y8);
    if (d) {
      const h = d.props.children, m = f.map((v) => v === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : v);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function F8(e) {
  const t = y.forwardRef((n, o) => {
    const { children: i, ...l } = n;
    if (y.isValidElement(i)) {
      const c = W8(i), f = q8(l, i.props);
      return i.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(i, f);
    }
    return y.Children.count(i) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var G8 = /* @__PURE__ */ Symbol("radix.slottable");
function Y8(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === G8;
}
function q8(e, t) {
  const n = { ...t };
  for (const o in t) {
    const i = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? i && l ? n[o] = (...f) => {
      const d = l(...f);
      return i(...f), d;
    } : i && (n[o] = i) : o === "style" ? n[o] = { ...i, ...l } : o === "className" && (n[o] = [i, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function W8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function TR(e) {
  const t = y.useRef({ value: e, previous: e });
  return y.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var X8 = [" ", "Enter", "ArrowUp", "ArrowDown"], K8 = [" ", "Enter"], _a = "Select", [Wf, Xf, J8] = Uv(_a), [es] = yr(_a, [
  J8,
  Qi
]), Kf = Qi(), [Q8, Ho] = es(_a), [eZ, tZ] = es(_a), CR = (e) => {
  const {
    __scopeSelect: t,
    children: n,
    open: o,
    defaultOpen: i,
    onOpenChange: l,
    value: c,
    defaultValue: f,
    onValueChange: d,
    dir: h,
    name: m,
    autoComplete: v,
    disabled: b,
    required: x,
    form: E
  } = e, w = Kf(t), [C, A] = y.useState(null), [M, T] = y.useState(null), [D, O] = y.useState(!1), k = qf(h), [R, N] = wa({
    prop: o,
    defaultProp: i ?? !1,
    onChange: l,
    caller: _a
  }), [P, Y] = wa({
    prop: c,
    defaultProp: f,
    onChange: d,
    caller: _a
  }), ne = y.useRef(null), J = C ? E || !!C.closest("form") : !0, [ce, ue] = y.useState(/* @__PURE__ */ new Set()), de = Array.from(ce).map((I) => I.props.value).join(";");
  return /* @__PURE__ */ S.jsx(_v, { ...w, children: /* @__PURE__ */ S.jsxs(
    Q8,
    {
      required: x,
      scope: t,
      trigger: C,
      onTriggerChange: A,
      valueNode: M,
      onValueNodeChange: T,
      valueNodeHasChildren: D,
      onValueNodeHasChildrenChange: O,
      contentId: pr(),
      value: P,
      onValueChange: Y,
      open: R,
      onOpenChange: N,
      dir: k,
      triggerPointerDownPosRef: ne,
      disabled: b,
      children: [
        /* @__PURE__ */ S.jsx(Wf.Provider, { scope: t, children: /* @__PURE__ */ S.jsx(
          eZ,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: y.useCallback((I) => {
              ue((G) => new Set(G).add(I));
            }, []),
            onNativeOptionRemove: y.useCallback((I) => {
              ue((G) => {
                const U = new Set(G);
                return U.delete(I), U;
              });
            }, []),
            children: n
          }
        ) }),
        J ? /* @__PURE__ */ S.jsxs(
          XR,
          {
            "aria-hidden": !0,
            required: x,
            tabIndex: -1,
            name: m,
            autoComplete: v,
            value: P,
            onChange: (I) => Y(I.target.value),
            disabled: b,
            form: E,
            children: [
              P === void 0 ? /* @__PURE__ */ S.jsx("option", { value: "" }) : null,
              Array.from(ce)
            ]
          },
          de
        ) : null
      ]
    }
  ) });
};
CR.displayName = _a;
var AR = "SelectTrigger", RR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, disabled: o = !1, ...i } = e, l = Kf(n), c = Ho(AR, n), f = c.disabled || o, d = Le(t, c.onTriggerChange), h = Xf(n), m = y.useRef("touch"), [v, b, x] = JR((w) => {
      const C = h().filter((T) => !T.disabled), A = C.find((T) => T.value === c.value), M = QR(C, w, A);
      M !== void 0 && c.onValueChange(M.value);
    }), E = (w) => {
      f || (c.onOpenChange(!0), x()), w && (c.triggerPointerDownPosRef.current = {
        x: Math.round(w.pageX),
        y: Math.round(w.pageY)
      });
    };
    return /* @__PURE__ */ S.jsx(Tv, { asChild: !0, ...l, children: /* @__PURE__ */ S.jsx(
      ze.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": c.contentId,
        "aria-expanded": c.open,
        "aria-required": c.required,
        "aria-autocomplete": "none",
        dir: c.dir,
        "data-state": c.open ? "open" : "closed",
        disabled: f,
        "data-disabled": f ? "" : void 0,
        "data-placeholder": KR(c.value) ? "" : void 0,
        ...i,
        ref: d,
        onClick: ge(i.onClick, (w) => {
          w.currentTarget.focus(), m.current !== "mouse" && E(w);
        }),
        onPointerDown: ge(i.onPointerDown, (w) => {
          m.current = w.pointerType;
          const C = w.target;
          C.hasPointerCapture(w.pointerId) && C.releasePointerCapture(w.pointerId), w.button === 0 && w.ctrlKey === !1 && w.pointerType === "mouse" && (E(w), w.preventDefault());
        }),
        onKeyDown: ge(i.onKeyDown, (w) => {
          const C = v.current !== "";
          !(w.ctrlKey || w.altKey || w.metaKey) && w.key.length === 1 && b(w.key), !(C && w.key === " ") && X8.includes(w.key) && (E(), w.preventDefault());
        })
      }
    ) });
  }
);
RR.displayName = AR;
var MR = "SelectValue", zR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: o, style: i, children: l, placeholder: c = "", ...f } = e, d = Ho(MR, n), { onValueNodeHasChildrenChange: h } = d, m = l !== void 0, v = Le(t, d.onValueNodeChange);
    return Ht(() => {
      h(m);
    }, [h, m]), /* @__PURE__ */ S.jsx(
      ze.span,
      {
        ...f,
        ref: v,
        style: { pointerEvents: "none" },
        children: KR(d.value) ? /* @__PURE__ */ S.jsx(S.Fragment, { children: c }) : l
      }
    );
  }
);
zR.displayName = MR;
var nZ = "SelectIcon", DR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, children: o, ...i } = e;
    return /* @__PURE__ */ S.jsx(ze.span, { "aria-hidden": !0, ...i, ref: t, children: o || "" });
  }
);
DR.displayName = nZ;
var rZ = "SelectPortal", NR = (e) => /* @__PURE__ */ S.jsx(Zl, { asChild: !0, ...e });
NR.displayName = rZ;
var Ta = "SelectContent", OR = y.forwardRef(
  (e, t) => {
    const n = Ho(Ta, e.__scopeSelect), [o, i] = y.useState();
    if (Ht(() => {
      i(new DocumentFragment());
    }, []), !n.open) {
      const l = o;
      return l ? Vo.createPortal(
        /* @__PURE__ */ S.jsx(jR, { scope: e.__scopeSelect, children: /* @__PURE__ */ S.jsx(Wf.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ S.jsx("div", { children: e.children }) }) }),
        l
      ) : null;
    }
    return /* @__PURE__ */ S.jsx(kR, { ...e, ref: t });
  }
);
OR.displayName = Ta;
var Kn = 10, [jR, Zo] = es(Ta), oZ = "SelectContentImpl", aZ = /* @__PURE__ */ Z8("SelectContent.RemoveScroll"), kR = y.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      position: o = "item-aligned",
      onCloseAutoFocus: i,
      onEscapeKeyDown: l,
      onPointerDownOutside: c,
      //
      // PopperContent props
      side: f,
      sideOffset: d,
      align: h,
      alignOffset: m,
      arrowPadding: v,
      collisionBoundary: b,
      collisionPadding: x,
      sticky: E,
      hideWhenDetached: w,
      avoidCollisions: C,
      //
      ...A
    } = e, M = Ho(Ta, n), [T, D] = y.useState(null), [O, k] = y.useState(null), R = Le(t, (H) => D(H)), [N, P] = y.useState(null), [Y, ne] = y.useState(
      null
    ), J = Xf(n), [ce, ue] = y.useState(!1), de = y.useRef(!1);
    y.useEffect(() => {
      if (T) return Nv(T);
    }, [T]), Dv();
    const I = y.useCallback(
      (H) => {
        const [re, ...le] = J().map((Re) => Re.ref.current), [fe] = le.slice(-1), me = document.activeElement;
        for (const Re of H)
          if (Re === me || (Re?.scrollIntoView({ block: "nearest" }), Re === re && O && (O.scrollTop = 0), Re === fe && O && (O.scrollTop = O.scrollHeight), Re?.focus(), document.activeElement !== me)) return;
      },
      [J, O]
    ), G = y.useCallback(
      () => I([N, T]),
      [I, N, T]
    );
    y.useEffect(() => {
      ce && G();
    }, [ce, G]);
    const { onOpenChange: U, triggerPointerDownPosRef: te } = M;
    y.useEffect(() => {
      if (T) {
        let H = { x: 0, y: 0 };
        const re = (fe) => {
          H = {
            x: Math.abs(Math.round(fe.pageX) - (te.current?.x ?? 0)),
            y: Math.abs(Math.round(fe.pageY) - (te.current?.y ?? 0))
          };
        }, le = (fe) => {
          H.x <= 10 && H.y <= 10 ? fe.preventDefault() : T.contains(fe.target) || U(!1), document.removeEventListener("pointermove", re), te.current = null;
        };
        return te.current !== null && (document.addEventListener("pointermove", re), document.addEventListener("pointerup", le, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", re), document.removeEventListener("pointerup", le, { capture: !0 });
        };
      }
    }, [T, U, te]), y.useEffect(() => {
      const H = () => U(!1);
      return window.addEventListener("blur", H), window.addEventListener("resize", H), () => {
        window.removeEventListener("blur", H), window.removeEventListener("resize", H);
      };
    }, [U]);
    const [he, j] = JR((H) => {
      const re = J().filter((me) => !me.disabled), le = re.find((me) => me.ref.current === document.activeElement), fe = QR(re, H, le);
      fe && setTimeout(() => fe.ref.current.focus());
    }), W = y.useCallback(
      (H, re, le) => {
        const fe = !de.current && !le;
        (M.value !== void 0 && M.value === re || fe) && (P(H), fe && (de.current = !0));
      },
      [M.value]
    ), $ = y.useCallback(() => T?.focus(), [T]), X = y.useCallback(
      (H, re, le) => {
        const fe = !de.current && !le;
        (M.value !== void 0 && M.value === re || fe) && ne(H);
      },
      [M.value]
    ), se = o === "popper" ? mg : PR, ie = se === mg ? {
      side: f,
      sideOffset: d,
      align: h,
      alignOffset: m,
      arrowPadding: v,
      collisionBoundary: b,
      collisionPadding: x,
      sticky: E,
      hideWhenDetached: w,
      avoidCollisions: C
    } : {};
    return /* @__PURE__ */ S.jsx(
      jR,
      {
        scope: n,
        content: T,
        viewport: O,
        onViewportChange: k,
        itemRefCallback: W,
        selectedItem: N,
        onItemLeave: $,
        itemTextRefCallback: X,
        focusSelectedItem: G,
        selectedItemText: Y,
        position: o,
        isPositioned: ce,
        searchRef: he,
        children: /* @__PURE__ */ S.jsx(Gf, { as: aZ, allowPinchZoom: !0, children: /* @__PURE__ */ S.jsx(
          Zf,
          {
            asChild: !0,
            trapped: M.open,
            onMountAutoFocus: (H) => {
              H.preventDefault();
            },
            onUnmountAutoFocus: ge(i, (H) => {
              M.trigger?.focus({ preventScroll: !0 }), H.preventDefault();
            }),
            children: /* @__PURE__ */ S.jsx(
              $l,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: l,
                onPointerDownOutside: c,
                onFocusOutside: (H) => H.preventDefault(),
                onDismiss: () => M.onOpenChange(!1),
                children: /* @__PURE__ */ S.jsx(
                  se,
                  {
                    role: "listbox",
                    id: M.contentId,
                    "data-state": M.open ? "open" : "closed",
                    dir: M.dir,
                    onContextMenu: (H) => H.preventDefault(),
                    ...A,
                    ...ie,
                    onPlaced: () => ue(!0),
                    ref: R,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...A.style
                    },
                    onKeyDown: ge(A.onKeyDown, (H) => {
                      const re = H.ctrlKey || H.altKey || H.metaKey;
                      if (H.key === "Tab" && H.preventDefault(), !re && H.key.length === 1 && j(H.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(H.key)) {
                        let fe = J().filter((me) => !me.disabled).map((me) => me.ref.current);
                        if (["ArrowUp", "End"].includes(H.key) && (fe = fe.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(H.key)) {
                          const me = H.target, Re = fe.indexOf(me);
                          fe = fe.slice(Re + 1);
                        }
                        setTimeout(() => I(fe)), H.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
kR.displayName = oZ;
var iZ = "SelectItemAlignedPosition", PR = y.forwardRef((e, t) => {
  const { __scopeSelect: n, onPlaced: o, ...i } = e, l = Ho(Ta, n), c = Zo(Ta, n), [f, d] = y.useState(null), [h, m] = y.useState(null), v = Le(t, (R) => m(R)), b = Xf(n), x = y.useRef(!1), E = y.useRef(!0), { viewport: w, selectedItem: C, selectedItemText: A, focusSelectedItem: M } = c, T = y.useCallback(() => {
    if (l.trigger && l.valueNode && f && h && w && C && A) {
      const R = l.trigger.getBoundingClientRect(), N = h.getBoundingClientRect(), P = l.valueNode.getBoundingClientRect(), Y = A.getBoundingClientRect();
      if (l.dir !== "rtl") {
        const me = Y.left - N.left, Re = P.left - me, je = R.left - Re, Qe = R.width + je, un = Math.max(Qe, N.width), Tn = window.innerWidth - Kn, Sr = pg(Re, [
          Kn,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(Kn, Tn - un)
        ]);
        f.style.minWidth = Qe + "px", f.style.left = Sr + "px";
      } else {
        const me = N.right - Y.right, Re = window.innerWidth - P.right - me, je = window.innerWidth - R.right - Re, Qe = R.width + je, un = Math.max(Qe, N.width), Tn = window.innerWidth - Kn, Sr = pg(Re, [
          Kn,
          Math.max(Kn, Tn - un)
        ]);
        f.style.minWidth = Qe + "px", f.style.right = Sr + "px";
      }
      const ne = b(), J = window.innerHeight - Kn * 2, ce = w.scrollHeight, ue = window.getComputedStyle(h), de = parseInt(ue.borderTopWidth, 10), I = parseInt(ue.paddingTop, 10), G = parseInt(ue.borderBottomWidth, 10), U = parseInt(ue.paddingBottom, 10), te = de + I + ce + U + G, he = Math.min(C.offsetHeight * 5, te), j = window.getComputedStyle(w), W = parseInt(j.paddingTop, 10), $ = parseInt(j.paddingBottom, 10), X = R.top + R.height / 2 - Kn, se = J - X, ie = C.offsetHeight / 2, H = C.offsetTop + ie, re = de + I + H, le = te - re;
      if (re <= X) {
        const me = ne.length > 0 && C === ne[ne.length - 1].ref.current;
        f.style.bottom = "0px";
        const Re = h.clientHeight - w.offsetTop - w.offsetHeight, je = Math.max(
          se,
          ie + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (me ? $ : 0) + Re + G
        ), Qe = re + je;
        f.style.height = Qe + "px";
      } else {
        const me = ne.length > 0 && C === ne[0].ref.current;
        f.style.top = "0px";
        const je = Math.max(
          X,
          de + w.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (me ? W : 0) + ie
        ) + le;
        f.style.height = je + "px", w.scrollTop = re - X + w.offsetTop;
      }
      f.style.margin = `${Kn}px 0`, f.style.minHeight = he + "px", f.style.maxHeight = J + "px", o?.(), requestAnimationFrame(() => x.current = !0);
    }
  }, [
    b,
    l.trigger,
    l.valueNode,
    f,
    h,
    w,
    C,
    A,
    l.dir,
    o
  ]);
  Ht(() => T(), [T]);
  const [D, O] = y.useState();
  Ht(() => {
    h && O(window.getComputedStyle(h).zIndex);
  }, [h]);
  const k = y.useCallback(
    (R) => {
      R && E.current === !0 && (T(), M?.(), E.current = !1);
    },
    [T, M]
  );
  return /* @__PURE__ */ S.jsx(
    lZ,
    {
      scope: n,
      contentWrapper: f,
      shouldExpandOnScrollRef: x,
      onScrollButtonChange: k,
      children: /* @__PURE__ */ S.jsx(
        "div",
        {
          ref: d,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: D
          },
          children: /* @__PURE__ */ S.jsx(
            ze.div,
            {
              ...i,
              ref: v,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...i.style
              }
            }
          )
        }
      )
    }
  );
});
PR.displayName = iZ;
var sZ = "SelectPopperPosition", mg = y.forwardRef((e, t) => {
  const {
    __scopeSelect: n,
    align: o = "start",
    collisionPadding: i = Kn,
    ...l
  } = e, c = Kf(n);
  return /* @__PURE__ */ S.jsx(
    Cv,
    {
      ...c,
      ...l,
      ref: t,
      align: o,
      collisionPadding: i,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...l.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
mg.displayName = sZ;
var [lZ, Bv] = es(Ta, {}), gg = "SelectViewport", LR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, nonce: o, ...i } = e, l = Zo(gg, n), c = Bv(gg, n), f = Le(t, l.onViewportChange), d = y.useRef(0);
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: o
        }
      ),
      /* @__PURE__ */ S.jsx(Wf.Slot, { scope: n, children: /* @__PURE__ */ S.jsx(
        ze.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...i,
          ref: f,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...i.style
          },
          onScroll: ge(i.onScroll, (h) => {
            const m = h.currentTarget, { contentWrapper: v, shouldExpandOnScrollRef: b } = c;
            if (b?.current && v) {
              const x = Math.abs(d.current - m.scrollTop);
              if (x > 0) {
                const E = window.innerHeight - Kn * 2, w = parseFloat(v.style.minHeight), C = parseFloat(v.style.height), A = Math.max(w, C);
                if (A < E) {
                  const M = A + x, T = Math.min(E, M), D = M - T;
                  v.style.height = T + "px", v.style.bottom === "0px" && (m.scrollTop = D > 0 ? D : 0, v.style.justifyContent = "flex-end");
                }
              }
            }
            d.current = m.scrollTop;
          })
        }
      ) })
    ] });
  }
);
LR.displayName = gg;
var IR = "SelectGroup", [cZ, uZ] = es(IR), VR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e, i = pr();
    return /* @__PURE__ */ S.jsx(cZ, { scope: n, id: i, children: /* @__PURE__ */ S.jsx(ze.div, { role: "group", "aria-labelledby": i, ...o, ref: t }) });
  }
);
VR.displayName = IR;
var UR = "SelectLabel", BR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e, i = uZ(UR, n);
    return /* @__PURE__ */ S.jsx(ze.div, { id: i.id, ...o, ref: t });
  }
);
BR.displayName = UR;
var mf = "SelectItem", [fZ, $R] = es(mf), HR = y.forwardRef(
  (e, t) => {
    const {
      __scopeSelect: n,
      value: o,
      disabled: i = !1,
      textValue: l,
      ...c
    } = e, f = Ho(mf, n), d = Zo(mf, n), h = f.value === o, [m, v] = y.useState(l ?? ""), [b, x] = y.useState(!1), E = Le(
      t,
      (M) => d.itemRefCallback?.(M, o, i)
    ), w = pr(), C = y.useRef("touch"), A = () => {
      i || (f.onValueChange(o), f.onOpenChange(!1));
    };
    if (o === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ S.jsx(
      fZ,
      {
        scope: n,
        value: o,
        disabled: i,
        textId: w,
        isSelected: h,
        onItemTextChange: y.useCallback((M) => {
          v((T) => T || (M?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ S.jsx(
          Wf.ItemSlot,
          {
            scope: n,
            value: o,
            disabled: i,
            textValue: m,
            children: /* @__PURE__ */ S.jsx(
              ze.div,
              {
                role: "option",
                "aria-labelledby": w,
                "data-highlighted": b ? "" : void 0,
                "aria-selected": h && b,
                "data-state": h ? "checked" : "unchecked",
                "aria-disabled": i || void 0,
                "data-disabled": i ? "" : void 0,
                tabIndex: i ? void 0 : -1,
                ...c,
                ref: E,
                onFocus: ge(c.onFocus, () => x(!0)),
                onBlur: ge(c.onBlur, () => x(!1)),
                onClick: ge(c.onClick, () => {
                  C.current !== "mouse" && A();
                }),
                onPointerUp: ge(c.onPointerUp, () => {
                  C.current === "mouse" && A();
                }),
                onPointerDown: ge(c.onPointerDown, (M) => {
                  C.current = M.pointerType;
                }),
                onPointerMove: ge(c.onPointerMove, (M) => {
                  C.current = M.pointerType, i ? d.onItemLeave?.() : C.current === "mouse" && M.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: ge(c.onPointerLeave, (M) => {
                  M.currentTarget === document.activeElement && d.onItemLeave?.();
                }),
                onKeyDown: ge(c.onKeyDown, (M) => {
                  d.searchRef?.current !== "" && M.key === " " || (K8.includes(M.key) && A(), M.key === " " && M.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
HR.displayName = mf;
var cl = "SelectItemText", ZR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, className: o, style: i, ...l } = e, c = Ho(cl, n), f = Zo(cl, n), d = $R(cl, n), h = tZ(cl, n), [m, v] = y.useState(null), b = Le(
      t,
      (A) => v(A),
      d.onItemTextChange,
      (A) => f.itemTextRefCallback?.(A, d.value, d.disabled)
    ), x = m?.textContent, E = y.useMemo(
      () => /* @__PURE__ */ S.jsx("option", { value: d.value, disabled: d.disabled, children: x }, d.value),
      [d.disabled, d.value, x]
    ), { onNativeOptionAdd: w, onNativeOptionRemove: C } = h;
    return Ht(() => (w(E), () => C(E)), [w, C, E]), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(ze.span, { id: d.textId, ...l, ref: b }),
      d.isSelected && c.valueNode && !c.valueNodeHasChildren ? Vo.createPortal(l.children, c.valueNode) : null
    ] });
  }
);
ZR.displayName = cl;
var FR = "SelectItemIndicator", GR = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e;
    return $R(FR, n).isSelected ? /* @__PURE__ */ S.jsx(ze.span, { "aria-hidden": !0, ...o, ref: t }) : null;
  }
);
GR.displayName = FR;
var vg = "SelectScrollUpButton", YR = y.forwardRef((e, t) => {
  const n = Zo(vg, e.__scopeSelect), o = Bv(vg, e.__scopeSelect), [i, l] = y.useState(!1), c = Le(t, o.onScrollButtonChange);
  return Ht(() => {
    if (n.viewport && n.isPositioned) {
      let f = function() {
        const h = d.scrollTop > 0;
        l(h);
      };
      const d = n.viewport;
      return f(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ S.jsx(
    WR,
    {
      ...e,
      ref: c,
      onAutoScroll: () => {
        const { viewport: f, selectedItem: d } = n;
        f && d && (f.scrollTop = f.scrollTop - d.offsetHeight);
      }
    }
  ) : null;
});
YR.displayName = vg;
var yg = "SelectScrollDownButton", qR = y.forwardRef((e, t) => {
  const n = Zo(yg, e.__scopeSelect), o = Bv(yg, e.__scopeSelect), [i, l] = y.useState(!1), c = Le(t, o.onScrollButtonChange);
  return Ht(() => {
    if (n.viewport && n.isPositioned) {
      let f = function() {
        const h = d.scrollHeight - d.clientHeight, m = Math.ceil(d.scrollTop) < h;
        l(m);
      };
      const d = n.viewport;
      return f(), d.addEventListener("scroll", f), () => d.removeEventListener("scroll", f);
    }
  }, [n.viewport, n.isPositioned]), i ? /* @__PURE__ */ S.jsx(
    WR,
    {
      ...e,
      ref: c,
      onAutoScroll: () => {
        const { viewport: f, selectedItem: d } = n;
        f && d && (f.scrollTop = f.scrollTop + d.offsetHeight);
      }
    }
  ) : null;
});
qR.displayName = yg;
var WR = y.forwardRef((e, t) => {
  const { __scopeSelect: n, onAutoScroll: o, ...i } = e, l = Zo("SelectScrollButton", n), c = y.useRef(null), f = Xf(n), d = y.useCallback(() => {
    c.current !== null && (window.clearInterval(c.current), c.current = null);
  }, []);
  return y.useEffect(() => () => d(), [d]), Ht(() => {
    f().find((m) => m.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [f]), /* @__PURE__ */ S.jsx(
    ze.div,
    {
      "aria-hidden": !0,
      ...i,
      ref: t,
      style: { flexShrink: 0, ...i.style },
      onPointerDown: ge(i.onPointerDown, () => {
        c.current === null && (c.current = window.setInterval(o, 50));
      }),
      onPointerMove: ge(i.onPointerMove, () => {
        l.onItemLeave?.(), c.current === null && (c.current = window.setInterval(o, 50));
      }),
      onPointerLeave: ge(i.onPointerLeave, () => {
        d();
      })
    }
  );
}), dZ = "SelectSeparator", hZ = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(ze.div, { "aria-hidden": !0, ...o, ref: t });
  }
);
hZ.displayName = dZ;
var bg = "SelectArrow", pZ = y.forwardRef(
  (e, t) => {
    const { __scopeSelect: n, ...o } = e, i = Kf(n), l = Ho(bg, n), c = Zo(bg, n);
    return l.open && c.position === "popper" ? /* @__PURE__ */ S.jsx(Av, { ...i, ...o, ref: t }) : null;
  }
);
pZ.displayName = bg;
var mZ = "SelectBubbleInput", XR = y.forwardRef(
  ({ __scopeSelect: e, value: t, ...n }, o) => {
    const i = y.useRef(null), l = Le(o, i), c = TR(t);
    return y.useEffect(() => {
      const f = i.current;
      if (!f) return;
      const d = window.HTMLSelectElement.prototype, m = Object.getOwnPropertyDescriptor(
        d,
        "value"
      ).set;
      if (c !== t && m) {
        const v = new Event("change", { bubbles: !0 });
        m.call(f, t), f.dispatchEvent(v);
      }
    }, [c, t]), /* @__PURE__ */ S.jsx(
      ze.select,
      {
        ...n,
        style: { ...BA, ...n.style },
        ref: l,
        defaultValue: t
      }
    );
  }
);
XR.displayName = mZ;
function KR(e) {
  return e === "" || e === void 0;
}
function JR(e) {
  const t = $t(e), n = y.useRef(""), o = y.useRef(0), i = y.useCallback(
    (c) => {
      const f = n.current + c;
      t(f), (function d(h) {
        n.current = h, window.clearTimeout(o.current), h !== "" && (o.current = window.setTimeout(() => d(""), 1e3));
      })(f);
    },
    [t]
  ), l = y.useCallback(() => {
    n.current = "", window.clearTimeout(o.current);
  }, []);
  return y.useEffect(() => () => window.clearTimeout(o.current), []), [n, i, l];
}
function QR(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((h) => h === t[0]) ? t[0] : t, l = n ? e.indexOf(n) : -1;
  let c = gZ(e, Math.max(l, 0));
  i.length === 1 && (c = c.filter((h) => h !== n));
  const d = c.find(
    (h) => h.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return d !== n ? d : void 0;
}
function gZ(e, t) {
  return e.map((n, o) => e[(t + o) % e.length]);
}
var vZ = CR, yZ = RR, bZ = zR, xZ = DR, SZ = NR, wZ = OR, EZ = LR, _Z = VR, TZ = BR, CZ = HR, AZ = ZR, RZ = GR, MZ = YR, zZ = qR;
function DZ({ ...e }) {
  return /* @__PURE__ */ S.jsx(vZ, { "data-slot": "select", ...e });
}
function NZ({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(_Z, { "data-slot": "select-group", ...e });
}
function OZ({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(bZ, { "data-slot": "select-value", ...e });
}
function jZ({
  className: e,
  size: t = "default",
  children: n,
  ...o
}) {
  return /* @__PURE__ */ S.jsxs(
    yZ,
    {
      "data-slot": "select-trigger",
      "data-size": t,
      className: Ge(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...o,
      children: [
        n,
        /* @__PURE__ */ S.jsx(xZ, { asChild: !0, children: /* @__PURE__ */ S.jsx(Tg, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function kZ({
  className: e,
  children: t,
  position: n = "popper",
  ...o
}) {
  return /* @__PURE__ */ S.jsx(SZ, { children: /* @__PURE__ */ S.jsxs(
    wZ,
    {
      "data-slot": "select-content",
      className: Ge(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        e
      ),
      position: n,
      ...o,
      children: [
        /* @__PURE__ */ S.jsx(IZ, {}),
        /* @__PURE__ */ S.jsx(
          EZ,
          {
            className: Ge(
              "p-1",
              n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children: t
          }
        ),
        /* @__PURE__ */ S.jsx(VZ, {})
      ]
    }
  ) });
}
function PZ({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    TZ,
    {
      "data-slot": "select-label",
      className: Ge("text-muted-foreground px-2 py-1.5 text-xs", e),
      ...t
    }
  );
}
function LZ({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ S.jsxs(
    CZ,
    {
      "data-slot": "select-item",
      className: Ge(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        e
      ),
      ...n,
      children: [
        /* @__PURE__ */ S.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ S.jsx(RZ, { children: /* @__PURE__ */ S.jsx(PE, { className: "size-4" }) }) }),
        /* @__PURE__ */ S.jsx(AZ, { children: t })
      ]
    }
  );
}
function IZ({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    MZ,
    {
      "data-slot": "select-scroll-up-button",
      className: Ge("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ S.jsx(LE, { className: "size-4" })
    }
  );
}
function VZ({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    zZ,
    {
      "data-slot": "select-scroll-down-button",
      className: Ge("flex cursor-default items-center justify-center py-1", e),
      ...t,
      children: /* @__PURE__ */ S.jsx(Tg, { className: "size-4" })
    }
  );
}
const eM = "claude-sonnet-4.5", UZ = ({
  open: e,
  onOpenChange: t,
  setApiKeyByName: n
}) => {
  const [o, i] = y.useState(
    localStorage.getItem("ai-name") || eM
  ), [l, c] = y.useState([]);
  y.useEffect(() => {
    const d = [];
    Object.entries(L8).forEach(([h, m]) => {
      d.push({ provider: h, models: Object.keys(m) });
    }), c(d);
  }, []);
  const f = async () => {
    try {
      localStorage.setItem("ai-name", o), window.dispatchEvent(new Event("chatbot:settings-updated")), n && await n(o), t(!1);
    } catch {
      t(!1);
    }
  };
  return /* @__PURE__ */ S.jsx(Pv, { open: e, onOpenChange: t, children: /* @__PURE__ */ S.jsxs(Lv, { className: "max-w-sm", children: [
    /* @__PURE__ */ S.jsxs(Iv, { children: [
      /* @__PURE__ */ S.jsx(Vv, { children: "Settings" }),
      /* @__PURE__ */ S.jsx(T8, { className: "text-xs text-muted-foreground italic", children: "Configure your chatbot model. Settings are stored locally." })
    ] }),
    /* @__PURE__ */ S.jsxs("div", { className: "flex flex-col gap-2 py-1", children: [
      /* @__PURE__ */ S.jsx(z8, { htmlFor: "openai-name", children: "Model name" }),
      /* @__PURE__ */ S.jsxs(DZ, { value: o, onValueChange: i, children: [
        /* @__PURE__ */ S.jsx(jZ, { id: "openai-name", className: "w-full", children: /* @__PURE__ */ S.jsx(OZ, { placeholder: "Select a model" }) }),
        /* @__PURE__ */ S.jsx(
          kZ,
          {
            position: "popper",
            className: "z-[9999] max-h-[30vh] overflow-y-auto",
            children: l.map((d) => /* @__PURE__ */ S.jsxs(NZ, { children: [
              /* @__PURE__ */ S.jsx(PZ, { children: d.provider }),
              d.models.map((h) => /* @__PURE__ */ S.jsx(LZ, { value: h, children: h }, h))
            ] }, d.provider))
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ S.jsx(ER, { children: /* @__PURE__ */ S.jsx(Nt, { onClick: f, type: "button", children: "Save" }) })
  ] }) });
};
function mE({ className: e }) {
  return /* @__PURE__ */ S.jsxs(
    "svg",
    {
      "aria-hidden": "true",
      viewBox: "0 0 24 24",
      version: "1.1",
      className: e,
      "data-view-component": "true",
      children: [
        /* @__PURE__ */ S.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"
          }
        ),
        /* @__PURE__ */ S.jsx(
          "path",
          {
            fill: "currentColor",
            d: "M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"
          }
        )
      ]
    }
  );
}
function BZ() {
  return /* @__PURE__ */ S.jsx("div", { className: "p-6", children: /* @__PURE__ */ S.jsxs("div", { className: "rounded-xl border bg-card p-6", children: [
    /* @__PURE__ */ S.jsx("div", { className: "text-base font-semibold", children: "MCP Configuration" }),
    /* @__PURE__ */ S.jsx("div", { className: "mt-2 text-sm text-muted-foreground", children: "UI placeholder (ported shell). Hook this up to your MCP server list and tools when ready." })
  ] }) });
}
function $Z({
  onClose: e,
  title: t = "Chatbot",
  version: n = "v1",
  setApiKeyByName: o,
  onToggleSidebar: i,
  isSidebarOpen: l = !1
}) {
  const [c, f] = y.useState(!1), [d, h] = y.useState(!1);
  return /* @__PURE__ */ S.jsxs(zv, { delayDuration: 150, children: [
    /* @__PURE__ */ S.jsxs("div", { className: "chatbot-drag-handle bg-background h-12 px-4 flex items-center justify-between border-b rounded-t-2xl cursor-grab active:cursor-grabbing", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ S.jsx("div", { className: "h-7 w-7 inline-flex items-center justify-center rounded-lg bg-blue-100 dark:bg-[#1abcfe]/10", children: /* @__PURE__ */ S.jsx(c2, { className: "h-4 w-4 text-blue-500 dark:text-[#1abcfe]" }) }),
        /* @__PURE__ */ S.jsx("h3", { className: "text-base font-semibold leading-none text-neutral-900 dark:text-white", children: t }),
        /* @__PURE__ */ S.jsx(
          JA,
          {
            variant: "outline",
            className: "hidden sm:inline-flex border-blue-200 text-blue-500 bg-transparent dark:border-[#1abcfe]/40 dark:text-[#1abcfe]",
            children: n
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-1", children: [
        i && /* @__PURE__ */ S.jsxs(il, { children: [
          /* @__PURE__ */ S.jsx(sl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Nt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              onClick: i,
              "aria-label": l ? "Hide chat history" : "Show chat history",
              type: "button",
              children: /* @__PURE__ */ S.jsx(a2, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(ll, { children: l ? "Hide chat history" : "Show chat history" })
        ] }),
        /* @__PURE__ */ S.jsxs(il, { children: [
          /* @__PURE__ */ S.jsx(sl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Nt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-blue-500 cursor-pointer",
              "aria-label": "Open settings",
              onClick: () => f(!0),
              type: "button",
              children: /* @__PURE__ */ S.jsx(_2, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(ll, { children: "Settings" })
        ] }),
        /* @__PURE__ */ S.jsxs(il, { children: [
          /* @__PURE__ */ S.jsx(sl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Nt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: () => h(!0),
              "aria-label": "MCP Configuration",
              type: "button",
              children: /* @__PURE__ */ S.jsx(mE, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(ll, { children: "MCP Configuration" })
        ] }),
        /* @__PURE__ */ S.jsxs(il, { children: [
          /* @__PURE__ */ S.jsx(sl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
            Nt,
            {
              variant: "ghost",
              size: "icon",
              className: "h-7 w-7 transition-colors hover:bg-muted hover:text-foreground cursor-pointer",
              onClick: e,
              "aria-label": "Close",
              type: "button",
              children: /* @__PURE__ */ S.jsx(Rf, { className: "h-4 w-4" })
            }
          ) }),
          /* @__PURE__ */ S.jsx(ll, { children: "Close" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ S.jsx(
      UZ,
      {
        open: c,
        onOpenChange: f,
        setApiKeyByName: o
      }
    ),
    /* @__PURE__ */ S.jsx(Pv, { open: d, onOpenChange: h, children: /* @__PURE__ */ S.jsxs(Lv, { className: "!w-[90vw] !max-w-[1400px] max-h-[85vh] overflow-hidden p-0 flex flex-col", children: [
      /* @__PURE__ */ S.jsx(Iv, { className: "px-8 pt-6 pb-4 border-b bg-linear-to-r from-background to-muted/20", children: /* @__PURE__ */ S.jsxs(Vv, { className: "flex items-center gap-3 text-xl font-bold", children: [
        /* @__PURE__ */ S.jsx("div", { className: "p-2 rounded-lg bg-primary/10", children: /* @__PURE__ */ S.jsx(mE, { className: "h-6 w-6 text-primary" }) }),
        "MCP Configuration"
      ] }) }),
      /* @__PURE__ */ S.jsx("div", { className: "overflow-y-auto px-4 flex-1", children: /* @__PURE__ */ S.jsx(BZ, {}) })
    ] }) })
  ] });
}
function HZ(e, t) {
  return y.useReducer((n, o) => t[n][o] ?? n, e);
}
var $v = "ScrollArea", [tM] = yr($v), [ZZ, Hn] = tM($v), nM = y.forwardRef(
  (e, t) => {
    const {
      __scopeScrollArea: n,
      type: o = "hover",
      dir: i,
      scrollHideDelay: l = 600,
      ...c
    } = e, [f, d] = y.useState(null), [h, m] = y.useState(null), [v, b] = y.useState(null), [x, E] = y.useState(null), [w, C] = y.useState(null), [A, M] = y.useState(0), [T, D] = y.useState(0), [O, k] = y.useState(!1), [R, N] = y.useState(!1), P = Le(t, (ne) => d(ne)), Y = qf(i);
    return /* @__PURE__ */ S.jsx(
      ZZ,
      {
        scope: n,
        type: o,
        dir: Y,
        scrollHideDelay: l,
        scrollArea: f,
        viewport: h,
        onViewportChange: m,
        content: v,
        onContentChange: b,
        scrollbarX: x,
        onScrollbarXChange: E,
        scrollbarXEnabled: O,
        onScrollbarXEnabledChange: k,
        scrollbarY: w,
        onScrollbarYChange: C,
        scrollbarYEnabled: R,
        onScrollbarYEnabledChange: N,
        onCornerWidthChange: M,
        onCornerHeightChange: D,
        children: /* @__PURE__ */ S.jsx(
          ze.div,
          {
            dir: Y,
            ...c,
            ref: P,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              "--radix-scroll-area-corner-width": A + "px",
              "--radix-scroll-area-corner-height": T + "px",
              ...e.style
            }
          }
        )
      }
    );
  }
);
nM.displayName = $v;
var rM = "ScrollAreaViewport", oM = y.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, children: o, nonce: i, ...l } = e, c = Hn(rM, n), f = y.useRef(null), d = Le(t, f, c.onViewportChange);
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ S.jsx(
        ze.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...l,
          ref: d,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: c.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: c.scrollbarYEnabled ? "scroll" : "hidden",
            ...e.style
          },
          children: /* @__PURE__ */ S.jsx("div", { ref: c.onContentChange, style: { minWidth: "100%", display: "table" }, children: o })
        }
      )
    ] });
  }
);
oM.displayName = rM;
var xr = "ScrollAreaScrollbar", aM = y.forwardRef(
  (e, t) => {
    const { forceMount: n, ...o } = e, i = Hn(xr, e.__scopeScrollArea), { onScrollbarXEnabledChange: l, onScrollbarYEnabledChange: c } = i, f = e.orientation === "horizontal";
    return y.useEffect(() => (f ? l(!0) : c(!0), () => {
      f ? l(!1) : c(!1);
    }), [f, l, c]), i.type === "hover" ? /* @__PURE__ */ S.jsx(FZ, { ...o, ref: t, forceMount: n }) : i.type === "scroll" ? /* @__PURE__ */ S.jsx(GZ, { ...o, ref: t, forceMount: n }) : i.type === "auto" ? /* @__PURE__ */ S.jsx(iM, { ...o, ref: t, forceMount: n }) : i.type === "always" ? /* @__PURE__ */ S.jsx(Hv, { ...o, ref: t }) : null;
  }
);
aM.displayName = xr;
var FZ = y.forwardRef((e, t) => {
  const { forceMount: n, ...o } = e, i = Hn(xr, e.__scopeScrollArea), [l, c] = y.useState(!1);
  return y.useEffect(() => {
    const f = i.scrollArea;
    let d = 0;
    if (f) {
      const h = () => {
        window.clearTimeout(d), c(!0);
      }, m = () => {
        d = window.setTimeout(() => c(!1), i.scrollHideDelay);
      };
      return f.addEventListener("pointerenter", h), f.addEventListener("pointerleave", m), () => {
        window.clearTimeout(d), f.removeEventListener("pointerenter", h), f.removeEventListener("pointerleave", m);
      };
    }
  }, [i.scrollArea, i.scrollHideDelay]), /* @__PURE__ */ S.jsx(cn, { present: n || l, children: /* @__PURE__ */ S.jsx(
    iM,
    {
      "data-state": l ? "visible" : "hidden",
      ...o,
      ref: t
    }
  ) });
}), GZ = y.forwardRef((e, t) => {
  const { forceMount: n, ...o } = e, i = Hn(xr, e.__scopeScrollArea), l = e.orientation === "horizontal", c = Qf(() => d("SCROLL_END"), 100), [f, d] = HZ("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return y.useEffect(() => {
    if (f === "idle") {
      const h = window.setTimeout(() => d("HIDE"), i.scrollHideDelay);
      return () => window.clearTimeout(h);
    }
  }, [f, i.scrollHideDelay, d]), y.useEffect(() => {
    const h = i.viewport, m = l ? "scrollLeft" : "scrollTop";
    if (h) {
      let v = h[m];
      const b = () => {
        const x = h[m];
        v !== x && (d("SCROLL"), c()), v = x;
      };
      return h.addEventListener("scroll", b), () => h.removeEventListener("scroll", b);
    }
  }, [i.viewport, l, d, c]), /* @__PURE__ */ S.jsx(cn, { present: n || f !== "hidden", children: /* @__PURE__ */ S.jsx(
    Hv,
    {
      "data-state": f === "hidden" ? "hidden" : "visible",
      ...o,
      ref: t,
      onPointerEnter: ge(e.onPointerEnter, () => d("POINTER_ENTER")),
      onPointerLeave: ge(e.onPointerLeave, () => d("POINTER_LEAVE"))
    }
  ) });
}), iM = y.forwardRef((e, t) => {
  const n = Hn(xr, e.__scopeScrollArea), { forceMount: o, ...i } = e, [l, c] = y.useState(!1), f = e.orientation === "horizontal", d = Qf(() => {
    if (n.viewport) {
      const h = n.viewport.offsetWidth < n.viewport.scrollWidth, m = n.viewport.offsetHeight < n.viewport.scrollHeight;
      c(f ? h : m);
    }
  }, 10);
  return Hi(n.viewport, d), Hi(n.content, d), /* @__PURE__ */ S.jsx(cn, { present: o || l, children: /* @__PURE__ */ S.jsx(
    Hv,
    {
      "data-state": l ? "visible" : "hidden",
      ...i,
      ref: t
    }
  ) });
}), Hv = y.forwardRef((e, t) => {
  const { orientation: n = "vertical", ...o } = e, i = Hn(xr, e.__scopeScrollArea), l = y.useRef(null), c = y.useRef(0), [f, d] = y.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), h = fM(f.viewport, f.content), m = {
    ...o,
    sizes: f,
    onSizesChange: d,
    hasThumb: h > 0 && h < 1,
    onThumbChange: (b) => l.current = b,
    onThumbPointerUp: () => c.current = 0,
    onThumbPointerDown: (b) => c.current = b
  };
  function v(b, x) {
    return JZ(b, c.current, f, x);
  }
  return n === "horizontal" ? /* @__PURE__ */ S.jsx(
    YZ,
    {
      ...m,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && l.current) {
          const b = i.viewport.scrollLeft, x = gE(b, f, i.dir);
          l.current.style.transform = `translate3d(${x}px, 0, 0)`;
        }
      },
      onWheelScroll: (b) => {
        i.viewport && (i.viewport.scrollLeft = b);
      },
      onDragScroll: (b) => {
        i.viewport && (i.viewport.scrollLeft = v(b, i.dir));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ S.jsx(
    qZ,
    {
      ...m,
      ref: t,
      onThumbPositionChange: () => {
        if (i.viewport && l.current) {
          const b = i.viewport.scrollTop, x = gE(b, f);
          l.current.style.transform = `translate3d(0, ${x}px, 0)`;
        }
      },
      onWheelScroll: (b) => {
        i.viewport && (i.viewport.scrollTop = b);
      },
      onDragScroll: (b) => {
        i.viewport && (i.viewport.scrollTop = v(b));
      }
    }
  ) : null;
}), YZ = y.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: o, ...i } = e, l = Hn(xr, e.__scopeScrollArea), [c, f] = y.useState(), d = y.useRef(null), h = Le(t, d, l.onScrollbarXChange);
  return y.useEffect(() => {
    d.current && f(getComputedStyle(d.current));
  }, [d]), /* @__PURE__ */ S.jsx(
    lM,
    {
      "data-orientation": "horizontal",
      ...i,
      ref: h,
      sizes: n,
      style: {
        bottom: 0,
        left: l.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: l.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        "--radix-scroll-area-thumb-width": Jf(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (m) => e.onThumbPointerDown(m.x),
      onDragScroll: (m) => e.onDragScroll(m.x),
      onWheelScroll: (m, v) => {
        if (l.viewport) {
          const b = l.viewport.scrollLeft + m.deltaX;
          e.onWheelScroll(b), hM(b, v) && m.preventDefault();
        }
      },
      onResize: () => {
        d.current && l.viewport && c && o({
          content: l.viewport.scrollWidth,
          viewport: l.viewport.offsetWidth,
          scrollbar: {
            size: d.current.clientWidth,
            paddingStart: vf(c.paddingLeft),
            paddingEnd: vf(c.paddingRight)
          }
        });
      }
    }
  );
}), qZ = y.forwardRef((e, t) => {
  const { sizes: n, onSizesChange: o, ...i } = e, l = Hn(xr, e.__scopeScrollArea), [c, f] = y.useState(), d = y.useRef(null), h = Le(t, d, l.onScrollbarYChange);
  return y.useEffect(() => {
    d.current && f(getComputedStyle(d.current));
  }, [d]), /* @__PURE__ */ S.jsx(
    lM,
    {
      "data-orientation": "vertical",
      ...i,
      ref: h,
      sizes: n,
      style: {
        top: 0,
        right: l.dir === "ltr" ? 0 : void 0,
        left: l.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        "--radix-scroll-area-thumb-height": Jf(n) + "px",
        ...e.style
      },
      onThumbPointerDown: (m) => e.onThumbPointerDown(m.y),
      onDragScroll: (m) => e.onDragScroll(m.y),
      onWheelScroll: (m, v) => {
        if (l.viewport) {
          const b = l.viewport.scrollTop + m.deltaY;
          e.onWheelScroll(b), hM(b, v) && m.preventDefault();
        }
      },
      onResize: () => {
        d.current && l.viewport && c && o({
          content: l.viewport.scrollHeight,
          viewport: l.viewport.offsetHeight,
          scrollbar: {
            size: d.current.clientHeight,
            paddingStart: vf(c.paddingTop),
            paddingEnd: vf(c.paddingBottom)
          }
        });
      }
    }
  );
}), [WZ, sM] = tM(xr), lM = y.forwardRef((e, t) => {
  const {
    __scopeScrollArea: n,
    sizes: o,
    hasThumb: i,
    onThumbChange: l,
    onThumbPointerUp: c,
    onThumbPointerDown: f,
    onThumbPositionChange: d,
    onDragScroll: h,
    onWheelScroll: m,
    onResize: v,
    ...b
  } = e, x = Hn(xr, n), [E, w] = y.useState(null), C = Le(t, (P) => w(P)), A = y.useRef(null), M = y.useRef(""), T = x.viewport, D = o.content - o.viewport, O = $t(m), k = $t(d), R = Qf(v, 10);
  function N(P) {
    if (A.current) {
      const Y = P.clientX - A.current.left, ne = P.clientY - A.current.top;
      h({ x: Y, y: ne });
    }
  }
  return y.useEffect(() => {
    const P = (Y) => {
      const ne = Y.target;
      E?.contains(ne) && O(Y, D);
    };
    return document.addEventListener("wheel", P, { passive: !1 }), () => document.removeEventListener("wheel", P, { passive: !1 });
  }, [T, E, D, O]), y.useEffect(k, [o, k]), Hi(E, R), Hi(x.content, R), /* @__PURE__ */ S.jsx(
    WZ,
    {
      scope: n,
      scrollbar: E,
      hasThumb: i,
      onThumbChange: $t(l),
      onThumbPointerUp: $t(c),
      onThumbPositionChange: k,
      onThumbPointerDown: $t(f),
      children: /* @__PURE__ */ S.jsx(
        ze.div,
        {
          ...b,
          ref: C,
          style: { position: "absolute", ...b.style },
          onPointerDown: ge(e.onPointerDown, (P) => {
            P.button === 0 && (P.target.setPointerCapture(P.pointerId), A.current = E.getBoundingClientRect(), M.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", x.viewport && (x.viewport.style.scrollBehavior = "auto"), N(P));
          }),
          onPointerMove: ge(e.onPointerMove, N),
          onPointerUp: ge(e.onPointerUp, (P) => {
            const Y = P.target;
            Y.hasPointerCapture(P.pointerId) && Y.releasePointerCapture(P.pointerId), document.body.style.webkitUserSelect = M.current, x.viewport && (x.viewport.style.scrollBehavior = ""), A.current = null;
          })
        }
      )
    }
  );
}), gf = "ScrollAreaThumb", cM = y.forwardRef(
  (e, t) => {
    const { forceMount: n, ...o } = e, i = sM(gf, e.__scopeScrollArea);
    return /* @__PURE__ */ S.jsx(cn, { present: n || i.hasThumb, children: /* @__PURE__ */ S.jsx(XZ, { ref: t, ...o }) });
  }
), XZ = y.forwardRef(
  (e, t) => {
    const { __scopeScrollArea: n, style: o, ...i } = e, l = Hn(gf, n), c = sM(gf, n), { onThumbPositionChange: f } = c, d = Le(
      t,
      (v) => c.onThumbChange(v)
    ), h = y.useRef(void 0), m = Qf(() => {
      h.current && (h.current(), h.current = void 0);
    }, 100);
    return y.useEffect(() => {
      const v = l.viewport;
      if (v) {
        const b = () => {
          if (m(), !h.current) {
            const x = QZ(v, f);
            h.current = x, f();
          }
        };
        return f(), v.addEventListener("scroll", b), () => v.removeEventListener("scroll", b);
      }
    }, [l.viewport, m, f]), /* @__PURE__ */ S.jsx(
      ze.div,
      {
        "data-state": c.hasThumb ? "visible" : "hidden",
        ...i,
        ref: d,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...o
        },
        onPointerDownCapture: ge(e.onPointerDownCapture, (v) => {
          const x = v.target.getBoundingClientRect(), E = v.clientX - x.left, w = v.clientY - x.top;
          c.onThumbPointerDown({ x: E, y: w });
        }),
        onPointerUp: ge(e.onPointerUp, c.onThumbPointerUp)
      }
    );
  }
);
cM.displayName = gf;
var Zv = "ScrollAreaCorner", uM = y.forwardRef(
  (e, t) => {
    const n = Hn(Zv, e.__scopeScrollArea), o = !!(n.scrollbarX && n.scrollbarY);
    return n.type !== "scroll" && o ? /* @__PURE__ */ S.jsx(KZ, { ...e, ref: t }) : null;
  }
);
uM.displayName = Zv;
var KZ = y.forwardRef((e, t) => {
  const { __scopeScrollArea: n, ...o } = e, i = Hn(Zv, n), [l, c] = y.useState(0), [f, d] = y.useState(0), h = !!(l && f);
  return Hi(i.scrollbarX, () => {
    const m = i.scrollbarX?.offsetHeight || 0;
    i.onCornerHeightChange(m), d(m);
  }), Hi(i.scrollbarY, () => {
    const m = i.scrollbarY?.offsetWidth || 0;
    i.onCornerWidthChange(m), c(m);
  }), h ? /* @__PURE__ */ S.jsx(
    ze.div,
    {
      ...o,
      ref: t,
      style: {
        width: l,
        height: f,
        position: "absolute",
        right: i.dir === "ltr" ? 0 : void 0,
        left: i.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...e.style
      }
    }
  ) : null;
});
function vf(e) {
  return e ? parseInt(e, 10) : 0;
}
function fM(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Jf(e) {
  const t = fM(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, o = (e.scrollbar.size - n) * t;
  return Math.max(o, 18);
}
function JZ(e, t, n, o = "ltr") {
  const i = Jf(n), l = i / 2, c = t || l, f = i - c, d = n.scrollbar.paddingStart + c, h = n.scrollbar.size - n.scrollbar.paddingEnd - f, m = n.content - n.viewport, v = o === "ltr" ? [0, m] : [m * -1, 0];
  return dM([d, h], v)(e);
}
function gE(e, t, n = "ltr") {
  const o = Jf(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, l = t.scrollbar.size - i, c = t.content - t.viewport, f = l - o, d = n === "ltr" ? [0, c] : [c * -1, 0], h = pg(e, d);
  return dM([0, c], [0, f])(h);
}
function dM(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const o = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + o * (n - e[0]);
  };
}
function hM(e, t) {
  return e > 0 && e < t;
}
var QZ = (e, t = () => {
}) => {
  let n = { left: e.scrollLeft, top: e.scrollTop }, o = 0;
  return (function i() {
    const l = { left: e.scrollLeft, top: e.scrollTop }, c = n.left !== l.left, f = n.top !== l.top;
    (c || f) && t(), n = l, o = window.requestAnimationFrame(i);
  })(), () => window.cancelAnimationFrame(o);
};
function Qf(e, t) {
  const n = $t(e), o = y.useRef(0);
  return y.useEffect(() => () => window.clearTimeout(o.current), []), y.useCallback(() => {
    window.clearTimeout(o.current), o.current = window.setTimeout(n, t);
  }, [n, t]);
}
function Hi(e, t) {
  const n = $t(t);
  Ht(() => {
    let o = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(o), o = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(o), i.unobserve(e);
      };
    }
  }, [e, n]);
}
var e7 = nM, t7 = oM, n7 = uM;
function pM({
  className: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ S.jsxs(
    e7,
    {
      "data-slot": "scroll-area",
      className: Ge("relative", e),
      ...n,
      children: [
        /* @__PURE__ */ S.jsx(
          t7,
          {
            "data-slot": "scroll-area-viewport",
            className: "focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1",
            children: t
          }
        ),
        /* @__PURE__ */ S.jsx(r7, {}),
        /* @__PURE__ */ S.jsx(n7, {})
      ]
    }
  );
}
function r7({
  className: e,
  orientation: t = "vertical",
  ...n
}) {
  return /* @__PURE__ */ S.jsx(
    aM,
    {
      "data-slot": "scroll-area-scrollbar",
      orientation: t,
      className: Ge(
        "flex touch-none p-px transition-colors select-none",
        t === "vertical" && "h-full w-2.5 border-l border-l-transparent",
        t === "horizontal" && "h-2.5 flex-col border-t border-t-transparent",
        e
      ),
      ...n,
      children: /* @__PURE__ */ S.jsx(
        cM,
        {
          "data-slot": "scroll-area-thumb",
          className: "bg-border relative flex-1 rounded-full"
        }
      )
    }
  );
}
var vm = "rovingFocusGroup.onEntryFocus", o7 = { bubbles: !1, cancelable: !0 }, Gl = "RovingFocusGroup", [xg, mM, a7] = Uv(Gl), [i7, gM] = yr(
  Gl,
  [a7]
), [s7, l7] = i7(Gl), vM = y.forwardRef(
  (e, t) => /* @__PURE__ */ S.jsx(xg.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(xg.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(c7, { ...e, ref: t }) }) })
);
vM.displayName = Gl;
var c7 = y.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: o,
    loop: i = !1,
    dir: l,
    currentTabStopId: c,
    defaultCurrentTabStopId: f,
    onCurrentTabStopIdChange: d,
    onEntryFocus: h,
    preventScrollOnEntryFocus: m = !1,
    ...v
  } = e, b = y.useRef(null), x = Le(t, b), E = qf(l), [w, C] = wa({
    prop: c,
    defaultProp: f ?? null,
    onChange: d,
    caller: Gl
  }), [A, M] = y.useState(!1), T = $t(h), D = mM(n), O = y.useRef(!1), [k, R] = y.useState(0);
  return y.useEffect(() => {
    const N = b.current;
    if (N)
      return N.addEventListener(vm, T), () => N.removeEventListener(vm, T);
  }, [T]), /* @__PURE__ */ S.jsx(
    s7,
    {
      scope: n,
      orientation: o,
      dir: E,
      loop: i,
      currentTabStopId: w,
      onItemFocus: y.useCallback(
        (N) => C(N),
        [C]
      ),
      onItemShiftTab: y.useCallback(() => M(!0), []),
      onFocusableItemAdd: y.useCallback(
        () => R((N) => N + 1),
        []
      ),
      onFocusableItemRemove: y.useCallback(
        () => R((N) => N - 1),
        []
      ),
      children: /* @__PURE__ */ S.jsx(
        ze.div,
        {
          tabIndex: A || k === 0 ? -1 : 0,
          "data-orientation": o,
          ...v,
          ref: x,
          style: { outline: "none", ...e.style },
          onMouseDown: ge(e.onMouseDown, () => {
            O.current = !0;
          }),
          onFocus: ge(e.onFocus, (N) => {
            const P = !O.current;
            if (N.target === N.currentTarget && P && !A) {
              const Y = new CustomEvent(vm, o7);
              if (N.currentTarget.dispatchEvent(Y), !Y.defaultPrevented) {
                const ne = D().filter((I) => I.focusable), J = ne.find((I) => I.active), ce = ne.find((I) => I.id === w), de = [J, ce, ...ne].filter(
                  Boolean
                ).map((I) => I.ref.current);
                xM(de, m);
              }
            }
            O.current = !1;
          }),
          onBlur: ge(e.onBlur, () => M(!1))
        }
      )
    }
  );
}), yM = "RovingFocusGroupItem", bM = y.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: o = !0,
      active: i = !1,
      tabStopId: l,
      children: c,
      ...f
    } = e, d = pr(), h = l || d, m = l7(yM, n), v = m.currentTabStopId === h, b = mM(n), { onFocusableItemAdd: x, onFocusableItemRemove: E, currentTabStopId: w } = m;
    return y.useEffect(() => {
      if (o)
        return x(), () => E();
    }, [o, x, E]), /* @__PURE__ */ S.jsx(
      xg.ItemSlot,
      {
        scope: n,
        id: h,
        focusable: o,
        active: i,
        children: /* @__PURE__ */ S.jsx(
          ze.span,
          {
            tabIndex: v ? 0 : -1,
            "data-orientation": m.orientation,
            ...f,
            ref: t,
            onMouseDown: ge(e.onMouseDown, (C) => {
              o ? m.onItemFocus(h) : C.preventDefault();
            }),
            onFocus: ge(e.onFocus, () => m.onItemFocus(h)),
            onKeyDown: ge(e.onKeyDown, (C) => {
              if (C.key === "Tab" && C.shiftKey) {
                m.onItemShiftTab();
                return;
              }
              if (C.target !== C.currentTarget) return;
              const A = d7(C, m.orientation, m.dir);
              if (A !== void 0) {
                if (C.metaKey || C.ctrlKey || C.altKey || C.shiftKey) return;
                C.preventDefault();
                let T = b().filter((D) => D.focusable).map((D) => D.ref.current);
                if (A === "last") T.reverse();
                else if (A === "prev" || A === "next") {
                  A === "prev" && T.reverse();
                  const D = T.indexOf(C.currentTarget);
                  T = m.loop ? h7(T, D + 1) : T.slice(D + 1);
                }
                setTimeout(() => xM(T));
              }
            }),
            children: typeof c == "function" ? c({ isCurrentTabStop: v, hasTabStop: w != null }) : c
          }
        )
      }
    );
  }
);
bM.displayName = yM;
var u7 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function f7(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function d7(e, t, n) {
  const o = f7(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o)))
    return u7[o];
}
function xM(e, t = !1) {
  const n = document.activeElement;
  for (const o of e)
    if (o === n || (o.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function h7(e, t) {
  return e.map((n, o) => e[(t + o) % e.length]);
}
var p7 = vM, m7 = bM;
// @__NO_SIDE_EFFECTS__
function g7(e) {
  const t = /* @__PURE__ */ v7(e), n = y.forwardRef((o, i) => {
    const { children: l, ...c } = o, f = y.Children.toArray(l), d = f.find(b7);
    if (d) {
      const h = d.props.children, m = f.map((v) => v === d ? y.Children.count(h) > 1 ? y.Children.only(null) : y.isValidElement(h) ? h.props.children : null : v);
      return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: y.isValidElement(h) ? y.cloneElement(h, void 0, m) : null });
    }
    return /* @__PURE__ */ S.jsx(t, { ...c, ref: i, children: l });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function v7(e) {
  const t = y.forwardRef((n, o) => {
    const { children: i, ...l } = n;
    if (y.isValidElement(i)) {
      const c = S7(i), f = x7(l, i.props);
      return i.type !== y.Fragment && (f.ref = o ? qr(o, c) : c), y.cloneElement(i, f);
    }
    return y.Children.count(i) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var y7 = /* @__PURE__ */ Symbol("radix.slottable");
function b7(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === y7;
}
function x7(e, t) {
  const n = { ...t };
  for (const o in t) {
    const i = e[o], l = t[o];
    /^on[A-Z]/.test(o) ? i && l ? n[o] = (...f) => {
      const d = l(...f);
      return i(...f), d;
    } : i && (n[o] = i) : o === "style" ? n[o] = { ...i, ...l } : o === "className" && (n[o] = [i, l].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function S7(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Sg = ["Enter", " "], w7 = ["ArrowDown", "PageUp", "Home"], SM = ["ArrowUp", "PageDown", "End"], E7 = [...w7, ...SM], _7 = {
  ltr: [...Sg, "ArrowRight"],
  rtl: [...Sg, "ArrowLeft"]
}, T7 = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Yl = "Menu", [zl, C7, A7] = Uv(Yl), [Ra, wM] = yr(Yl, [
  A7,
  Qi,
  gM
]), ed = Qi(), EM = gM(), [R7, Ma] = Ra(Yl), [M7, ql] = Ra(Yl), _M = (e) => {
  const { __scopeMenu: t, open: n = !1, children: o, dir: i, onOpenChange: l, modal: c = !0 } = e, f = ed(t), [d, h] = y.useState(null), m = y.useRef(!1), v = $t(l), b = qf(i);
  return y.useEffect(() => {
    const x = () => {
      m.current = !0, document.addEventListener("pointerdown", E, { capture: !0, once: !0 }), document.addEventListener("pointermove", E, { capture: !0, once: !0 });
    }, E = () => m.current = !1;
    return document.addEventListener("keydown", x, { capture: !0 }), () => {
      document.removeEventListener("keydown", x, { capture: !0 }), document.removeEventListener("pointerdown", E, { capture: !0 }), document.removeEventListener("pointermove", E, { capture: !0 });
    };
  }, []), /* @__PURE__ */ S.jsx(_v, { ...f, children: /* @__PURE__ */ S.jsx(
    R7,
    {
      scope: t,
      open: n,
      onOpenChange: v,
      content: d,
      onContentChange: h,
      children: /* @__PURE__ */ S.jsx(
        M7,
        {
          scope: t,
          onClose: y.useCallback(() => v(!1), [v]),
          isUsingKeyboardRef: m,
          dir: b,
          modal: c,
          children: o
        }
      )
    }
  ) });
};
_M.displayName = Yl;
var z7 = "MenuAnchor", Fv = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e, i = ed(n);
    return /* @__PURE__ */ S.jsx(Tv, { ...i, ...o, ref: t });
  }
);
Fv.displayName = z7;
var Gv = "MenuPortal", [D7, TM] = Ra(Gv, {
  forceMount: void 0
}), CM = (e) => {
  const { __scopeMenu: t, forceMount: n, children: o, container: i } = e, l = Ma(Gv, t);
  return /* @__PURE__ */ S.jsx(D7, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(cn, { present: n || l.open, children: /* @__PURE__ */ S.jsx(Zl, { asChild: !0, container: i, children: o }) }) });
};
CM.displayName = Gv;
var Un = "MenuContent", [N7, Yv] = Ra(Un), AM = y.forwardRef(
  (e, t) => {
    const n = TM(Un, e.__scopeMenu), { forceMount: o = n.forceMount, ...i } = e, l = Ma(Un, e.__scopeMenu), c = ql(Un, e.__scopeMenu);
    return /* @__PURE__ */ S.jsx(zl.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(cn, { present: o || l.open, children: /* @__PURE__ */ S.jsx(zl.Slot, { scope: e.__scopeMenu, children: c.modal ? /* @__PURE__ */ S.jsx(O7, { ...i, ref: t }) : /* @__PURE__ */ S.jsx(j7, { ...i, ref: t }) }) }) });
  }
), O7 = y.forwardRef(
  (e, t) => {
    const n = Ma(Un, e.__scopeMenu), o = y.useRef(null), i = Le(t, o);
    return y.useEffect(() => {
      const l = o.current;
      if (l) return Nv(l);
    }, []), /* @__PURE__ */ S.jsx(
      qv,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: ge(
          e.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), j7 = y.forwardRef((e, t) => {
  const n = Ma(Un, e.__scopeMenu);
  return /* @__PURE__ */ S.jsx(
    qv,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), k7 = /* @__PURE__ */ g7("MenuContent.ScrollLock"), qv = y.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: o = !1,
      trapFocus: i,
      onOpenAutoFocus: l,
      onCloseAutoFocus: c,
      disableOutsidePointerEvents: f,
      onEntryFocus: d,
      onEscapeKeyDown: h,
      onPointerDownOutside: m,
      onFocusOutside: v,
      onInteractOutside: b,
      onDismiss: x,
      disableOutsideScroll: E,
      ...w
    } = e, C = Ma(Un, n), A = ql(Un, n), M = ed(n), T = EM(n), D = C7(n), [O, k] = y.useState(null), R = y.useRef(null), N = Le(t, R, C.onContentChange), P = y.useRef(0), Y = y.useRef(""), ne = y.useRef(0), J = y.useRef(null), ce = y.useRef("right"), ue = y.useRef(0), de = E ? Gf : y.Fragment, I = E ? { as: k7, allowPinchZoom: !0 } : void 0, G = (te) => {
      const he = Y.current + te, j = D().filter((H) => !H.disabled), W = document.activeElement, $ = j.find((H) => H.ref.current === W)?.textValue, X = j.map((H) => H.textValue), se = Y7(X, he, $), ie = j.find((H) => H.textValue === se)?.ref.current;
      (function H(re) {
        Y.current = re, window.clearTimeout(P.current), re !== "" && (P.current = window.setTimeout(() => H(""), 1e3));
      })(he), ie && setTimeout(() => ie.focus());
    };
    y.useEffect(() => () => window.clearTimeout(P.current), []), Dv();
    const U = y.useCallback((te) => ce.current === J.current?.side && W7(te, J.current?.area), []);
    return /* @__PURE__ */ S.jsx(
      N7,
      {
        scope: n,
        searchRef: Y,
        onItemEnter: y.useCallback(
          (te) => {
            U(te) && te.preventDefault();
          },
          [U]
        ),
        onItemLeave: y.useCallback(
          (te) => {
            U(te) || (R.current?.focus(), k(null));
          },
          [U]
        ),
        onTriggerLeave: y.useCallback(
          (te) => {
            U(te) && te.preventDefault();
          },
          [U]
        ),
        pointerGraceTimerRef: ne,
        onPointerGraceIntentChange: y.useCallback((te) => {
          J.current = te;
        }, []),
        children: /* @__PURE__ */ S.jsx(de, { ...I, children: /* @__PURE__ */ S.jsx(
          Zf,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: ge(l, (te) => {
              te.preventDefault(), R.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: c,
            children: /* @__PURE__ */ S.jsx(
              $l,
              {
                asChild: !0,
                disableOutsidePointerEvents: f,
                onEscapeKeyDown: h,
                onPointerDownOutside: m,
                onFocusOutside: v,
                onInteractOutside: b,
                onDismiss: x,
                children: /* @__PURE__ */ S.jsx(
                  p7,
                  {
                    asChild: !0,
                    ...T,
                    dir: A.dir,
                    orientation: "vertical",
                    loop: o,
                    currentTabStopId: O,
                    onCurrentTabStopIdChange: k,
                    onEntryFocus: ge(d, (te) => {
                      A.isUsingKeyboardRef.current || te.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ S.jsx(
                      Cv,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": HM(C.open),
                        "data-radix-menu-content": "",
                        dir: A.dir,
                        ...M,
                        ...w,
                        ref: N,
                        style: { outline: "none", ...w.style },
                        onKeyDown: ge(w.onKeyDown, (te) => {
                          const j = te.target.closest("[data-radix-menu-content]") === te.currentTarget, W = te.ctrlKey || te.altKey || te.metaKey, $ = te.key.length === 1;
                          j && (te.key === "Tab" && te.preventDefault(), !W && $ && G(te.key));
                          const X = R.current;
                          if (te.target !== X || !E7.includes(te.key)) return;
                          te.preventDefault();
                          const ie = D().filter((H) => !H.disabled).map((H) => H.ref.current);
                          SM.includes(te.key) && ie.reverse(), F7(ie);
                        }),
                        onBlur: ge(e.onBlur, (te) => {
                          te.currentTarget.contains(te.target) || (window.clearTimeout(P.current), Y.current = "");
                        }),
                        onPointerMove: ge(
                          e.onPointerMove,
                          Dl((te) => {
                            const he = te.target, j = ue.current !== te.clientX;
                            if (te.currentTarget.contains(he) && j) {
                              const W = te.clientX > ue.current ? "right" : "left";
                              ce.current = W, ue.current = te.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
AM.displayName = Un;
var P7 = "MenuGroup", Wv = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(ze.div, { role: "group", ...o, ref: t });
  }
);
Wv.displayName = P7;
var L7 = "MenuLabel", RM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(ze.div, { ...o, ref: t });
  }
);
RM.displayName = L7;
var yf = "MenuItem", vE = "menu.itemSelect", td = y.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: o, ...i } = e, l = y.useRef(null), c = ql(yf, e.__scopeMenu), f = Yv(yf, e.__scopeMenu), d = Le(t, l), h = y.useRef(!1), m = () => {
      const v = l.current;
      if (!n && v) {
        const b = new CustomEvent(vE, { bubbles: !0, cancelable: !0 });
        v.addEventListener(vE, (x) => o?.(x), { once: !0 }), gA(v, b), b.defaultPrevented ? h.current = !1 : c.onClose();
      }
    };
    return /* @__PURE__ */ S.jsx(
      MM,
      {
        ...i,
        ref: d,
        disabled: n,
        onClick: ge(e.onClick, m),
        onPointerDown: (v) => {
          e.onPointerDown?.(v), h.current = !0;
        },
        onPointerUp: ge(e.onPointerUp, (v) => {
          h.current || v.currentTarget?.click();
        }),
        onKeyDown: ge(e.onKeyDown, (v) => {
          const b = f.searchRef.current !== "";
          n || b && v.key === " " || Sg.includes(v.key) && (v.currentTarget.click(), v.preventDefault());
        })
      }
    );
  }
);
td.displayName = yf;
var MM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: o = !1, textValue: i, ...l } = e, c = Yv(yf, n), f = EM(n), d = y.useRef(null), h = Le(t, d), [m, v] = y.useState(!1), [b, x] = y.useState("");
    return y.useEffect(() => {
      const E = d.current;
      E && x((E.textContent ?? "").trim());
    }, [l.children]), /* @__PURE__ */ S.jsx(
      zl.ItemSlot,
      {
        scope: n,
        disabled: o,
        textValue: i ?? b,
        children: /* @__PURE__ */ S.jsx(m7, { asChild: !0, ...f, focusable: !o, children: /* @__PURE__ */ S.jsx(
          ze.div,
          {
            role: "menuitem",
            "data-highlighted": m ? "" : void 0,
            "aria-disabled": o || void 0,
            "data-disabled": o ? "" : void 0,
            ...l,
            ref: h,
            onPointerMove: ge(
              e.onPointerMove,
              Dl((E) => {
                o ? c.onItemLeave(E) : (c.onItemEnter(E), E.defaultPrevented || E.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: ge(
              e.onPointerLeave,
              Dl((E) => c.onItemLeave(E))
            ),
            onFocus: ge(e.onFocus, () => v(!0)),
            onBlur: ge(e.onBlur, () => v(!1))
          }
        ) })
      }
    );
  }
), I7 = "MenuCheckboxItem", zM = y.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: o, ...i } = e;
    return /* @__PURE__ */ S.jsx(kM, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ S.jsx(
      td,
      {
        role: "menuitemcheckbox",
        "aria-checked": bf(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": Kv(n),
        onSelect: ge(
          i.onSelect,
          () => o?.(bf(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
zM.displayName = I7;
var DM = "MenuRadioGroup", [V7, U7] = Ra(
  DM,
  { value: void 0, onValueChange: () => {
  } }
), NM = y.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: o, ...i } = e, l = $t(o);
    return /* @__PURE__ */ S.jsx(V7, { scope: e.__scopeMenu, value: n, onValueChange: l, children: /* @__PURE__ */ S.jsx(Wv, { ...i, ref: t }) });
  }
);
NM.displayName = DM;
var OM = "MenuRadioItem", jM = y.forwardRef(
  (e, t) => {
    const { value: n, ...o } = e, i = U7(OM, e.__scopeMenu), l = n === i.value;
    return /* @__PURE__ */ S.jsx(kM, { scope: e.__scopeMenu, checked: l, children: /* @__PURE__ */ S.jsx(
      td,
      {
        role: "menuitemradio",
        "aria-checked": l,
        ...o,
        ref: t,
        "data-state": Kv(l),
        onSelect: ge(
          o.onSelect,
          () => i.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
jM.displayName = OM;
var Xv = "MenuItemIndicator", [kM, B7] = Ra(
  Xv,
  { checked: !1 }
), PM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: o, ...i } = e, l = B7(Xv, n);
    return /* @__PURE__ */ S.jsx(
      cn,
      {
        present: o || bf(l.checked) || l.checked === !0,
        children: /* @__PURE__ */ S.jsx(
          ze.span,
          {
            ...i,
            ref: t,
            "data-state": Kv(l.checked)
          }
        )
      }
    );
  }
);
PM.displayName = Xv;
var $7 = "MenuSeparator", LM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e;
    return /* @__PURE__ */ S.jsx(
      ze.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...o,
        ref: t
      }
    );
  }
);
LM.displayName = $7;
var H7 = "MenuArrow", IM = y.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...o } = e, i = ed(n);
    return /* @__PURE__ */ S.jsx(Av, { ...i, ...o, ref: t });
  }
);
IM.displayName = H7;
var Z7 = "MenuSub", [cY, VM] = Ra(Z7), ul = "MenuSubTrigger", UM = y.forwardRef(
  (e, t) => {
    const n = Ma(ul, e.__scopeMenu), o = ql(ul, e.__scopeMenu), i = VM(ul, e.__scopeMenu), l = Yv(ul, e.__scopeMenu), c = y.useRef(null), { pointerGraceTimerRef: f, onPointerGraceIntentChange: d } = l, h = { __scopeMenu: e.__scopeMenu }, m = y.useCallback(() => {
      c.current && window.clearTimeout(c.current), c.current = null;
    }, []);
    return y.useEffect(() => m, [m]), y.useEffect(() => {
      const v = f.current;
      return () => {
        window.clearTimeout(v), d(null);
      };
    }, [f, d]), /* @__PURE__ */ S.jsx(Fv, { asChild: !0, ...h, children: /* @__PURE__ */ S.jsx(
      MM,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": HM(n.open),
        ...e,
        ref: qr(t, i.onTriggerChange),
        onClick: (v) => {
          e.onClick?.(v), !(e.disabled || v.defaultPrevented) && (v.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: ge(
          e.onPointerMove,
          Dl((v) => {
            l.onItemEnter(v), !v.defaultPrevented && !e.disabled && !n.open && !c.current && (l.onPointerGraceIntentChange(null), c.current = window.setTimeout(() => {
              n.onOpenChange(!0), m();
            }, 100));
          })
        ),
        onPointerLeave: ge(
          e.onPointerLeave,
          Dl((v) => {
            m();
            const b = n.content?.getBoundingClientRect();
            if (b) {
              const x = n.content?.dataset.side, E = x === "right", w = E ? -5 : 5, C = b[E ? "left" : "right"], A = b[E ? "right" : "left"];
              l.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: v.clientX + w, y: v.clientY },
                  { x: C, y: b.top },
                  { x: A, y: b.top },
                  { x: A, y: b.bottom },
                  { x: C, y: b.bottom }
                ],
                side: x
              }), window.clearTimeout(f.current), f.current = window.setTimeout(
                () => l.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (l.onTriggerLeave(v), v.defaultPrevented) return;
              l.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: ge(e.onKeyDown, (v) => {
          const b = l.searchRef.current !== "";
          e.disabled || b && v.key === " " || _7[o.dir].includes(v.key) && (n.onOpenChange(!0), n.content?.focus(), v.preventDefault());
        })
      }
    ) });
  }
);
UM.displayName = ul;
var BM = "MenuSubContent", $M = y.forwardRef(
  (e, t) => {
    const n = TM(Un, e.__scopeMenu), { forceMount: o = n.forceMount, ...i } = e, l = Ma(Un, e.__scopeMenu), c = ql(Un, e.__scopeMenu), f = VM(BM, e.__scopeMenu), d = y.useRef(null), h = Le(t, d);
    return /* @__PURE__ */ S.jsx(zl.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(cn, { present: o || l.open, children: /* @__PURE__ */ S.jsx(zl.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(
      qv,
      {
        id: f.contentId,
        "aria-labelledby": f.triggerId,
        ...i,
        ref: h,
        align: "start",
        side: c.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (m) => {
          c.isUsingKeyboardRef.current && d.current?.focus(), m.preventDefault();
        },
        onCloseAutoFocus: (m) => m.preventDefault(),
        onFocusOutside: ge(e.onFocusOutside, (m) => {
          m.target !== f.trigger && l.onOpenChange(!1);
        }),
        onEscapeKeyDown: ge(e.onEscapeKeyDown, (m) => {
          c.onClose(), m.preventDefault();
        }),
        onKeyDown: ge(e.onKeyDown, (m) => {
          const v = m.currentTarget.contains(m.target), b = T7[c.dir].includes(m.key);
          v && b && (l.onOpenChange(!1), f.trigger?.focus(), m.preventDefault());
        })
      }
    ) }) }) });
  }
);
$M.displayName = BM;
function HM(e) {
  return e ? "open" : "closed";
}
function bf(e) {
  return e === "indeterminate";
}
function Kv(e) {
  return bf(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function F7(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function G7(e, t) {
  return e.map((n, o) => e[(t + o) % e.length]);
}
function Y7(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((h) => h === t[0]) ? t[0] : t, l = n ? e.indexOf(n) : -1;
  let c = G7(e, Math.max(l, 0));
  i.length === 1 && (c = c.filter((h) => h !== n));
  const d = c.find(
    (h) => h.toLowerCase().startsWith(i.toLowerCase())
  );
  return d !== n ? d : void 0;
}
function q7(e, t) {
  const { x: n, y: o } = e;
  let i = !1;
  for (let l = 0, c = t.length - 1; l < t.length; c = l++) {
    const f = t[l], d = t[c], h = f.x, m = f.y, v = d.x, b = d.y;
    m > o != b > o && n < (v - h) * (o - m) / (b - m) + h && (i = !i);
  }
  return i;
}
function W7(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return q7(n, t);
}
function Dl(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var X7 = _M, K7 = Fv, J7 = CM, Q7 = AM, eF = Wv, tF = RM, nF = td, rF = zM, oF = NM, aF = jM, iF = PM, sF = LM, lF = IM, cF = UM, uF = $M, nd = "DropdownMenu", [fF] = yr(
  nd,
  [wM]
), Qt = wM(), [dF, ZM] = fF(nd), FM = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: o,
    open: i,
    defaultOpen: l,
    onOpenChange: c,
    modal: f = !0
  } = e, d = Qt(t), h = y.useRef(null), [m, v] = wa({
    prop: i,
    defaultProp: l ?? !1,
    onChange: c,
    caller: nd
  });
  return /* @__PURE__ */ S.jsx(
    dF,
    {
      scope: t,
      triggerId: pr(),
      triggerRef: h,
      contentId: pr(),
      open: m,
      onOpenChange: v,
      onOpenToggle: y.useCallback(() => v((b) => !b), [v]),
      modal: f,
      children: /* @__PURE__ */ S.jsx(X7, { ...d, open: m, onOpenChange: v, dir: o, modal: f, children: n })
    }
  );
};
FM.displayName = nd;
var GM = "DropdownMenuTrigger", YM = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: o = !1, ...i } = e, l = ZM(GM, n), c = Qt(n);
    return /* @__PURE__ */ S.jsx(K7, { asChild: !0, ...c, children: /* @__PURE__ */ S.jsx(
      ze.button,
      {
        type: "button",
        id: l.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": l.open,
        "aria-controls": l.open ? l.contentId : void 0,
        "data-state": l.open ? "open" : "closed",
        "data-disabled": o ? "" : void 0,
        disabled: o,
        ...i,
        ref: qr(t, l.triggerRef),
        onPointerDown: ge(e.onPointerDown, (f) => {
          !o && f.button === 0 && f.ctrlKey === !1 && (l.onOpenToggle(), l.open || f.preventDefault());
        }),
        onKeyDown: ge(e.onKeyDown, (f) => {
          o || (["Enter", " "].includes(f.key) && l.onOpenToggle(), f.key === "ArrowDown" && l.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(f.key) && f.preventDefault());
        })
      }
    ) });
  }
);
YM.displayName = GM;
var hF = "DropdownMenuPortal", qM = (e) => {
  const { __scopeDropdownMenu: t, ...n } = e, o = Qt(t);
  return /* @__PURE__ */ S.jsx(J7, { ...o, ...n });
};
qM.displayName = hF;
var WM = "DropdownMenuContent", XM = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, i = ZM(WM, n), l = Qt(n), c = y.useRef(!1);
    return /* @__PURE__ */ S.jsx(
      Q7,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...l,
        ...o,
        ref: t,
        onCloseAutoFocus: ge(e.onCloseAutoFocus, (f) => {
          c.current || i.triggerRef.current?.focus(), c.current = !1, f.preventDefault();
        }),
        onInteractOutside: ge(e.onInteractOutside, (f) => {
          const d = f.detail.originalEvent, h = d.button === 0 && d.ctrlKey === !0, m = d.button === 2 || h;
          (!i.modal || m) && (c.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
XM.displayName = WM;
var pF = "DropdownMenuGroup", mF = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
    return /* @__PURE__ */ S.jsx(eF, { ...i, ...o, ref: t });
  }
);
mF.displayName = pF;
var gF = "DropdownMenuLabel", vF = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
    return /* @__PURE__ */ S.jsx(tF, { ...i, ...o, ref: t });
  }
);
vF.displayName = gF;
var yF = "DropdownMenuItem", KM = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
    return /* @__PURE__ */ S.jsx(nF, { ...i, ...o, ref: t });
  }
);
KM.displayName = yF;
var bF = "DropdownMenuCheckboxItem", xF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(rF, { ...i, ...o, ref: t });
});
xF.displayName = bF;
var SF = "DropdownMenuRadioGroup", wF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(oF, { ...i, ...o, ref: t });
});
wF.displayName = SF;
var EF = "DropdownMenuRadioItem", _F = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(aF, { ...i, ...o, ref: t });
});
_F.displayName = EF;
var TF = "DropdownMenuItemIndicator", CF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(iF, { ...i, ...o, ref: t });
});
CF.displayName = TF;
var AF = "DropdownMenuSeparator", RF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(sF, { ...i, ...o, ref: t });
});
RF.displayName = AF;
var MF = "DropdownMenuArrow", zF = y.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
    return /* @__PURE__ */ S.jsx(lF, { ...i, ...o, ref: t });
  }
);
zF.displayName = MF;
var DF = "DropdownMenuSubTrigger", NF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(cF, { ...i, ...o, ref: t });
});
NF.displayName = DF;
var OF = "DropdownMenuSubContent", jF = y.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...o } = e, i = Qt(n);
  return /* @__PURE__ */ S.jsx(
    uF,
    {
      ...i,
      ...o,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
jF.displayName = OF;
var kF = FM, PF = YM, LF = qM, IF = XM, VF = KM;
function JM({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(kF, { "data-slot": "dropdown-menu", ...e });
}
function QM({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(
    PF,
    {
      "data-slot": "dropdown-menu-trigger",
      ...e
    }
  );
}
function ez({
  className: e,
  sideOffset: t = 4,
  ...n
}) {
  return /* @__PURE__ */ S.jsx(LF, { children: /* @__PURE__ */ S.jsx(
    IF,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: t,
      className: Ge(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        e
      ),
      ...n,
      onCloseAutoFocus: (o) => {
        o.preventDefault(), document.body.style.pointerEvents = "";
      }
    }
  ) });
}
function Zu({
  className: e,
  inset: t,
  variant: n = "default",
  ...o
}) {
  return /* @__PURE__ */ S.jsx(
    VF,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": t,
      "data-variant": n,
      className: Ge(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...o
    }
  );
}
function UF({ className: e, type: t, ...n }) {
  return /* @__PURE__ */ S.jsx(
    "input",
    {
      type: t,
      "data-slot": "input",
      className: Ge(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-sm border bg-transparent px-3 py-1 text-xs shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50",
        "focus:border-input focus-visible:border-input",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        e
      ),
      ...n
    }
  );
}
function BF({
  open: e,
  onConfirm: t,
  onCancel: n
}) {
  return /* @__PURE__ */ S.jsx(Pv, { open: e, onOpenChange: n, children: /* @__PURE__ */ S.jsxs(Lv, { className: "max-w-md", children: [
    /* @__PURE__ */ S.jsxs(Iv, { children: [
      /* @__PURE__ */ S.jsx(Vv, { children: "Delete Conversation" }),
      /* @__PURE__ */ S.jsx("p", { className: "text-xs italic text-muted-foreground mt-1", children: "Are you sure you want to delete this conversation? This action is irreversible and you will not be able to recover the deleted messages." })
    ] }),
    /* @__PURE__ */ S.jsxs(ER, { children: [
      /* @__PURE__ */ S.jsx(
        Nt,
        {
          variant: "outline",
          onClick: n,
          type: "button",
          className: "cursor-pointer",
          children: "Cancel"
        }
      ),
      /* @__PURE__ */ S.jsx(
        Nt,
        {
          variant: "destructive",
          onClick: t,
          type: "button",
          className: "cursor-pointer",
          children: "Delete Conversation"
        }
      )
    ] })
  ] }) });
}
const tz = ({
  message: e = "Loading..."
}) => /* @__PURE__ */ S.jsx("div", { className: "flex items-center justify-center h-full m-auto p-4", children: /* @__PURE__ */ S.jsxs("div", { className: "flex flex-col items-center gap-3", children: [
  /* @__PURE__ */ S.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary" }),
  /* @__PURE__ */ S.jsx("p", { className: "text-sm text-muted-foreground", children: e })
] }) }), nz = "chatbot.threads.v1", Jv = "chatbot:threads-updated";
function Qv(e) {
  return `chatbot.thread.${e}.messages.v1`;
}
function rz(e) {
  if (!e) return null;
  try {
    return JSON.parse(e);
  } catch {
    return null;
  }
}
function va() {
  const e = rz(localStorage.getItem(nz));
  return (Array.isArray(e) ? e : []).filter((n) => n && typeof n.id == "string").map((n) => ({
    id: String(n.id),
    title: typeof n.title == "string" ? n.title : "New chat",
    createdAt: typeof n.createdAt == "number" ? n.createdAt : Date.now(),
    updatedAt: typeof n.updatedAt == "number" ? n.updatedAt : Date.now()
  })).sort((n, o) => o.updatedAt - n.updatedAt);
}
function xf(e) {
  localStorage.setItem(nz, JSON.stringify(e)), window.dispatchEvent(new Event(Jv));
}
function $F(e, t) {
  const n = Date.now(), o = va(), i = o.find((d) => d.id === e), l = (t ?? "").trim();
  if (!i) {
    xf([
      {
        id: e,
        title: l || "New chat",
        createdAt: n,
        updatedAt: n
      },
      ...o
    ]);
    return;
  }
  const f = (!i.title || i.title.trim() === "" || i.title === "New chat") && l ? l : i.title;
  xf(
    o.map(
      (d) => d.id === e ? {
        ...d,
        title: f,
        updatedAt: n
      } : d
    )
  );
}
function HF(e, t) {
  const n = t.trim();
  if (!n) return;
  const o = va();
  xf(
    o.map((i) => i.id === e ? { ...i, title: n, updatedAt: Date.now() } : i)
  );
}
function ZF(e) {
  const t = va();
  xf(t.filter((n) => n.id !== e)), localStorage.removeItem(Qv(e)), window.dispatchEvent(new Event(Jv));
}
function FF(e) {
  const t = rz(localStorage.getItem(Qv(e)));
  return Array.isArray(t) ? t : [];
}
function GF(e, t) {
  localStorage.setItem(Qv(e), JSON.stringify(t)), window.dispatchEvent(new Event(Jv));
}
function Sf(e) {
  if (typeof e == "number" && Number.isFinite(e)) return e;
  if (typeof e == "string") {
    const t = Date.parse(e);
    if (!Number.isNaN(t)) return t;
  }
  return Date.now();
}
function oz(e) {
  if (!e || typeof e != "object") return null;
  const t = String(e.id ?? e.threadId ?? "");
  return t ? {
    id: t,
    title: typeof e.title == "string" ? e.title : null,
    createdAt: e.createdAt ?? e.created_at ?? null,
    updatedAt: e.updatedAt ?? e.updated_at ?? null
  } : null;
}
function YF(e) {
  return (Array.isArray(e) ? e : Array.isArray(e?.threads) ? e.threads : Array.isArray(e?.data) ? e.data : []).map(oz).filter((n) => !!n).map((n) => ({
    ...n,
    createdAt: Sf(n.createdAt),
    updatedAt: Sf(n.updatedAt)
  })).sort((n, o) => o.updatedAt - n.updatedAt);
}
async function az() {
  const e = localStorage.getItem("access_token");
  return e ? { Authorization: `Bearer ${e}` } : {};
}
async function qF(e, t) {
  const n = t.trim();
  if (!n) return [];
  const o = await az(), i = new URL("/api/v1/thread", e), l = await fetch(i.toString(), { headers: { ...o, userId: n } });
  if (!l.ok) {
    if ((l.headers.get("content-type") ?? "").includes("application/json")) {
      const h = await l.json().catch(() => null), m = h?.message || h?.error || h?.details || `Failed to fetch threads (${l.status})`;
      throw new Error(typeof m == "string" ? m : `Failed to fetch threads (${l.status})`);
    }
    const d = await l.text().catch(() => "");
    throw new Error(d || `Failed to fetch threads (${l.status})`);
  }
  const c = await l.json().catch(() => null);
  return YF(c);
}
function WF(e) {
  return (Array.isArray(e?.messages) ? e.messages : Array.isArray(e?.data) ? e.data : []).filter((n) => n && typeof n == "object").map((n) => ({
    id: String(n.id ?? ""),
    threadId: n.threadId ? String(n.threadId) : void 0,
    role: String(n.role ?? ""),
    parts: Array.isArray(n.parts) ? n.parts : [],
    metadata: n.metadata,
    createdAt: n.createdAt ?? n.created_at ?? null,
    updatedAt: n.updatedAt ?? n.updated_at ?? null
  })).filter((n) => !!n.id && !!n.role);
}
async function XF(e) {
  if (e.ok) return e.json().catch(() => null);
  if ((e.headers.get("content-type") ?? "").includes("application/json")) {
    const o = await e.json().catch(() => null), i = o?.message || o?.error || o?.details || `Request failed (${e.status})`;
    throw new Error(typeof i == "string" ? i : `Request failed (${e.status})`);
  }
  const n = await e.text().catch(() => "");
  throw new Error(n || `Request failed (${e.status})`);
}
async function KF(e, t, n) {
  const o = t.trim(), i = n.trim();
  if (!o) throw new Error("Missing userId");
  if (!i) throw new Error("Missing threadId");
  const l = await az(), c = new URL(`/api/v1/thread/${encodeURIComponent(i)}`, e), f = await fetch(c.toString(), { headers: { ...l, userId: o } }), d = await XF(f), h = oz(d) ?? { id: i }, m = Array.isArray(d?.messages) ? d.messages : [];
  return {
    ...h,
    createdAt: Sf(h.createdAt),
    updatedAt: Sf(h.updatedAt),
    messages: WF({ messages: m })
  };
}
function JF() {
  return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
}
function QF(e) {
  const t = new Date(e), n = /* @__PURE__ */ new Date(), o = new Date(n.getFullYear(), n.getMonth(), n.getDate()), i = new Date(t.getFullYear(), t.getMonth(), t.getDate()), l = new Date(o);
  l.setDate(l.getDate() - 1);
  const c = o.getTime() - i.getTime(), f = Math.floor(c / (1e3 * 60 * 60 * 24));
  return f === 0 ? "Today" : f === 1 ? "Yesterday" : f < 7 ? "Last 7 days" : f < 30 ? "Last 30 days" : "Older";
}
function eG(e) {
  const t = {
    Today: [],
    Yesterday: [],
    "Last 7 days": [],
    "Last 30 days": [],
    Older: []
  };
  return e.forEach((n) => {
    const o = QF(n.updatedAt);
    t[o].push(n);
  }), t;
}
function yE(e) {
  return e.map((t) => ({
    id: t.id,
    title: t.title,
    createdAt: t.createdAt,
    updatedAt: t.updatedAt
  }));
}
function tG(e) {
  return e.map((t) => ({
    id: t.id,
    title: t.title ?? "New conversation",
    createdAt: typeof t.createdAt == "number" ? t.createdAt : Date.now(),
    updatedAt: typeof t.updatedAt == "number" ? t.updatedAt : Date.now()
  }));
}
function nG({
  isOpen: e,
  currentChatId: t,
  onThreadSelect: n,
  onNewThread: o,
  apiBaseUrl: i,
  userId: l,
  isLoadingThread: c = !1,
  className: f
}) {
  const [d, h] = y.useState(!1), [m, v] = y.useState(
    null
  ), [b, x] = y.useState(null), [E, w] = y.useState(!1), [C, A] = y.useState(null), [M, T] = y.useState(null), [D, O] = y.useState(""), [k, R] = y.useState(""), [N, P] = y.useState(
    /* @__PURE__ */ new Set()
  ), [Y, ne] = y.useState(
    /* @__PURE__ */ new Set()
  ), [J, ce] = y.useState(null), ue = y.useRef(null), [de, I] = y.useState([]);
  y.useEffect(() => {
    e && I(va());
  }, [e]), y.useEffect(() => {
    if (!e) return;
    const re = () => I(va());
    return window.addEventListener("chatbot:threads-updated", re), () => window.removeEventListener("chatbot:threads-updated", re);
  }, [e]), y.useEffect(() => {
    M && setTimeout(() => ue.current?.focus(), 0);
  }, [M]), y.useEffect(() => {
    const re = de.map((me) => me.id), le = new Set(re), fe = re.filter((me) => !Y.has(me));
    if (fe.length > 0) {
      P(new Set(fe));
      const me = setTimeout(() => P(/* @__PURE__ */ new Set()), 400);
      return () => clearTimeout(me);
    }
    (Y.size !== le.size || !Array.from(le).every((me) => Y.has(me))) && ne(le);
  }, [de, Y]), y.useEffect(() => {
    if (!e) return;
    let re = !1;
    return (async () => {
      h(!0);
      try {
        const fe = await qF(i, l);
        if (re) return;
        v(fe);
      } catch {
        if (re) return;
        v(null);
      } finally {
        if (re) return;
        h(!1);
      }
    })(), () => {
      re = !0;
    };
  }, [i, e, l]);
  const G = y.useMemo(
    () => new Set((m ?? []).map((re) => re.id)),
    [m]
  ), U = y.useMemo(() => {
    if (m !== null) {
      const re = tG(m);
      return [...yE(de).filter((me) => !G.has(me.id)), ...re].sort(
        (me, Re) => Re.updatedAt - me.updatedAt
      );
    }
    return yE(de);
  }, [de, G, m]), te = y.useMemo(
    () => eG(U),
    [U]
  ), he = (re, le) => {
    le.stopPropagation(), A(re), w(!0);
  }, j = async () => {
    if (C)
      try {
        x(C), await new Promise((re) => setTimeout(re, 300)), ZF(C), I(va()), t === C && ce(null);
      } finally {
        w(!1), x(null), A(null);
      }
  }, W = () => {
    w(!1), A(null);
  }, $ = () => {
    const re = JF();
    ce(re), o?.(re), n(re);
  }, X = async (re) => {
    const le = U.find((fe) => fe.id === re);
    if (!(!le || !le.title))
      try {
        await navigator.clipboard.writeText(le.title);
      } catch {
      }
  }, se = (re) => {
    const fe = U.find((me) => me.id === re)?.title || "";
    T(re), O(fe), R(fe);
  }, ie = (re) => {
    const le = D.trim();
    if (!le || le === k.trim()) return H();
    HF(re, le), I(va()), T(null), O(""), R("");
  }, H = () => {
    T(null), O(""), R("");
  };
  return e ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
    /* @__PURE__ */ S.jsx(
      BF,
      {
        open: E,
        onConfirm: j,
        onCancel: W
      }
    ),
    /* @__PURE__ */ S.jsx(zv, { delayDuration: 50, children: /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: Ge(
          " h-full flex flex-col bg-background border-r border-border",
          f
        ),
        children: [
          /* @__PURE__ */ S.jsxs("div", { className: "w-full p-4 border-b border-border shrink-0", children: [
            /* @__PURE__ */ S.jsxs("div", { className: "flex items-center justify-between gap-2 flex-wrap", children: [
              /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ S.jsx(zS, { className: "h-5 w-5 text-blue-500" }),
                /* @__PURE__ */ S.jsx("h3", { className: "font-semibold text-foreground", children: "Conversations" })
              ] }),
              /* @__PURE__ */ S.jsxs(il, { children: [
                /* @__PURE__ */ S.jsx(sl, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                  Nt,
                  {
                    variant: "ghost",
                    size: "icon",
                    className: "h-4 w-4 p-1 text-revert transition-colors hover:bg-blue-100 hover:text-blue-600 dark:hover:bg-blue-950/20 cursor-pointer",
                    onClick: $,
                    disabled: d,
                    "aria-label": "Create new conversation",
                    type: "button",
                    children: /* @__PURE__ */ S.jsx(x2, { className: "h-4 w-4" })
                  }
                ) }),
                /* @__PURE__ */ S.jsx(ll, { children: "Create new conversation" })
              ] })
            ] }),
            /* @__PURE__ */ S.jsxs("p", { className: "text-sm text-muted-foreground mt-1", children: [
              U.length,
              " saved conversations"
            ] })
          ] }),
          /* @__PURE__ */ S.jsx("div", { className: "flex-1 w-full min-h-0", children: /* @__PURE__ */ S.jsx(pM, { className: "h-full w-full", children: d ? /* @__PURE__ */ S.jsx(tz, { message: "Loading conversations..." }) : U.length === 0 ? /* @__PURE__ */ S.jsxs("div", { className: "p-4 text-center text-muted-foreground", children: [
            /* @__PURE__ */ S.jsx(zS, { className: "h-12 w-12 mx-auto mb-2 opacity-50" }),
            /* @__PURE__ */ S.jsx("p", { children: "No conversations yet" }),
            /* @__PURE__ */ S.jsx("p", { className: "text-xs mt-1", children: "Start chatting to create your first conversation" })
          ] }) : /* @__PURE__ */ S.jsx("div", { className: "w-full px-2 py-1 ", children: Object.entries(te).map(([re, le]) => le.length === 0 ? null : /* @__PURE__ */ S.jsxs("div", { className: "mb-4 w-full ", children: [
            /* @__PURE__ */ S.jsx("h5", { className: "text-xs font-semibold text-muted-foreground px-3 py-2 uppercase tracking-wide", children: re }),
            le.map((fe) => /* @__PURE__ */ S.jsx(
              "div",
              {
                className: Ge(
                  "group relative w-full p-2 rounded-lg cursor-pointer transition-all duration-300 ",
                  "hover:bg-blue-50/80 hover:shadow-sm ",
                  "dark:hover:bg-blue-950/30",
                  J === fe.id || t === fe.id ? "bg-blue-50 dark:bg-blue-950/20 border border-blue-200 dark:border-blue-800 shadow-sm" : "border border-transparent",
                  b === fe.id && "animate-slideOutLeft opacity-0 scale-95",
                  N.has(fe.id) && "animate-slideInLeft"
                ),
                onClick: () => {
                  ce(fe.id), n(fe.id);
                },
                children: /* @__PURE__ */ S.jsxs("div", { className: "flex items-start justify-between gap-2 w-full min-w-0", children: [
                  /* @__PURE__ */ S.jsx(
                    "div",
                    {
                      className: "flex-1 min-w-0 overflow-visible p-0",
                      onDoubleClick: (me) => {
                        me.stopPropagation(), c || se(fe.id);
                      },
                      children: /* @__PURE__ */ S.jsx("div", { className: "flex items-center gap-2 mb-1 w-full ", children: M === fe.id ? /* @__PURE__ */ S.jsx(
                        UF,
                        {
                          ref: ue,
                          type: "text",
                          value: D,
                          onChange: (me) => O(me.target.value),
                          onBlur: () => ie(fe.id),
                          onKeyDown: (me) => {
                            me.key === "Enter" ? (me.preventDefault(), ie(fe.id)) : me.key === "Escape" && (me.preventDefault(), H());
                          },
                          onClick: (me) => me.stopPropagation(),
                          className: "h-9 text-sm font-semibold px-2 py-1 border-blue-400 focus:border-blue-500 focus:ring-blue-500 dark:border-blue-600 dark:focus:border-blue-500",
                          autoFocus: !0
                        }
                      ) : /* @__PURE__ */ S.jsx("div", { className: "text-ellipsis text-sm text-foreground break-all cursor-pointer w-full hover:bg-inherit dark:hover:bg-neutral-800/50 rounded transition-colors", children: fe.title || "New conversation" }) })
                    }
                  ),
                  /* @__PURE__ */ S.jsxs(JM, { children: [
                    /* @__PURE__ */ S.jsx(QM, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                      Nt,
                      {
                        variant: "ghost",
                        size: "icon",
                        className: Ge(
                          "h-6 w-6 shrink-0 opacity-0 group-hover:opacity-100 transition-opacity",
                          "hover:bg-neutral-200 dark:hover:bg-neutral-700"
                        ),
                        onClick: (me) => me.stopPropagation(),
                        type: "button",
                        children: /* @__PURE__ */ S.jsx(KO, { className: "h-4 w-4" })
                      }
                    ) }),
                    /* @__PURE__ */ S.jsxs(ez, { align: "end", className: "w-48", children: [
                      /* @__PURE__ */ S.jsxs(
                        Zu,
                        {
                          onClick: (me) => {
                            me.stopPropagation(), X(fe.id);
                          },
                          className: "cursor-pointer",
                          children: [
                            /* @__PURE__ */ S.jsx(Cm, { className: "h-4 w-4 mr-2" }),
                            "Copy conversation"
                          ]
                        }
                      ),
                      /* @__PURE__ */ S.jsxs(
                        Zu,
                        {
                          onClick: (me) => {
                            me.stopPropagation(), se(fe.id);
                          },
                          className: "cursor-pointer",
                          children: [
                            /* @__PURE__ */ S.jsx(C2, { className: "h-4 w-4 mr-2" }),
                            "Rename"
                          ]
                        }
                      ),
                      /* @__PURE__ */ S.jsxs(
                        Zu,
                        {
                          onClick: (me) => {
                            me.stopPropagation(), G.has(fe.id) || he(fe.id, me);
                          },
                          className: "cursor-pointer text-red-600 focus:text-red-600 dark:text-red-400 dark:focus:text-red-400",
                          disabled: b === fe.id || G.has(fe.id),
                          children: [
                            /* @__PURE__ */ S.jsx(R2, { className: "h-4 w-4 mr-2" }),
                            "Delete"
                          ]
                        }
                      )
                    ] })
                  ] })
                ] })
              },
              fe.id
            ))
          ] }, re)) }) }) })
        ]
      }
    ) })
  ] }) : null;
}
var rd = "Switch", [rG] = yr(rd), [oG, aG] = rG(rd), iz = y.forwardRef(
  (e, t) => {
    const {
      __scopeSwitch: n,
      name: o,
      checked: i,
      defaultChecked: l,
      required: c,
      disabled: f,
      value: d = "on",
      onCheckedChange: h,
      form: m,
      ...v
    } = e, [b, x] = y.useState(null), E = Le(t, (T) => x(T)), w = y.useRef(!1), C = b ? m || !!b.closest("form") : !0, [A, M] = wa({
      prop: i,
      defaultProp: l ?? !1,
      onChange: h,
      caller: rd
    });
    return /* @__PURE__ */ S.jsxs(oG, { scope: n, checked: A, disabled: f, children: [
      /* @__PURE__ */ S.jsx(
        ze.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": A,
          "aria-required": c,
          "data-state": uz(A),
          "data-disabled": f ? "" : void 0,
          disabled: f,
          value: d,
          ...v,
          ref: E,
          onClick: ge(e.onClick, (T) => {
            M((D) => !D), C && (w.current = T.isPropagationStopped(), w.current || T.stopPropagation());
          })
        }
      ),
      C && /* @__PURE__ */ S.jsx(
        cz,
        {
          control: b,
          bubbles: !w.current,
          name: o,
          value: d,
          checked: A,
          required: c,
          disabled: f,
          form: m,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
iz.displayName = rd;
var sz = "SwitchThumb", lz = y.forwardRef(
  (e, t) => {
    const { __scopeSwitch: n, ...o } = e, i = aG(sz, n);
    return /* @__PURE__ */ S.jsx(
      ze.span,
      {
        "data-state": uz(i.checked),
        "data-disabled": i.disabled ? "" : void 0,
        ...o,
        ref: t
      }
    );
  }
);
lz.displayName = sz;
var iG = "SwitchBubbleInput", cz = y.forwardRef(
  ({
    __scopeSwitch: e,
    control: t,
    checked: n,
    bubbles: o = !0,
    ...i
  }, l) => {
    const c = y.useRef(null), f = Le(c, l), d = TR(n), h = DA(t);
    return y.useEffect(() => {
      const m = c.current;
      if (!m) return;
      const v = window.HTMLInputElement.prototype, x = Object.getOwnPropertyDescriptor(
        v,
        "checked"
      ).set;
      if (d !== n && x) {
        const E = new Event("click", { bubbles: o });
        x.call(m, n), m.dispatchEvent(E);
      }
    }, [d, n, o]), /* @__PURE__ */ S.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": !0,
        defaultChecked: n,
        ...i,
        tabIndex: -1,
        ref: f,
        style: {
          ...i.style,
          ...h,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
cz.displayName = iG;
function uz(e) {
  return e ? "checked" : "unchecked";
}
var sG = iz, lG = lz;
function cG({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    sG,
    {
      "data-slot": "switch",
      className: Ge(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ...t,
      children: /* @__PURE__ */ S.jsx(
        lG,
        {
          "data-slot": "switch-thumb",
          className: Ge(
            "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
          )
        }
      )
    }
  );
}
function uG(e) {
  if (!Number.isFinite(e)) return "";
  const t = e / 1024;
  return t < 1024 ? `${Math.round(t)} KB` : `${(t / 1024).toFixed(1)} MB`;
}
function bE(e) {
  const {
    value: t = "",
    onChange: n,
    onSend: o,
    opStop: i,
    onFilesChange: l,
    files: c,
    onStartTyping: f,
    onUseNextSuggestionChange: d,
    disabled: h = !1
  } = e, [m, v] = y.useState(t), b = y.useRef(!1), x = y.useRef(null), [E, w] = y.useState(c ?? []), [C, A] = y.useState(!1), M = y.useMemo(
    () => typeof window < "u" && "SpeechRecognition" in window,
    []
  ), [T, D] = y.useState(() => {
    try {
      const P = localStorage.getItem("useNextSuggestion");
      return P ? JSON.parse(P) : !1;
    } catch {
      return !1;
    }
  });
  y.useEffect(() => {
    v(t ?? "");
  }, [t]), y.useEffect(() => {
    Array.isArray(c) && w(c);
  }, [c]), y.useEffect(() => {
    f && (b.current || (m || "").trim().length !== 0 && (b.current = !0, f()));
  }, [m, f]), y.useEffect(() => {
    try {
      localStorage.setItem("useNextSuggestion", JSON.stringify(T));
    } catch {
    }
    d?.(T);
  }, [d, T]);
  const O = (P) => {
    w(P), l?.(P);
  }, k = (P) => {
    O(E.filter((Y, ne) => ne !== P));
  }, R = () => {
    A((P) => !P);
  }, N = async () => {
    const P = (m || "").trim();
    !P || h || (v(""), n?.(""), await o(P));
  };
  return /* @__PURE__ */ S.jsxs(
    "div",
    {
      className: "w-full border-t dark:bg-neutral-700 bg-neutral-200 backdrop-blur-md shadow-xl dark:border-0 p-2 flex flex-col gap-2 transition-all",
      children: [
        /* @__PURE__ */ S.jsxs("div", { className: "flex-1 flex flex-col", children: [
          E.length > 0 && /* @__PURE__ */ S.jsx("div", { className: "flex mt-1 w-full flex-wrap gap-2 max-h-32 overflow-y-auto wrap-break-word p-2", children: E.map((P, Y) => /* @__PURE__ */ S.jsxs(
            JA,
            {
              variant: "outline",
              className: "flex items-center justify-between gap-2 text-sm py-1 bg-background/50 dark:bg-neutral-800 rounded-md px-2 border",
              children: [
                /* @__PURE__ */ S.jsxs("div", { className: "truncate flex items-baseline gap-2", children: [
                  /* @__PURE__ */ S.jsx("div", { className: "font-medium", children: P.name }),
                  P.size ? /* @__PURE__ */ S.jsx("div", { className: "text-xs text-neutral-500", children: uG(P.size) }) : null
                ] }),
                /* @__PURE__ */ S.jsx(
                  "button",
                  {
                    onClick: () => k(Y),
                    title: "Remove",
                    className: "cursor-pointer text-neutral-400 hover:text-red-500 p-1",
                    type: "button",
                    children: /* @__PURE__ */ S.jsx(Rf, { className: "h-4 w-4" })
                  }
                )
              ]
            },
            Y
          )) }),
          /* @__PURE__ */ S.jsx("div", { className: "relative", children: /* @__PURE__ */ S.jsx(
            "textarea",
            {
              value: m,
              onChange: (P) => {
                const Y = P.target.value;
                v(Y), n?.(Y);
              },
              onKeyDown: (P) => {
                P.key === "Enter" && !P.shiftKey && (P.preventDefault(), N());
              },
              placeholder: "Ask any thing",
              disabled: h,
              rows: 3,
              className: "w-full min-h-16 max-h-40 overflow-y-auto dark:bg-neutral-700 bg-neutral-200 resize-none border-0 focus-visible:ring-0 px-3 py-2 text-neutral-800 placeholder:text-neutral-600 dark:text-white dark:placeholder:text-gray-400 outline-none"
            }
          ) })
        ] }),
        /* @__PURE__ */ S.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
          /* @__PURE__ */ S.jsx("div", { className: "mx-1" }),
          /* @__PURE__ */ S.jsxs("div", { className: "flex flex-row items-center gap-2 ml-auto", children: [
            /* @__PURE__ */ S.jsx(
              "input",
              {
                ref: x,
                type: "file",
                multiple: !0,
                className: "hidden",
                onChange: (P) => {
                  const Y = P.target.files ? Array.from(P.target.files) : [];
                  Y.length && O([...E, ...Y]), P.currentTarget.value = "";
                }
              }
            ),
            /* @__PURE__ */ S.jsx(
              Nt,
              {
                size: "icon",
                variant: "ghost",
                onClick: () => x.current?.click(),
                type: "button",
                disabled: h,
                title: "Upload files",
                className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: /* @__PURE__ */ S.jsx(g2, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ S.jsx(
              Nt,
              {
                size: "icon",
                variant: "ghost",
                onClick: R,
                type: "button",
                disabled: !M || h,
                "aria-pressed": C,
                title: C ? "Stop voice" : "Start voice",
                className: C ? "cursor-pointer  bg-neutral-200 dark:bg-neutral-800 text-red-500 dark:text-red-400" : "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                children: C ? /* @__PURE__ */ S.jsx(d2, { className: "h-5 w-5" }) : /* @__PURE__ */ S.jsx(p2, { className: "h-5 w-5" })
              }
            ),
            /* @__PURE__ */ S.jsxs(JM, { children: [
              /* @__PURE__ */ S.jsx(QM, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                Nt,
                {
                  size: "icon",
                  variant: "ghost",
                  disabled: h,
                  title: "Using next suggestion",
                  className: "cursor-pointer hover:bg-neutral-400 dark:hover:bg-neutral-800 text-neutral-500 hover:text-neutral-900 dark:text-gray-300 dark:hover:text-white",
                  type: "button",
                  children: /* @__PURE__ */ S.jsx(s2, { className: "h-5 w-5" })
                }
              ) }),
              /* @__PURE__ */ S.jsx(ez, { align: "end", side: "top", className: "w-72", children: /* @__PURE__ */ S.jsxs(
                Zu,
                {
                  onSelect: (P) => P.preventDefault(),
                  className: "flex items-center justify-between gap-3 cursor-pointer px-3 py-2",
                  children: [
                    /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2", children: [
                      /* @__PURE__ */ S.jsx(t2, { className: "h-4 w-4 text-amber-500 shrink-0" }),
                      /* @__PURE__ */ S.jsx("span", { className: "text-sm font-medium whitespace-nowrap", children: "Using next suggestion" })
                    ] }),
                    /* @__PURE__ */ S.jsx(
                      cG,
                      {
                        checked: T,
                        onCheckedChange: (P) => D(P),
                        className: "shrink-0"
                      }
                    )
                  ]
                }
              ) })
            ] }),
            h ? /* @__PURE__ */ S.jsx(
              Nt,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-red-900 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-red-900 dark:hover:bg-neutral-800",
                onClick: i,
                disabled: !h,
                title: "Stop thinking",
                type: "button",
                children: /* @__PURE__ */ S.jsx(y2, { className: "h-5 w-5" })
              }
            ) : /* @__PURE__ */ S.jsx(
              Nt,
              {
                size: "icon",
                className: "cursor-pointer rounded-full bg-blue-500 text-white hover:bg-blue-600 transition-colors shadow-md dark:bg-green-500 dark:hover:bg-neutral-800",
                onClick: () => {
                  N();
                },
                disabled: h || !(m || "").trim(),
                title: "Send (Ctrl+End)",
                type: "button",
                children: /* @__PURE__ */ S.jsx(w2, { className: "h-5 w-5" })
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function fG() {
  const [e, t] = y.useState(!1);
  return y.useEffect(() => {
    t(!0);
  }, []), e;
}
const dG = ({
  words: e,
  duration: t = 3e3,
  className: n
}) => {
  const [o, i] = y.useState(e[0]), [l, c] = y.useState(!1), f = fG(), d = y.useCallback(() => {
    const h = e[e.indexOf(o) + 1] || e[0];
    i(h), c(!0);
  }, [o, e]);
  return y.useEffect(() => {
    l || setTimeout(() => {
      d();
    }, t);
  }, [l, t, d]), f ? /* @__PURE__ */ S.jsx(
    VC,
    {
      onExitComplete: () => {
        c(!1);
      },
      children: /* @__PURE__ */ S.jsx(
        Uu.div,
        {
          initial: {
            opacity: 0,
            y: 10
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            type: "spring",
            stiffness: 100,
            damping: 10
          },
          exit: {
            opacity: 0,
            y: -40,
            x: 40,
            filter: "blur(8px)",
            scale: 2,
            position: "absolute"
          },
          className: Ge(
            "z-10 inline-block relative text-left text-foreground px-2",
            n
          ),
          children: o.split(" ").map((h, m) => /* @__PURE__ */ S.jsxs(
            Uu.span,
            {
              initial: { opacity: 0, y: 10, filter: "blur(4px)" },
              animate: { opacity: 1, y: 0, filter: "blur(0px)" },
              transition: {
                delay: m * 0.01,
                duration: 0.03
              },
              className: "inline-block whitespace-nowrap",
              children: [
                h.split("").map((v, b) => /* @__PURE__ */ S.jsx(
                  Uu.span,
                  {
                    initial: { opacity: 0, y: 10, filter: "blur(4px)" },
                    animate: { opacity: 1, y: 0, filter: "blur(0px)" },
                    transition: {
                      delay: m * 0.2 + b * 0.08,
                      duration: 0.2
                    },
                    className: "inline-block",
                    children: v
                  },
                  h + b
                )),
                /* @__PURE__ */ S.jsx("span", { className: "inline-block", children: "" })
              ]
            },
            h + m
          ))
        },
        o
      )
    }
  ) : null;
};
function hG() {
  const e = (/* @__PURE__ */ new Date()).getHours();
  return e < 12 ? "goodMorning" : e < 18 ? "goodAfternoon" : "goodEvening";
}
function pG() {
  const e = { name: "User" }, t = y.useMemo(() => {
    if (!e) return "";
    const n = [
      `Good ${hG().replace("good", "")}, ${e.name}!`,
      `Nice to see you again, ${e.name}.`,
      `What are you working on today, ${e.name}?`,
      "Let me know when you're ready to begin.",
      "What are your thoughts today?",
      "Where would you like to start?",
      `What are you thinking, ${e.name}?`
    ];
    return n[Math.floor(Math.random() * n.length)];
  }, [e.name]);
  return /* @__PURE__ */ S.jsx(
    Uu.div,
    {
      className: "max-w-3xl mx-auto my-1",
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      transition: { delay: 0.3 },
      children: /* @__PURE__ */ S.jsx("div", { className: "rounded-xl p-2 flex flex-col gap-2 leading-relaxed text-center", children: /* @__PURE__ */ S.jsx("h1", { className: "text-sm md:text-base text-blue-700 dark:text-[#1abcfe] drop-shadow-sm font-sans", children: t ? /* @__PURE__ */ S.jsx(dG, { words: [t], className: "" }) : "" }) })
    },
    "welcome"
  );
}
function xE() {
  return /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground text-xs px-6 py-2 mt-1", children: [
    /* @__PURE__ */ S.jsx(_g, { className: "h-4 w-4 text-blue-400 dark:text-[#1abcfe] animate-pulse" }),
    /* @__PURE__ */ S.jsx("span", { className: "animate-pulse", children: "Thinking" })
  ] });
}
function mG({ error: e }) {
  const [t, n] = y.useState(!1), o = e?.message ?? "Unknown error", i = o.length > 200 ? o.slice(0, 200) + "" : o;
  return /* @__PURE__ */ S.jsx("div", { className: "w-full mx-auto max-w-2xl px-4 mt-6", children: /* @__PURE__ */ S.jsxs("div", { className: "flex items-start gap-3 bg-stone-50 dark:bg-stone-800/30 border border-stone-200 dark:border-stone-700 rounded-xl p-4 shadow-sm", children: [
    /* @__PURE__ */ S.jsx("div", { className: "flex-shrink-0 mt-1", children: /* @__PURE__ */ S.jsx(z2, { className: "h-6 w-6 text-amber-500" }) }),
    /* @__PURE__ */ S.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ S.jsx("div", { className: "font-semibold text-stone-800 dark:text-stone-200 mb-1", children: "Oops! Something went wrong" }),
      /* @__PURE__ */ S.jsx("div", { className: "whitespace-pre-wrap break-words text-stone-700 dark:text-stone-300 text-sm leading-relaxed", children: t ? o : i }),
      o.length > 200 && /* @__PURE__ */ S.jsx(
        "button",
        {
          className: "mt-2 text-xs text-blue-600 dark:text-blue-400 underline hover:opacity-80",
          onClick: () => n((l) => !l),
          type: "button",
          children: t ? "Show less" : "Show more"
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "mt-3 text-xs text-stone-500 dark:text-stone-400", children: "Try refreshing the page or checking your connection. If the problem keeps happening, please contact support." })
    ] })
  ] }) });
}
function gG(e) {
  return e.type === "dynamic-tool" || e.type.startsWith("tool-");
}
function vG(e) {
  return e.type === "dynamic-tool" ? e.toolName : e.type.startsWith("tool-") ? e.type.slice(5) : null;
}
function yG(e) {
  return e.filter((t) => t.type === "text").map((t) => t.text).join("");
}
function bG({
  message: e,
  isLast: t,
  messageIndex: n = 0,
  onApproveTool: o,
  onAddToolOutputDev: i
}) {
  const l = t ? "polite" : "off", c = e.role === "user", f = y.useMemo(() => yG(e.parts), [e.parts]), d = e.parts.filter(gG), [h, m] = y.useState(
    () => /* @__PURE__ */ new Set()
  ), v = (x) => {
    m((E) => {
      const w = new Set(E);
      return w.has(x) ? w.delete(x) : w.add(x), w;
    });
  }, b = async () => {
    const x = f.trim();
    if (x)
      try {
        await navigator.clipboard.writeText(x);
      } catch {
      }
  };
  return e.role === "system" || !e.parts?.length ? null : c ? /* @__PURE__ */ S.jsxs("div", { className: "w-full mx-auto max-w-3xl px-4", "data-role": e.role, children: [
    n !== 0 ? /* @__PURE__ */ S.jsxs("div", { className: "flex items-center gap-2 text-muted-foreground px-2", children: [
      /* @__PURE__ */ S.jsx(ZO, { className: "w-4 h-4 opacity-50", "aria-hidden": !0 }),
      /* @__PURE__ */ S.jsx("div", { className: "flex-1 h-px border-t border-dashed border-muted-foreground/40" })
    ] }) : null,
    /* @__PURE__ */ S.jsx("div", { className: "flex justify-end my-2", "aria-live": l, children: /* @__PURE__ */ S.jsxs("div", { className: "group flex items-start gap-2", children: [
      /* @__PURE__ */ S.jsx("div", { className: "relative flex flex-col gap-2 items-end", children: /* @__PURE__ */ S.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ S.jsx("div", { className: "absolute -top-1 -left-10 opacity-0 group-hover:opacity-100 transition-opacity", children: /* @__PURE__ */ S.jsx(
          Nt,
          {
            type: "button",
            variant: "ghost",
            size: "icon",
            className: "h-7 w-7",
            onClick: () => {
              b();
            },
            "aria-label": "Copy message",
            title: "Copy",
            disabled: !f.trim(),
            children: /* @__PURE__ */ S.jsx(Cm, { className: "h-4 w-4" })
          }
        ) }),
        /* @__PURE__ */ S.jsx("div", { className: "flex flex-col gap-2", children: /* @__PURE__ */ S.jsx("div", { className: "bg-neutral-200 dark:bg-neutral-700 px-3 py-2 rounded-md text-sm text-foreground wrap-break-word", children: f || /* @__PURE__ */ S.jsx("span", { className: "text-muted-foreground", children: "" }) }) })
      ] }) }),
      /* @__PURE__ */ S.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ S.jsx("div", { className: "h-8 w-8 rounded-full bg-muted flex items-center justify-center", children: /* @__PURE__ */ S.jsx(N2, { className: "h-4 w-4 text-foreground" }) }) })
    ] }) })
  ] }) : /* @__PURE__ */ S.jsx("div", { className: "w-full mx-auto max-w-3xl px-4", "data-role": e.role, "aria-live": l, children: /* @__PURE__ */ S.jsxs("div", { className: "group flex items-start gap-2", children: [
    /* @__PURE__ */ S.jsx("span", { className: "shrink-0 mt-1", children: /* @__PURE__ */ S.jsx(_g, { className: "h-5 w-5 text-blue-400 dark:text-[#1abcfe]" }) }),
    /* @__PURE__ */ S.jsxs("div", { className: "relative flex flex-col w-full", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ S.jsx("div", { className: "text-foreground text-sm max-w-[70vw] wrap-break-word", children: /* @__PURE__ */ S.jsx("div", { className: "prose prose-sm dark:prose-invert prose-p:my-0 prose-ul:my-1 prose-ol:my-1 prose-pre:my-1", children: f || /* @__PURE__ */ S.jsx("span", { className: "text-muted-foreground", children: "" }) }) }),
        /* @__PURE__ */ S.jsx("div", { className: "opacity-0 group-hover:opacity-100 transition-opacity ml-2", children: /* @__PURE__ */ S.jsx(
          Nt,
          {
            type: "button",
            variant: "ghost",
            size: "icon",
            className: "h-7 w-7",
            onClick: () => {
              b();
            },
            "aria-label": "Copy message",
            title: "Copy",
            disabled: !f.trim(),
            children: /* @__PURE__ */ S.jsx(Cm, { className: "h-4 w-4" })
          }
        ) })
      ] }),
      d.length > 0 ? /* @__PURE__ */ S.jsx("div", { className: "mt-3 space-y-2", children: d.map((x) => {
        const E = vG(x);
        if (!E) return null;
        const w = h.has(x.toolCallId);
        return /* @__PURE__ */ S.jsxs(
          "div",
          {
            className: "rounded-xl border bg-background/40 px-3 py-2 text-xs",
            children: [
              /* @__PURE__ */ S.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
                /* @__PURE__ */ S.jsxs("div", { className: "min-w-0", children: [
                  /* @__PURE__ */ S.jsxs("div", { className: "font-medium truncate", children: [
                    "Tool: ",
                    /* @__PURE__ */ S.jsx("code", { children: E })
                  ] }),
                  /* @__PURE__ */ S.jsxs("div", { className: "text-muted-foreground", children: [
                    "State: ",
                    /* @__PURE__ */ S.jsx("code", { children: x.state })
                  ] })
                ] }),
                /* @__PURE__ */ S.jsx("div", { className: "flex items-center gap-1 shrink-0", children: /* @__PURE__ */ S.jsx(
                  Nt,
                  {
                    type: "button",
                    variant: "ghost",
                    size: "icon",
                    className: "h-7 w-7",
                    onClick: () => v(x.toolCallId),
                    "aria-label": w ? "Collapse tool details" : "Expand tool details",
                    children: w ? /* @__PURE__ */ S.jsx(LE, { className: "h-4 w-4" }) : /* @__PURE__ */ S.jsx(Tg, { className: "h-4 w-4" })
                  }
                ) })
              ] }),
              w ? /* @__PURE__ */ S.jsxs("div", { className: "mt-2 space-y-2", children: [
                "input" in x && x.input !== void 0 ? /* @__PURE__ */ S.jsxs("div", { children: [
                  /* @__PURE__ */ S.jsx("div", { className: "text-muted-foreground", children: "Input" }),
                  /* @__PURE__ */ S.jsx("pre", { className: "mt-0.5 max-h-64 overflow-auto whitespace-pre-wrap break-words rounded-md bg-muted/30 p-2", children: JSON.stringify(x.input, null, 2) })
                ] }) : null,
                "output" in x && x.output !== void 0 ? /* @__PURE__ */ S.jsxs("div", { children: [
                  /* @__PURE__ */ S.jsx("div", { className: "text-muted-foreground", children: "Output" }),
                  /* @__PURE__ */ S.jsx("pre", { className: "mt-0.5 max-h-64 overflow-auto whitespace-pre-wrap break-words rounded-md bg-muted/30 p-2", children: JSON.stringify(x.output, null, 2) })
                ] }) : null,
                "errorText" in x && x.errorText ? /* @__PURE__ */ S.jsx("div", { className: "text-red-600", children: x.errorText }) : null
              ] }) : null,
              x.state === "approval-requested" && o ? /* @__PURE__ */ S.jsxs("div", { className: "mt-2 flex flex-wrap gap-2", children: [
                /* @__PURE__ */ S.jsxs(
                  Nt,
                  {
                    type: "button",
                    variant: "outline",
                    className: "gap-2",
                    onClick: () => o(x.approval.id, !0),
                    children: [
                      /* @__PURE__ */ S.jsx(PE, { className: "h-4 w-4" }),
                      "Approve"
                    ]
                  }
                ),
                /* @__PURE__ */ S.jsxs(
                  Nt,
                  {
                    type: "button",
                    variant: "outline",
                    className: "gap-2 text-destructive hover:text-destructive",
                    onClick: () => o(x.approval.id, !1),
                    children: [
                      /* @__PURE__ */ S.jsx(Rf, { className: "h-4 w-4" }),
                      "Deny"
                    ]
                  }
                )
              ] }) : null,
              null
            ]
          },
          x.toolCallId
        );
      }) }) : null
    ] })
  ] }) });
}
const od = y.createContext(null);
od.displayName = "PanelGroupContext";
const yt = {
  group: "data-panel-group",
  groupDirection: "data-panel-group-direction",
  groupId: "data-panel-group-id",
  panel: "data-panel",
  panelCollapsible: "data-panel-collapsible",
  panelId: "data-panel-id",
  panelSize: "data-panel-size",
  resizeHandle: "data-resize-handle",
  resizeHandleActive: "data-resize-handle-active",
  resizeHandleEnabled: "data-panel-resize-handle-enabled",
  resizeHandleId: "data-panel-resize-handle-id",
  resizeHandleState: "data-resize-handle-state"
}, ey = 10, ba = y.useLayoutEffect, SE = Tf.useId, xG = typeof SE == "function" ? SE : () => null;
let SG = 0;
function ty(e = null) {
  const t = xG(), n = y.useRef(e || t || null);
  return n.current === null && (n.current = "" + SG++), e ?? n.current;
}
function fz({
  children: e,
  className: t = "",
  collapsedSize: n,
  collapsible: o,
  defaultSize: i,
  forwardedRef: l,
  id: c,
  maxSize: f,
  minSize: d,
  onCollapse: h,
  onExpand: m,
  onResize: v,
  order: b,
  style: x,
  tagName: E = "div",
  ...w
}) {
  const C = y.useContext(od);
  if (C === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: A,
    expandPanel: M,
    getPanelSize: T,
    getPanelStyle: D,
    groupId: O,
    isPanelCollapsed: k,
    reevaluatePanelConstraints: R,
    registerPanel: N,
    resizePanel: P,
    unregisterPanel: Y
  } = C, ne = ty(c), J = y.useRef({
    callbacks: {
      onCollapse: h,
      onExpand: m,
      onResize: v
    },
    constraints: {
      collapsedSize: n,
      collapsible: o,
      defaultSize: i,
      maxSize: f,
      minSize: d
    },
    id: ne,
    idIsFromProps: c !== void 0,
    order: b
  });
  y.useRef({
    didLogMissingDefaultSizeWarning: !1
  }), ba(() => {
    const {
      callbacks: ue,
      constraints: de
    } = J.current, I = {
      ...de
    };
    J.current.id = ne, J.current.idIsFromProps = c !== void 0, J.current.order = b, ue.onCollapse = h, ue.onExpand = m, ue.onResize = v, de.collapsedSize = n, de.collapsible = o, de.defaultSize = i, de.maxSize = f, de.minSize = d, (I.collapsedSize !== de.collapsedSize || I.collapsible !== de.collapsible || I.maxSize !== de.maxSize || I.minSize !== de.minSize) && R(J.current, I);
  }), ba(() => {
    const ue = J.current;
    return N(ue), () => {
      Y(ue);
    };
  }, [b, ne, N, Y]), y.useImperativeHandle(l, () => ({
    collapse: () => {
      A(J.current);
    },
    expand: (ue) => {
      M(J.current, ue);
    },
    getId() {
      return ne;
    },
    getSize() {
      return T(J.current);
    },
    isCollapsed() {
      return k(J.current);
    },
    isExpanded() {
      return !k(J.current);
    },
    resize: (ue) => {
      P(J.current, ue);
    }
  }), [A, M, T, k, ne, P]);
  const ce = D(J.current, i);
  return y.createElement(E, {
    ...w,
    children: e,
    className: t,
    id: ne,
    style: {
      ...ce,
      ...x
    },
    // CSS selectors
    [yt.groupId]: O,
    [yt.panel]: "",
    [yt.panelCollapsible]: o || void 0,
    [yt.panelId]: ne,
    [yt.panelSize]: parseFloat("" + ce.flexGrow).toFixed(1)
  });
}
const dz = y.forwardRef((e, t) => y.createElement(fz, {
  ...e,
  forwardedRef: t
}));
fz.displayName = "Panel";
dz.displayName = "forwardRef(Panel)";
let wg = null, Fu = -1, Ro = null;
function wG(e, t, n) {
  const o = (t & vz) !== 0, i = (t & yz) !== 0, l = (t & bz) !== 0, c = (t & xz) !== 0;
  if (t) {
    if (o)
      return l ? "se-resize" : c ? "ne-resize" : "e-resize";
    if (i)
      return l ? "sw-resize" : c ? "nw-resize" : "w-resize";
    if (l)
      return "s-resize";
    if (c)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function EG() {
  Ro !== null && (document.head.removeChild(Ro), wg = null, Ro = null, Fu = -1);
}
function ym(e, t, n) {
  var o, i;
  const l = wG(e, t);
  if (wg !== l) {
    if (wg = l, Ro === null && (Ro = document.createElement("style"), document.head.appendChild(Ro)), Fu >= 0) {
      var c;
      (c = Ro.sheet) === null || c === void 0 || c.removeRule(Fu);
    }
    Fu = (o = (i = Ro.sheet) === null || i === void 0 ? void 0 : i.insertRule(`*{cursor: ${l} !important;}`)) !== null && o !== void 0 ? o : -1;
  }
}
function hz(e) {
  return e.type === "keydown";
}
function pz(e) {
  return e.type.startsWith("pointer");
}
function mz(e) {
  return e.type.startsWith("mouse");
}
function ad(e) {
  if (pz(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (mz(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function _G() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function TG(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function CG(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: _E(e),
    b: _E(t)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), o = e;
  Ne(o, "Stacking order can only be calculated for elements with a common ancestor");
  const i = {
    a: EE(wE(n.a)),
    b: EE(wE(n.b))
  };
  if (i.a === i.b) {
    const l = o.childNodes, c = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let f = l.length;
    for (; f--; ) {
      const d = l[f];
      if (d === c.a) return 1;
      if (d === c.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const AG = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function RG(e) {
  var t;
  const n = getComputedStyle((t = gz(e)) !== null && t !== void 0 ? t : e).display;
  return n === "flex" || n === "inline-flex";
}
function MG(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || RG(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || AG.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function wE(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (Ne(n, "Missing node"), MG(n)) return n;
  }
  return null;
}
function EE(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function _E(e) {
  const t = [];
  for (; e; )
    t.push(e), e = gz(e);
  return t;
}
function gz(e) {
  const {
    parentNode: t
  } = e;
  return t && t instanceof ShadowRoot ? t.host : t;
}
const vz = 1, yz = 2, bz = 4, xz = 8, zG = _G() === "coarse";
let Qn = [], Pi = !1, Mo = /* @__PURE__ */ new Map(), id = /* @__PURE__ */ new Map();
const Nl = /* @__PURE__ */ new Set();
function DG(e, t, n, o, i) {
  var l;
  const {
    ownerDocument: c
  } = t, f = {
    direction: n,
    element: t,
    hitAreaMargins: o,
    setResizeHandlerState: i
  }, d = (l = Mo.get(c)) !== null && l !== void 0 ? l : 0;
  return Mo.set(c, d + 1), Nl.add(f), wf(), function() {
    var m;
    id.delete(e), Nl.delete(f);
    const v = (m = Mo.get(c)) !== null && m !== void 0 ? m : 1;
    if (Mo.set(c, v - 1), wf(), v === 1 && Mo.delete(c), Qn.includes(f)) {
      const b = Qn.indexOf(f);
      b >= 0 && Qn.splice(b, 1), sd(), i("up", !0, null);
    }
  };
}
function NG(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: o
  } = ad(e);
  Pi = !0, ny({
    target: t,
    x: n,
    y: o
  }), wf(), Qn.length > 0 && (Ef("down", e), sd(), e.preventDefault(), Sz(t) || e.stopImmediatePropagation());
}
function bm(e) {
  const {
    x: t,
    y: n
  } = ad(e);
  if (Pi && // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
  e.type !== "pointerleave" && e.buttons === 0 && (Pi = !1, Ef("up", e)), !Pi) {
    const {
      target: o
    } = e;
    ny({
      target: o,
      x: t,
      y: n
    });
  }
  Ef("move", e), sd(), Qn.length > 0 && e.preventDefault();
}
function xm(e) {
  const {
    target: t
  } = e, {
    x: n,
    y: o
  } = ad(e);
  id.clear(), Pi = !1, Qn.length > 0 && (e.preventDefault(), Sz(t) || e.stopImmediatePropagation()), Ef("up", e), ny({
    target: t,
    x: n,
    y: o
  }), sd(), wf();
}
function Sz(e) {
  let t = e;
  for (; t; ) {
    if (t.hasAttribute(yt.resizeHandle))
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function ny({
  target: e,
  x: t,
  y: n
}) {
  Qn.splice(0);
  let o = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (o = e), Nl.forEach((i) => {
    const {
      element: l,
      hitAreaMargins: c
    } = i, f = l.getBoundingClientRect(), {
      bottom: d,
      left: h,
      right: m,
      top: v
    } = f, b = zG ? c.coarse : c.fine;
    if (t >= h - b && t <= m + b && n >= v - b && n <= d + b) {
      if (o !== null && document.contains(o) && l !== o && !l.contains(o) && !o.contains(l) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      CG(o, l) > 0) {
        let E = o, w = !1;
        for (; E && !E.contains(l); ) {
          if (TG(E.getBoundingClientRect(), f)) {
            w = !0;
            break;
          }
          E = E.parentElement;
        }
        if (w)
          return;
      }
      Qn.push(i);
    }
  });
}
function Sm(e, t) {
  id.set(e, t);
}
function sd() {
  let e = !1, t = !1;
  Qn.forEach((o) => {
    const {
      direction: i
    } = o;
    i === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  id.forEach((o) => {
    n |= o;
  }), e && t ? ym("intersection", n) : e ? ym("horizontal", n) : t ? ym("vertical", n) : EG();
}
let wm;
function wf() {
  var e;
  (e = wm) === null || e === void 0 || e.abort(), wm = new AbortController();
  const t = {
    capture: !0,
    signal: wm.signal
  };
  Nl.size && (Pi ? (Qn.length > 0 && Mo.forEach((n, o) => {
    const {
      body: i
    } = o;
    n > 0 && (i.addEventListener("contextmenu", xm, t), i.addEventListener("pointerleave", bm, t), i.addEventListener("pointermove", bm, t));
  }), Mo.forEach((n, o) => {
    const {
      body: i
    } = o;
    i.addEventListener("pointerup", xm, t), i.addEventListener("pointercancel", xm, t);
  })) : Mo.forEach((n, o) => {
    const {
      body: i
    } = o;
    n > 0 && (i.addEventListener("pointerdown", NG, t), i.addEventListener("pointermove", bm, t));
  }));
}
function Ef(e, t) {
  Nl.forEach((n) => {
    const {
      setResizeHandlerState: o
    } = n, i = Qn.includes(n);
    o(e, i, t);
  });
}
function OG() {
  const [e, t] = y.useState(0);
  return y.useCallback(() => t((n) => n + 1), []);
}
function Ne(e, t) {
  if (!e)
    throw console.error(t), Error(t);
}
function Ca(e, t, n = ey) {
  return e.toFixed(n) === t.toFixed(n) ? 0 : e > t ? 1 : -1;
}
function Hr(e, t, n = ey) {
  return Ca(e, t, n) === 0;
}
function Sn(e, t, n) {
  return Ca(e, t, n) === 0;
}
function jG(e, t, n) {
  if (e.length !== t.length)
    return !1;
  for (let o = 0; o < e.length; o++) {
    const i = e[o], l = t[o];
    if (!Sn(i, l, n))
      return !1;
  }
  return !0;
}
function Di({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const o = e[t];
  Ne(o != null, `Panel constraints not found for index ${t}`);
  let {
    collapsedSize: i = 0,
    collapsible: l,
    maxSize: c = 100,
    minSize: f = 0
  } = o;
  if (Ca(n, f) < 0)
    if (l) {
      const d = (i + f) / 2;
      Ca(n, d) < 0 ? n = i : n = f;
    } else
      n = f;
  return n = Math.min(c, n), n = parseFloat(n.toFixed(ey)), n;
}
function fl({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: o,
  prevLayout: i,
  trigger: l
}) {
  if (Sn(e, 0))
    return t;
  const c = [...t], [f, d] = o;
  Ne(f != null, "Invalid first pivot index"), Ne(d != null, "Invalid second pivot index");
  let h = 0;
  if (l === "keyboard") {
    {
      const v = e < 0 ? d : f, b = n[v];
      Ne(b, `Panel constraints not found for index ${v}`);
      const {
        collapsedSize: x = 0,
        collapsible: E,
        minSize: w = 0
      } = b;
      if (E) {
        const C = t[v];
        if (Ne(C != null, `Previous layout not found for panel index ${v}`), Sn(C, x)) {
          const A = w - C;
          Ca(A, Math.abs(e)) > 0 && (e = e < 0 ? 0 - A : A);
        }
      }
    }
    {
      const v = e < 0 ? f : d, b = n[v];
      Ne(b, `No panel constraints found for index ${v}`);
      const {
        collapsedSize: x = 0,
        collapsible: E,
        minSize: w = 0
      } = b;
      if (E) {
        const C = t[v];
        if (Ne(C != null, `Previous layout not found for panel index ${v}`), Sn(C, w)) {
          const A = C - x;
          Ca(A, Math.abs(e)) > 0 && (e = e < 0 ? 0 - A : A);
        }
      }
    }
  }
  {
    const v = e < 0 ? 1 : -1;
    let b = e < 0 ? d : f, x = 0;
    for (; ; ) {
      const w = t[b];
      Ne(w != null, `Previous layout not found for panel index ${b}`);
      const A = Di({
        panelConstraints: n,
        panelIndex: b,
        size: 100
      }) - w;
      if (x += A, b += v, b < 0 || b >= n.length)
        break;
    }
    const E = Math.min(Math.abs(e), Math.abs(x));
    e = e < 0 ? 0 - E : E;
  }
  {
    let b = e < 0 ? f : d;
    for (; b >= 0 && b < n.length; ) {
      const x = Math.abs(e) - Math.abs(h), E = t[b];
      Ne(E != null, `Previous layout not found for panel index ${b}`);
      const w = E - x, C = Di({
        panelConstraints: n,
        panelIndex: b,
        size: w
      });
      if (!Sn(E, C) && (h += E - C, c[b] = C, h.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? b-- : b++;
    }
  }
  if (jG(i, c))
    return i;
  {
    const v = e < 0 ? d : f, b = t[v];
    Ne(b != null, `Previous layout not found for panel index ${v}`);
    const x = b + h, E = Di({
      panelConstraints: n,
      panelIndex: v,
      size: x
    });
    if (c[v] = E, !Sn(E, x)) {
      let w = x - E, A = e < 0 ? d : f;
      for (; A >= 0 && A < n.length; ) {
        const M = c[A];
        Ne(M != null, `Previous layout not found for panel index ${A}`);
        const T = M + w, D = Di({
          panelConstraints: n,
          panelIndex: A,
          size: T
        });
        if (Sn(M, D) || (w -= D - M, c[A] = D), Sn(w, 0))
          break;
        e > 0 ? A-- : A++;
      }
    }
  }
  const m = c.reduce((v, b) => b + v, 0);
  return Sn(m, 100) ? c : i;
}
function kG({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let o = 0, i = 100, l = 0, c = 0;
  const f = n[0];
  Ne(f != null, "No pivot index found"), t.forEach((v, b) => {
    const {
      constraints: x
    } = v, {
      maxSize: E = 100,
      minSize: w = 0
    } = x;
    b === f ? (o = w, i = E) : (l += w, c += E);
  });
  const d = Math.min(i, 100 - l), h = Math.max(o, 100 - c), m = e[f];
  return {
    valueMax: d,
    valueMin: h,
    valueNow: m
  };
}
function Ol(e, t = document) {
  return Array.from(t.querySelectorAll(`[${yt.resizeHandleId}][data-panel-group-id="${e}"]`));
}
function wz(e, t, n = document) {
  const i = Ol(e, n).findIndex((l) => l.getAttribute(yt.resizeHandleId) === t);
  return i ?? null;
}
function Ez(e, t, n) {
  const o = wz(e, t, n);
  return o != null ? [o, o + 1] : [-1, -1];
}
function PG(e) {
  return e instanceof HTMLElement ? !0 : typeof e == "object" && e !== null && "tagName" in e && "getAttribute" in e;
}
function _z(e, t = document) {
  if (PG(t) && t.dataset.panelGroupId == e)
    return t;
  const n = t.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return n || null;
}
function ld(e, t = document) {
  const n = t.querySelector(`[${yt.resizeHandleId}="${e}"]`);
  return n || null;
}
function LG(e, t, n, o = document) {
  var i, l, c, f;
  const d = ld(t, o), h = Ol(e, o), m = d ? h.indexOf(d) : -1, v = (i = (l = n[m]) === null || l === void 0 ? void 0 : l.id) !== null && i !== void 0 ? i : null, b = (c = (f = n[m + 1]) === null || f === void 0 ? void 0 : f.id) !== null && c !== void 0 ? c : null;
  return [v, b];
}
function IG({
  committedValuesRef: e,
  eagerValuesRef: t,
  groupId: n,
  layout: o,
  panelDataArray: i,
  panelGroupElement: l,
  setLayout: c
}) {
  y.useRef({
    didWarnAboutMissingResizeHandle: !1
  }), ba(() => {
    if (!l)
      return;
    const f = Ol(n, l);
    for (let d = 0; d < i.length - 1; d++) {
      const {
        valueMax: h,
        valueMin: m,
        valueNow: v
      } = kG({
        layout: o,
        panelsArray: i,
        pivotIndices: [d, d + 1]
      }), b = f[d];
      if (b != null) {
        const x = i[d];
        Ne(x, `No panel data found for index "${d}"`), b.setAttribute("aria-controls", x.id), b.setAttribute("aria-valuemax", "" + Math.round(h)), b.setAttribute("aria-valuemin", "" + Math.round(m)), b.setAttribute("aria-valuenow", v != null ? "" + Math.round(v) : "");
      }
    }
    return () => {
      f.forEach((d, h) => {
        d.removeAttribute("aria-controls"), d.removeAttribute("aria-valuemax"), d.removeAttribute("aria-valuemin"), d.removeAttribute("aria-valuenow");
      });
    };
  }, [n, o, i, l]), y.useEffect(() => {
    if (!l)
      return;
    const f = t.current;
    Ne(f, "Eager values not found");
    const {
      panelDataArray: d
    } = f, h = _z(n, l);
    Ne(h != null, `No group found for id "${n}"`);
    const m = Ol(n, l);
    Ne(m, `No resize handles found for group id "${n}"`);
    const v = m.map((b) => {
      const x = b.getAttribute(yt.resizeHandleId);
      Ne(x, "Resize handle element has no handle id attribute");
      const [E, w] = LG(n, x, d, l);
      if (E == null || w == null)
        return () => {
        };
      const C = (A) => {
        if (!A.defaultPrevented)
          switch (A.key) {
            case "Enter": {
              A.preventDefault();
              const M = d.findIndex((T) => T.id === E);
              if (M >= 0) {
                const T = d[M];
                Ne(T, `No panel data found for index ${M}`);
                const D = o[M], {
                  collapsedSize: O = 0,
                  collapsible: k,
                  minSize: R = 0
                } = T.constraints;
                if (D != null && k) {
                  const N = fl({
                    delta: Sn(D, O) ? R - O : O - D,
                    initialLayout: o,
                    panelConstraints: d.map((P) => P.constraints),
                    pivotIndices: Ez(n, x, l),
                    prevLayout: o,
                    trigger: "keyboard"
                  });
                  o !== N && c(N);
                }
              }
              break;
            }
          }
      };
      return b.addEventListener("keydown", C), () => {
        b.removeEventListener("keydown", C);
      };
    });
    return () => {
      v.forEach((b) => b());
    };
  }, [l, e, t, n, o, i, c]);
}
function TE(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Tz(e, t) {
  const n = e === "horizontal", {
    x: o,
    y: i
  } = ad(t);
  return n ? o : i;
}
function VG(e, t, n, o, i) {
  const l = n === "horizontal", c = ld(t, i);
  Ne(c, `No resize handle element found for id "${t}"`);
  const f = c.getAttribute(yt.groupId);
  Ne(f, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: d
  } = o;
  const h = Tz(n, e), m = _z(f, i);
  Ne(m, `No group element found for id "${f}"`);
  const v = m.getBoundingClientRect(), b = l ? v.width : v.height;
  return (h - d) / b * 100;
}
function UG(e, t, n, o, i, l) {
  if (hz(e)) {
    const c = n === "horizontal";
    let f = 0;
    e.shiftKey ? f = 100 : i != null ? f = i : f = 10;
    let d = 0;
    switch (e.key) {
      case "ArrowDown":
        d = c ? 0 : f;
        break;
      case "ArrowLeft":
        d = c ? -f : 0;
        break;
      case "ArrowRight":
        d = c ? f : 0;
        break;
      case "ArrowUp":
        d = c ? 0 : -f;
        break;
      case "End":
        d = 100;
        break;
      case "Home":
        d = -100;
        break;
    }
    return d;
  } else
    return o == null ? 0 : VG(e, t, n, o, l);
}
function BG({
  panelDataArray: e
}) {
  const t = Array(e.length), n = e.map((l) => l.constraints);
  let o = 0, i = 100;
  for (let l = 0; l < e.length; l++) {
    const c = n[l];
    Ne(c, `Panel constraints not found for index ${l}`);
    const {
      defaultSize: f
    } = c;
    f != null && (o++, t[l] = f, i -= f);
  }
  for (let l = 0; l < e.length; l++) {
    const c = n[l];
    Ne(c, `Panel constraints not found for index ${l}`);
    const {
      defaultSize: f
    } = c;
    if (f != null)
      continue;
    const d = e.length - o, h = i / d;
    o++, t[l] = h, i -= h;
  }
  return t;
}
function Si(e, t, n) {
  t.forEach((o, i) => {
    const l = e[i];
    Ne(l, `Panel data not found for index ${i}`);
    const {
      callbacks: c,
      constraints: f,
      id: d
    } = l, {
      collapsedSize: h = 0,
      collapsible: m
    } = f, v = n[d];
    if (v == null || o !== v) {
      n[d] = o;
      const {
        onCollapse: b,
        onExpand: x,
        onResize: E
      } = c;
      E && E(o, v), m && (b || x) && (x && (v == null || Hr(v, h)) && !Hr(o, h) && x(), b && (v == null || !Hr(v, h)) && Hr(o, h) && b());
    }
  });
}
function Ou(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function $G({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: o,
  panelIndex: i,
  precision: l = 3
}) {
  const c = n[i];
  let f;
  return c == null ? f = e != null ? e.toFixed(l) : "1" : o.length === 1 ? f = "1" : f = c.toFixed(l), {
    flexBasis: 0,
    flexGrow: f,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
function HG(e, t = 10) {
  let n = null;
  return (...i) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...i);
    }, t);
  };
}
function CE(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function Cz(e) {
  return `react-resizable-panels:${e}`;
}
function Az(e) {
  return e.map((t) => {
    const {
      constraints: n,
      id: o,
      idIsFromProps: i,
      order: l
    } = t;
    return i ? o : l ? `${l}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function Rz(e, t) {
  try {
    const n = Cz(e), o = t.getItem(n);
    if (o) {
      const i = JSON.parse(o);
      if (typeof i == "object" && i != null)
        return i;
    }
  } catch {
  }
  return null;
}
function ZG(e, t, n) {
  var o, i;
  const l = (o = Rz(e, n)) !== null && o !== void 0 ? o : {}, c = Az(t);
  return (i = l[c]) !== null && i !== void 0 ? i : null;
}
function FG(e, t, n, o, i) {
  var l;
  const c = Cz(e), f = Az(t), d = (l = Rz(e, i)) !== null && l !== void 0 ? l : {};
  d[f] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: o
  };
  try {
    i.setItem(c, JSON.stringify(d));
  } catch (h) {
    console.error(h);
  }
}
function AE({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], o = n.reduce((l, c) => l + c, 0);
  if (n.length !== t.length)
    throw Error(`Invalid ${t.length} panel layout: ${n.map((l) => `${l}%`).join(", ")}`);
  if (!Sn(o, 100) && n.length > 0)
    for (let l = 0; l < t.length; l++) {
      const c = n[l];
      Ne(c != null, `No layout data found for index ${l}`);
      const f = 100 / o * c;
      n[l] = f;
    }
  let i = 0;
  for (let l = 0; l < t.length; l++) {
    const c = n[l];
    Ne(c != null, `No layout data found for index ${l}`);
    const f = Di({
      panelConstraints: t,
      panelIndex: l,
      size: c
    });
    c != f && (i += c - f, n[l] = f);
  }
  if (!Sn(i, 0))
    for (let l = 0; l < t.length; l++) {
      const c = n[l];
      Ne(c != null, `No layout data found for index ${l}`);
      const f = c + i, d = Di({
        panelConstraints: t,
        panelIndex: l,
        size: f
      });
      if (c !== d && (i -= d - c, n[l] = d, Sn(i, 0)))
        break;
    }
  return n;
}
const GG = 100, dl = {
  getItem: (e) => (CE(dl), dl.getItem(e)),
  setItem: (e, t) => {
    CE(dl), dl.setItem(e, t);
  }
}, RE = {};
function Mz({
  autoSaveId: e = null,
  children: t,
  className: n = "",
  direction: o,
  forwardedRef: i,
  id: l = null,
  onLayout: c = null,
  keyboardResizeBy: f = null,
  storage: d = dl,
  style: h,
  tagName: m = "div",
  ...v
}) {
  const b = ty(l), x = y.useRef(null), [E, w] = y.useState(null), [C, A] = y.useState([]), M = OG(), T = y.useRef({}), D = y.useRef(/* @__PURE__ */ new Map()), O = y.useRef(0), k = y.useRef({
    autoSaveId: e,
    direction: o,
    dragState: E,
    id: b,
    keyboardResizeBy: f,
    onLayout: c,
    storage: d
  }), R = y.useRef({
    layout: C,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  y.useRef({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), y.useImperativeHandle(i, () => ({
    getId: () => k.current.id,
    getLayout: () => {
      const {
        layout: $
      } = R.current;
      return $;
    },
    setLayout: ($) => {
      const {
        onLayout: X
      } = k.current, {
        layout: se,
        panelDataArray: ie
      } = R.current, H = AE({
        layout: $,
        panelConstraints: ie.map((re) => re.constraints)
      });
      TE(se, H) || (A(H), R.current.layout = H, X && X(H), Si(ie, H, T.current));
    }
  }), []), ba(() => {
    k.current.autoSaveId = e, k.current.direction = o, k.current.dragState = E, k.current.id = b, k.current.onLayout = c, k.current.storage = d;
  }), IG({
    committedValuesRef: k,
    eagerValuesRef: R,
    groupId: b,
    layout: C,
    panelDataArray: R.current.panelDataArray,
    setLayout: A,
    panelGroupElement: x.current
  }), y.useEffect(() => {
    const {
      panelDataArray: $
    } = R.current;
    if (e) {
      if (C.length === 0 || C.length !== $.length)
        return;
      let X = RE[e];
      X == null && (X = HG(FG, GG), RE[e] = X);
      const se = [...$], ie = new Map(D.current);
      X(e, se, ie, C, d);
    }
  }, [e, C, d]), y.useEffect(() => {
  });
  const N = y.useCallback(($) => {
    const {
      onLayout: X
    } = k.current, {
      layout: se,
      panelDataArray: ie
    } = R.current;
    if ($.constraints.collapsible) {
      const H = ie.map((me) => me.constraints), {
        collapsedSize: re = 0,
        panelSize: le,
        pivotIndices: fe
      } = da(ie, $, se);
      if (Ne(le != null, `Panel size not found for panel "${$.id}"`), !Hr(le, re)) {
        D.current.set($.id, le);
        const Re = _i(ie, $) === ie.length - 1 ? le - re : re - le, je = fl({
          delta: Re,
          initialLayout: se,
          panelConstraints: H,
          pivotIndices: fe,
          prevLayout: se,
          trigger: "imperative-api"
        });
        Ou(se, je) || (A(je), R.current.layout = je, X && X(je), Si(ie, je, T.current));
      }
    }
  }, []), P = y.useCallback(($, X) => {
    const {
      onLayout: se
    } = k.current, {
      layout: ie,
      panelDataArray: H
    } = R.current;
    if ($.constraints.collapsible) {
      const re = H.map((Qe) => Qe.constraints), {
        collapsedSize: le = 0,
        panelSize: fe = 0,
        minSize: me = 0,
        pivotIndices: Re
      } = da(H, $, ie), je = X ?? me;
      if (Hr(fe, le)) {
        const Qe = D.current.get($.id), un = Qe != null && Qe >= je ? Qe : je, Sr = _i(H, $) === H.length - 1 ? fe - un : un - fe, kt = fl({
          delta: Sr,
          initialLayout: ie,
          panelConstraints: re,
          pivotIndices: Re,
          prevLayout: ie,
          trigger: "imperative-api"
        });
        Ou(ie, kt) || (A(kt), R.current.layout = kt, se && se(kt), Si(H, kt, T.current));
      }
    }
  }, []), Y = y.useCallback(($) => {
    const {
      layout: X,
      panelDataArray: se
    } = R.current, {
      panelSize: ie
    } = da(se, $, X);
    return Ne(ie != null, `Panel size not found for panel "${$.id}"`), ie;
  }, []), ne = y.useCallback(($, X) => {
    const {
      panelDataArray: se
    } = R.current, ie = _i(se, $);
    return $G({
      defaultSize: X,
      dragState: E,
      layout: C,
      panelData: se,
      panelIndex: ie
    });
  }, [E, C]), J = y.useCallback(($) => {
    const {
      layout: X,
      panelDataArray: se
    } = R.current, {
      collapsedSize: ie = 0,
      collapsible: H,
      panelSize: re
    } = da(se, $, X);
    return Ne(re != null, `Panel size not found for panel "${$.id}"`), H === !0 && Hr(re, ie);
  }, []), ce = y.useCallback(($) => {
    const {
      layout: X,
      panelDataArray: se
    } = R.current, {
      collapsedSize: ie = 0,
      collapsible: H,
      panelSize: re
    } = da(se, $, X);
    return Ne(re != null, `Panel size not found for panel "${$.id}"`), !H || Ca(re, ie) > 0;
  }, []), ue = y.useCallback(($) => {
    const {
      panelDataArray: X
    } = R.current;
    X.push($), X.sort((se, ie) => {
      const H = se.order, re = ie.order;
      return H == null && re == null ? 0 : H == null ? -1 : re == null ? 1 : H - re;
    }), R.current.panelDataArrayChanged = !0, M();
  }, [M]);
  ba(() => {
    if (R.current.panelDataArrayChanged) {
      R.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: $,
        onLayout: X,
        storage: se
      } = k.current, {
        layout: ie,
        panelDataArray: H
      } = R.current;
      let re = null;
      if ($) {
        const fe = ZG($, H, se);
        fe && (D.current = new Map(Object.entries(fe.expandToSizes)), re = fe.layout);
      }
      re == null && (re = BG({
        panelDataArray: H
      }));
      const le = AE({
        layout: re,
        panelConstraints: H.map((fe) => fe.constraints)
      });
      TE(ie, le) || (A(le), R.current.layout = le, X && X(le), Si(H, le, T.current));
    }
  }), ba(() => {
    const $ = R.current;
    return () => {
      $.layout = [];
    };
  }, []);
  const de = y.useCallback(($) => {
    let X = !1;
    const se = x.current;
    return se && window.getComputedStyle(se, null).getPropertyValue("direction") === "rtl" && (X = !0), function(H) {
      H.preventDefault();
      const re = x.current;
      if (!re)
        return () => null;
      const {
        direction: le,
        dragState: fe,
        id: me,
        keyboardResizeBy: Re,
        onLayout: je
      } = k.current, {
        layout: Qe,
        panelDataArray: un
      } = R.current, {
        initialLayout: Tn
      } = fe ?? {}, Sr = Ez(me, $, re);
      let kt = UG(H, $, le, fe, Re, re);
      const za = le === "horizontal";
      za && X && (kt = -kt);
      const ts = un.map((cd) => cd.constraints), wr = fl({
        delta: kt,
        initialLayout: Tn ?? Qe,
        panelConstraints: ts,
        pivotIndices: Sr,
        prevLayout: Qe,
        trigger: hz(H) ? "keyboard" : "mouse-or-touch"
      }), Wl = !Ou(Qe, wr);
      (pz(H) || mz(H)) && O.current != kt && (O.current = kt, !Wl && kt !== 0 ? za ? Sm($, kt < 0 ? vz : yz) : Sm($, kt < 0 ? bz : xz) : Sm($, 0)), Wl && (A(wr), R.current.layout = wr, je && je(wr), Si(un, wr, T.current));
    };
  }, []), I = y.useCallback(($, X) => {
    const {
      onLayout: se
    } = k.current, {
      layout: ie,
      panelDataArray: H
    } = R.current, re = H.map((Qe) => Qe.constraints), {
      panelSize: le,
      pivotIndices: fe
    } = da(H, $, ie);
    Ne(le != null, `Panel size not found for panel "${$.id}"`);
    const Re = _i(H, $) === H.length - 1 ? le - X : X - le, je = fl({
      delta: Re,
      initialLayout: ie,
      panelConstraints: re,
      pivotIndices: fe,
      prevLayout: ie,
      trigger: "imperative-api"
    });
    Ou(ie, je) || (A(je), R.current.layout = je, se && se(je), Si(H, je, T.current));
  }, []), G = y.useCallback(($, X) => {
    const {
      layout: se,
      panelDataArray: ie
    } = R.current, {
      collapsedSize: H = 0,
      collapsible: re
    } = X, {
      collapsedSize: le = 0,
      collapsible: fe,
      maxSize: me = 100,
      minSize: Re = 0
    } = $.constraints, {
      panelSize: je
    } = da(ie, $, se);
    je != null && (re && fe && Hr(je, H) ? Hr(H, le) || I($, le) : je < Re ? I($, Re) : je > me && I($, me));
  }, [I]), U = y.useCallback(($, X) => {
    const {
      direction: se
    } = k.current, {
      layout: ie
    } = R.current;
    if (!x.current)
      return;
    const H = ld($, x.current);
    Ne(H, `Drag handle element not found for id "${$}"`);
    const re = Tz(se, X);
    w({
      dragHandleId: $,
      dragHandleRect: H.getBoundingClientRect(),
      initialCursorPosition: re,
      initialLayout: ie
    });
  }, []), te = y.useCallback(() => {
    w(null);
  }, []), he = y.useCallback(($) => {
    const {
      panelDataArray: X
    } = R.current, se = _i(X, $);
    se >= 0 && (X.splice(se, 1), delete T.current[$.id], R.current.panelDataArrayChanged = !0, M());
  }, [M]), j = y.useMemo(() => ({
    collapsePanel: N,
    direction: o,
    dragState: E,
    expandPanel: P,
    getPanelSize: Y,
    getPanelStyle: ne,
    groupId: b,
    isPanelCollapsed: J,
    isPanelExpanded: ce,
    reevaluatePanelConstraints: G,
    registerPanel: ue,
    registerResizeHandle: de,
    resizePanel: I,
    startDragging: U,
    stopDragging: te,
    unregisterPanel: he,
    panelGroupElement: x.current
  }), [N, E, o, P, Y, ne, b, J, ce, G, ue, de, I, U, te, he]), W = {
    display: "flex",
    flexDirection: o === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return y.createElement(od.Provider, {
    value: j
  }, y.createElement(m, {
    ...v,
    children: t,
    className: n,
    id: l,
    ref: x,
    style: {
      ...W,
      ...h
    },
    // CSS selectors
    [yt.group]: "",
    [yt.groupDirection]: o,
    [yt.groupId]: b
  }));
}
const zz = y.forwardRef((e, t) => y.createElement(Mz, {
  ...e,
  forwardedRef: t
}));
Mz.displayName = "PanelGroup";
zz.displayName = "forwardRef(PanelGroup)";
function _i(e, t) {
  return e.findIndex((n) => n === t || n.id === t.id);
}
function da(e, t, n) {
  const o = _i(e, t), l = o === e.length - 1 ? [o - 1, o] : [o, o + 1], c = n[o];
  return {
    ...t.constraints,
    panelSize: c,
    pivotIndices: l
  };
}
function YG({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: o
}) {
  y.useEffect(() => {
    if (e || n == null || o == null)
      return;
    const i = ld(t, o);
    if (i == null)
      return;
    const l = (c) => {
      if (!c.defaultPrevented)
        switch (c.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            c.preventDefault(), n(c);
            break;
          }
          case "F6": {
            c.preventDefault();
            const f = i.getAttribute(yt.groupId);
            Ne(f, `No group element found for id "${f}"`);
            const d = Ol(f, o), h = wz(f, t, o);
            Ne(h !== null, `No resize element found for id "${t}"`);
            const m = c.shiftKey ? h > 0 ? h - 1 : d.length - 1 : h + 1 < d.length ? h + 1 : 0;
            d[m].focus();
            break;
          }
        }
    };
    return i.addEventListener("keydown", l), () => {
      i.removeEventListener("keydown", l);
    };
  }, [o, e, t, n]);
}
function Dz({
  children: e = null,
  className: t = "",
  disabled: n = !1,
  hitAreaMargins: o,
  id: i,
  onBlur: l,
  onClick: c,
  onDragging: f,
  onFocus: d,
  onPointerDown: h,
  onPointerUp: m,
  style: v = {},
  tabIndex: b = 0,
  tagName: x = "div",
  ...E
}) {
  var w, C;
  const A = y.useRef(null), M = y.useRef({
    onClick: c,
    onDragging: f,
    onPointerDown: h,
    onPointerUp: m
  });
  y.useEffect(() => {
    M.current.onClick = c, M.current.onDragging = f, M.current.onPointerDown = h, M.current.onPointerUp = m;
  });
  const T = y.useContext(od);
  if (T === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: D,
    groupId: O,
    registerResizeHandle: k,
    startDragging: R,
    stopDragging: N,
    panelGroupElement: P
  } = T, Y = ty(i), [ne, J] = y.useState("inactive"), [ce, ue] = y.useState(!1), [de, I] = y.useState(null), G = y.useRef({
    state: ne
  });
  ba(() => {
    G.current.state = ne;
  }), y.useEffect(() => {
    if (n)
      I(null);
    else {
      const j = k(Y);
      I(() => j);
    }
  }, [n, Y, k]);
  const U = (w = o?.coarse) !== null && w !== void 0 ? w : 15, te = (C = o?.fine) !== null && C !== void 0 ? C : 5;
  y.useEffect(() => {
    if (n || de == null)
      return;
    const j = A.current;
    Ne(j, "Element ref not attached");
    let W = !1;
    return DG(Y, j, D, {
      coarse: U,
      fine: te
    }, (X, se, ie) => {
      if (!se) {
        J("inactive");
        return;
      }
      switch (X) {
        case "down": {
          J("drag"), W = !1, Ne(ie, 'Expected event to be defined for "down" action'), R(Y, ie);
          const {
            onDragging: H,
            onPointerDown: re
          } = M.current;
          H?.(!0), re?.();
          break;
        }
        case "move": {
          const {
            state: H
          } = G.current;
          W = !0, H !== "drag" && J("hover"), Ne(ie, 'Expected event to be defined for "move" action'), de(ie);
          break;
        }
        case "up": {
          J("hover"), N();
          const {
            onClick: H,
            onDragging: re,
            onPointerUp: le
          } = M.current;
          re?.(!1), le?.(), W || H?.();
          break;
        }
      }
    });
  }, [U, D, n, te, k, Y, de, R, N]), YG({
    disabled: n,
    handleId: Y,
    resizeHandler: de,
    panelGroupElement: P
  });
  const he = {
    touchAction: "none",
    userSelect: "none"
  };
  return y.createElement(x, {
    ...E,
    children: e,
    className: t,
    id: i,
    onBlur: () => {
      ue(!1), l?.();
    },
    onFocus: () => {
      ue(!0), d?.();
    },
    ref: A,
    role: "separator",
    style: {
      ...he,
      ...v
    },
    tabIndex: b,
    // CSS selectors
    [yt.groupDirection]: D,
    [yt.groupId]: O,
    [yt.resizeHandle]: "",
    [yt.resizeHandleActive]: ne === "drag" ? "pointer" : ce ? "keyboard" : void 0,
    [yt.resizeHandleEnabled]: !n,
    [yt.resizeHandleId]: Y,
    [yt.resizeHandleState]: ne
  });
}
Dz.displayName = "PanelResizeHandle";
function qG({
  className: e,
  ...t
}) {
  return /* @__PURE__ */ S.jsx(
    zz,
    {
      "data-slot": "resizable-panel-group",
      className: Ge(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        e
      ),
      ...t
    }
  );
}
function ME({
  ...e
}) {
  return /* @__PURE__ */ S.jsx(dz, { "data-slot": "resizable-panel", ...e });
}
function WG({
  withHandle: e,
  className: t,
  ...n
}) {
  return /* @__PURE__ */ S.jsx(
    Dz,
    {
      "data-slot": "resizable-handle",
      className: Ge(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:translate-x-0 data-[panel-group-direction=vertical]:after:-translate-y-1/2 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        t
      ),
      ...n,
      children: e && /* @__PURE__ */ S.jsx("div", { className: "bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border", children: /* @__PURE__ */ S.jsx(QO, { className: "size-2.5" }) })
    }
  );
}
const Em = "http://localhost:5000", zE = "35b0gpu7tBWmLECWnaWn8aawvEr", XG = "You are a helpful assistant. Answer in Vietnamese unless the user asks otherwise.";
async function KG() {
  const e = localStorage.getItem("access_token");
  return e ? { Authorization: `Bearer ${e}` } : {};
}
function JG() {
  return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
}
function QG(e) {
  return e.filter((t) => t.type === "text").map((t) => t.text).join("");
}
function eY(e) {
  const t = e.find((o) => o.role === "user"), n = t ? QG(t.parts).trim() : "";
  return n ? n.length > 60 ? `${n.slice(0, 60)}` : n : "";
}
function tY({
  onClose: e,
  chatId: t,
  onChatIdChange: n
}) {
  const [o, i] = y.useState(""), [l, c] = y.useState([]), [f, d] = y.useState(!1), [h, m] = y.useState(!0), [v, b] = y.useState(null), [x, E] = y.useState(!1), [w, C] = y.useState(
    () => localStorage.getItem("user_id") || void 0 || zE
  );
  y.useEffect(() => {
    const j = () => {
      C(
        localStorage.getItem("user_id") || void 0 || zE
      );
    };
    return window.addEventListener("chatbot:settings-updated", j), () => window.removeEventListener("chatbot:settings-updated", j);
  }, []);
  const A = `${Em}/api/v1/ai-chat`, M = y.useMemo(() => [], []), {
    messages: T,
    status: D,
    sendMessage: O,
    setMessages: k,
    stop: R,
    error: N,
    addToolOutput: P,
    // manual tool approvals
    addToolApprovalResponse: Y,
    clearError: ne
  } = c3({
    id: t,
    sendAutomaticallyWhen: r3,
    transport: new pT({
      api: A,
      fetch: async (j, W) => {
        const $ = await KG();
        return fetch(j, {
          ...W,
          headers: {
            ...$,
            ...W?.headers
          }
        });
      },
      prepareSendMessagesRequest: async ({
        messages: j,
        body: W,
        id: $,
        trigger: X,
        messageId: se
      }) => {
        const ie = await JI(
          j.map(({ id: re, ...le }) => le),
          { ignoreIncompleteToolCalls: !0 }
        ), H = localStorage.getItem("ai-name") || eM;
        return {
          body: {
            ...W ?? {},
            id: $,
            model: H,
            system: XG,
            messages: ie,
            trigger: X,
            messageId: se
          }
        };
      }
    }),
    messages: M,
    generateId: JG,
    experimental_throttle: 100,
    onError: (j) => {
      console.log(" onError:", j);
    }
  }), J = y.useMemo(
    () => T.filter((j) => j.role !== "system"),
    [T]
  ), ce = D === "streaming" || D === "submitted";
  y.useEffect(() => {
    GF(t, T), $F(t, eY(T));
  }, [t, T]), y.useEffect(() => {
    const j = FF(t);
    k(j);
  }, [t, k]), y.useEffect(() => {
    let j = !1;
    return (async () => {
      if (t) {
        E(!0), b(null);
        try {
          const $ = await KF(Em, w, t);
          if (j) return;
          const X = $.messages ?? [];
          k(X);
        } catch ($) {
          if (j) return;
          const X = $ instanceof Error ? $.message : "Failed to load thread";
          !/not found/i.test(X) && !/missing/i.test(X) && b(X);
        } finally {
          if (j) return;
          E(!1);
        }
      }
    })(), () => {
      j = !0;
    };
  }, [t, k, w]);
  const ue = () => m((j) => !j), de = y.useCallback(
    (j) => {
      R(), i(""), c([]), d(!1), D === "error" && ne(), n(j);
    },
    [ne, n, D, R]
  ), I = y.useCallback(
    (j) => {
      R(), i(""), c([]), d(!1), D === "error" && ne(), k([]), n(j);
    },
    [ne, n, k, D, R]
  ), G = y.useCallback(
    async (j) => {
      const W = (j ?? o).trim();
      !W || ce || (D === "error" && ne(), d(!1), i(""), await O({ text: W }));
    },
    [ne, o, ce, O, D]
  ), U = y.useCallback(() => {
    R();
  }, [R]), te = y.useCallback(
    async (j) => {
      await P(j);
    },
    [P]
  ), he = y.useRef(null);
  return y.useEffect(() => {
    he.current?.scrollIntoView({ block: "end" });
  }, [J.length, x, ce]), /* @__PURE__ */ S.jsxs("div", { className: "relative h-full w-full flex flex-col overflow-hidden", children: [
    /* @__PURE__ */ S.jsx(
      $Z,
      {
        onClose: e,
        onToggleSidebar: ue,
        isSidebarOpen: h
      }
    ),
    /* @__PURE__ */ S.jsxs(qG, { direction: "horizontal", className: "flex-1 min-h-0", children: [
      /* @__PURE__ */ S.jsx(
        ME,
        {
          defaultSize: 25,
          minSize: 21,
          maxSize: 26,
          collapsible: !0,
          collapsedSize: 0,
          className: h ? "z-1000 overflow-auto-y" : "hidden",
          children: /* @__PURE__ */ S.jsx(
            nG,
            {
              isOpen: h,
              currentChatId: t,
              onThreadSelect: de,
              onNewThread: I,
              apiBaseUrl: Em,
              userId: w,
              isLoadingThread: x
            }
          )
        }
      ),
      h && /* @__PURE__ */ S.jsx(WG, { withHandle: !0 }),
      /* @__PURE__ */ S.jsx(ME, { defaultSize: 80, minSize: 50, children: /* @__PURE__ */ S.jsxs("div", { className: "h-full flex flex-col gap-2 overflow-y-auto overflow-hidden", children: [
        x ? /* @__PURE__ */ S.jsx(tz, { message: "Loading thread..." }) : /* @__PURE__ */ S.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              className: "flex-1 overflow-hidden",
              "data-chatbot-text": "data-chatbot",
              tabIndex: 0,
              children: /* @__PURE__ */ S.jsx(pM, { className: "h-full pr-2 chat-scroll-area", children: /* @__PURE__ */ S.jsxs("div", { className: "flex flex-col gap-3 py-2 min-h-full justify-end overflow-x-auto wrap-break-word", children: [
                /* @__PURE__ */ S.jsx(VC, { initial: !1, children: J.map((j, W) => /* @__PURE__ */ S.jsx(
                  bG,
                  {
                    message: j,
                    isLast: W === J.length - 1,
                    messageIndex: W,
                    onApproveTool: ($, X) => Y({ id: $, approved: X }),
                    onAddToolOutputDev: ($, X) => {
                      te({
                        tool: X,
                        toolCallId: $,
                        output: { ok: !0 }
                      });
                    }
                  },
                  j.id
                )) }),
                J.length > 0 && ce ? /* @__PURE__ */ S.jsx(xE, {}) : null,
                !f && N ? /* @__PURE__ */ S.jsx(mG, { error: N }) : null,
                v ? /* @__PURE__ */ S.jsxs("div", { className: "px-4 py-2 text-xs text-destructive whitespace-pre-wrap break-words", children: [
                  "Failed to load thread: ",
                  v
                ] }) : null,
                /* @__PURE__ */ S.jsx("div", { className: "min-w-0 min-h-52" }),
                /* @__PURE__ */ S.jsx("div", { ref: he })
              ] }) })
            }
          ),
          J.length !== 0 && /* @__PURE__ */ S.jsx(
            bE,
            {
              value: o,
              onChange: i,
              onSend: G,
              onFilesChange: c,
              files: l,
              opStop: U,
              onStartTyping: () => {
              },
              onUseNextSuggestionChange: () => {
              },
              disabled: ce
            }
          )
        ] }),
        J.length === 0 && /* @__PURE__ */ S.jsxs(y.Fragment, { children: [
          /* @__PURE__ */ S.jsx(pG, {}),
          (D === "streaming" || D === "submitted") && /* @__PURE__ */ S.jsx("div", { className: "flex justify-center py-4", children: /* @__PURE__ */ S.jsx(xE, {}) }),
          /* @__PURE__ */ S.jsx(
            bE,
            {
              value: o,
              onChange: i,
              onSend: G,
              onFilesChange: c,
              files: l,
              opStop: U,
              onStartTyping: () => {
              },
              onUseNextSuggestionChange: () => {
              },
              disabled: ce
            }
          )
        ] })
      ] }) })
    ] })
  ] });
}
function nY() {
  return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
}
function _f(e, t, n) {
  return Math.min(n, Math.max(t, e));
}
function _m() {
  return typeof window > "u" ? { width: 1024, height: 768 } : { width: window.innerWidth, height: window.innerHeight };
}
function Nz(e) {
  const n = Math.max(1, e.width - 32), o = Math.max(1, e.height - 32), i = n >= 280 ? Math.min(500, n) : n, l = o >= 240 ? Math.min(400, o) : o;
  return { padding: 16, minWidth: i, minHeight: l, maxWidth: n, maxHeight: o };
}
function Oz(e, t) {
  return {
    width: _f(e.width, t.minWidth, t.maxWidth),
    height: _f(e.height, t.minHeight, t.maxHeight)
  };
}
function jz(e, t, n, o) {
  const i = o.padding, l = o.padding, c = n.width - t.width - o.padding, f = n.height - t.height - o.padding;
  return {
    x: _f(e.x, i, c),
    y: _f(e.y, l, f)
  };
}
function rY(e) {
  const t = Nz(e), n = Oz({ width: 800, height: 600 }, t), o = jz(
    { x: e.width - n.width - t.padding, y: e.height - n.height - t.padding },
    n,
    e,
    t
  );
  return { size: n, position: o };
}
function oY() {
  const [e, t] = y.useState(!1), [n, o] = y.useState(() => nY()), [i, l] = y.useState(() => _m()), [{ position: c, size: f }, d] = y.useState(() => rY(_m())), h = y.useMemo(() => Nz(i), [i]);
  y.useEffect(() => {
    const v = () => l(_m());
    return window.addEventListener("resize", v), () => window.removeEventListener("resize", v);
  }, []), y.useEffect(() => {
    d((v) => {
      const b = Oz(v.size, h), x = jz(v.position, b, i, h);
      return { size: b, position: x };
    });
  }, [h, i]);
  const m = typeof document < "u" ? document.body : null;
  return m ? Vo.createPortal(
    /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx(
        LO,
        {
          position: c,
          size: f,
          onDragStop: (v, b) => d((x) => ({ ...x, position: { x: b.x, y: b.y } })),
          onResizeStop: (v, b, x, E, w) => {
            d((C) => ({
              ...C,
              size: {
                width: parseInt(x.style.width),
                height: parseInt(x.style.height)
              },
              position: w
            }));
          },
          minWidth: h.minWidth,
          minHeight: h.minHeight,
          maxWidth: h.maxWidth,
          maxHeight: h.maxHeight,
          bounds: "window",
          dragHandleClassName: "chatbot-drag-handle",
          className: "z-50",
          style: {
            position: "fixed",
            opacity: e ? 1 : 0,
            visibility: e ? "visible" : "hidden",
            pointerEvents: e ? "auto" : "none"
          },
          children: /* @__PURE__ */ S.jsx("div", { className: "w-full h-full rounded-2xl shadow-xl border backdrop-blur-md flex flex-col bg-background overflow-hidden z-[1000]", children: /* @__PURE__ */ S.jsx(
            tY,
            {
              onClose: () => t(!1),
              chatId: n,
              onChatIdChange: (v) => o(v)
            }
          ) })
        }
      ),
      e ? null : /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => t(!0),
          className: "fixed bottom-4 right-4 z-50 cursor-pointer p-3 rounded-full border-2 shadow-sm bg-background hover:bg-core-navy-60 hover:shadow-2xl transition-all",
          "aria-label": "Open chatbot",
          type: "button",
          children: /* @__PURE__ */ S.jsx(_g, { className: "h-6 w-6" })
        }
      )
    ] }),
    m
  ) : null;
}
let $r = null;
const aY = {
  init(e) {
    if (!e.apiHost) {
      console.error("ChatbotEmbed: apiHost is required");
      return;
    }
    const t = e.containerId || "chatbot-root";
    let n = document.getElementById(t);
    return n || (n = document.createElement("div"), n.id = t, document.body.appendChild(n)), window.__CHATBOT_CONFIG__ = e, $r || ($r = uO.createRoot(n)), $r.render(
      Jn.createElement(
        Jn.StrictMode,
        null,
        Jn.createElement(oY)
      )
    ), {
      destroy: () => {
        $r && ($r.unmount(), $r = null), n && n.parentNode && n.parentNode.removeChild(n);
      }
    };
  },
  destroy() {
    $r && ($r.unmount(), $r = null);
  }
};
typeof window < "u" && (window.ChatbotEmbed = aY);
export {
  aY as ChatbotEmbed,
  aY as default
};
